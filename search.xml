<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【天翼杯安卓题二】 爱加密脱壳实战]]></title>
      <url>//%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/2017-10-22-aijiami-unpacker.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这个apk使用爱加密加密，加密时间是2017.6月。这个题其实就是个脱壳题，脱完立马见flag。(出题人也太懒了)</p>
<h3 id="壳介绍"><a href="#壳介绍" class="headerlink" title="壳介绍"></a>壳介绍</h3><p>爱加密的壳16年年底就已经开始通过 <code>hook dvmResolveClass</code> ，在调用具体方法时解密方法指令，然后将 DexFile结构体中的对应方法的 <code>md-&gt;insns</code> 指向 解密后的方法指令数据区，然后进入 <code>真正的dvmResolveClass</code>中执行指令，执行完后在重新加密指令，这样就可以防止 <code>dexhunter</code> 等工具在内存中 <code>dump dex</code> 文件。</p>
<p>流程图</p>
<p><img src="/img/android_sec/ijiami_flow.png" alt="流程图"></p>
<p><a href="http://www.cnblogs.com/2014asm/p/6534189.html" target="_blank" rel="external">图片来源</a> </p>
<h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>由上面可以知道，在<code>dvmResolveClass</code>函数执行的时候，代码是已经还原好了的。这时我们去<code>dump</code>相应的指令就是正确的指令。于是修改 <code>dvmResolveClass</code> 的代码，<code>dump</code> 方法的数据。<br>修改 <code>dvmResolveClass</code> 函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*  add dump .....*/   </div><div class="line">    </div><div class="line">  char key_str[20] = &quot;jiajiatest&quot;;</div><div class="line">  int fd=open(&quot;/data/local/tmp/resolve_class_config&quot;,O_RDONLY,0666);</div><div class="line">  if(fd!=-1)&#123;</div><div class="line">    int len = read(fd,key_str,19);</div><div class="line">    key_str[len-1] = &apos;\x00&apos;;</div><div class="line">    key_str[len] = &apos;\x00&apos;;</div><div class="line">    close(fd);</div><div class="line">  &#125;</div><div class="line">  ALOGI(&quot;The key_str ---&gt; %s----referrer-&gt;descriptor---&gt;%s--&quot;, key_str, referrer-&gt;descriptor);</div><div class="line">  </div><div class="line">if(strstr(referrer-&gt;descriptor, key_str))&#123;</div><div class="line">       char task_name[] = &quot;task_name&quot;;</div><div class="line">      char *logbuf = new char[1024];</div><div class="line">      char path[50] = &#123;0&#125;;</div><div class="line">      sprintf(path, &quot;/data/local/tmp/%s_dump_%d&quot;, key_str, getpid());</div><div class="line">      FILE *fpw = fopen(path, &quot;awb+&quot;);</div><div class="line">      for(int i=0; i &lt; referrer-&gt;directMethodCount; i++)&#123;</div><div class="line">        Method* md = &amp;referrer-&gt;directMethods[i];</div><div class="line">        const char* mName_d = md-&gt;name;</div><div class="line">        const u2 insSize_d = md-&gt;insSize;</div><div class="line">        const u2* insns_d = md-&gt;insns;</div><div class="line">        const u2 methodldx_d = md-&gt;methodIndex;</div><div class="line">        u4 insns_d_size = dvmGetMethodInsnsSize(md);</div><div class="line">// ALOGI(&quot;hacklh_md----&gt;%p, i--&gt;%d, directMethodCount--&gt;%d&quot;, md, i,referrer-&gt;directMethodCount);</div><div class="line">        sprintf(logbuf,&quot;-------------- (KL)resolving [class=%s, method=%s, methodIndex=%u, insSize=%u, insns_d=%x, codeSize=%d] in pid: %d(name: %s)&quot;,referrer-&gt;descriptor,mName_d,methodldx_d,insSize_d,(u4)insns_d, insns_d_size,getpid() , task_name);</div><div class="line">        LOGD(&quot;%s&quot;,logbuf);</div><div class="line">        if(fpw != NULL)&#123; </div><div class="line">          fwrite(logbuf,1,strlen(logbuf),fpw);</div><div class="line">          fflush(fpw);</div><div class="line">          fwrite((u1*)insns_d,1,insns_d_size*2, fpw);</div><div class="line">          fflush(fpw);</div><div class="line">        &#125;else&#123;</div><div class="line">          LOGD(&quot;——(KL)open %s fail!&quot;, path);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      for(int i=0; i &lt; referrer-&gt;virtualMethodCount; i++)&#123;</div><div class="line">        Method* mv = &amp;referrer-&gt;virtualMethods[i];</div><div class="line">        const char* mName_v = mv-&gt;name;</div><div class="line">        const u2 insSize_v = mv-&gt;insSize;</div><div class="line">        const u2* insns_v = mv-&gt;insns;</div><div class="line">        const u2 methodIdx_v = mv-&gt;methodIndex;</div><div class="line">        u4 insns_v_size = dvmGetMethodInsnsSize(mv);</div><div class="line">        sprintf(logbuf,&quot;-------------- (KL)resolving [class=%s, method=%s, methodIndex=%u, insSize=%u, insns_d=%x, codeSize=%d] in pid: %d(name: %s)&quot;,referrer-&gt;descriptor,mName_v,methodIdx_v,insSize_v,(u4)insns_v, insns_v_size,getpid() , task_name);</div><div class="line">        LOGD(&quot;%s&quot;,logbuf);</div><div class="line">        if(fpw != NULL)&#123;</div><div class="line">          fwrite(logbuf,1,strlen(logbuf),fpw);</div><div class="line">          fflush(fpw);</div><div class="line">          fwrite((u1*)insns_v,1,insns_v_size*2, fpw);</div><div class="line">          fflush(fpw);</div><div class="line">        &#125;else&#123;</div><div class="line">          LOGD(&quot;%s&quot;,&quot;——(KL)open file fail!&quot;);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      if(fpw != NULL)&#123;</div><div class="line">        fclose(fpw);</div><div class="line">      &#125;</div><div class="line">      delete logbuf;</div><div class="line">/*  add end .....*/</div></pre></td></tr></table></figure>
<p>dump之后我们需要把指令patch到dex对应位置上去，patch的方式有很多种，我选择使用ida脚本对他进行patch。我觉得ida就是一个各种文件格式的loader，我们可以在ida中修改文件的内容，然后可以让ida把修改应用到文件中，以完成patch。 因此在IDA中patch代码十分的方便，而且也很方便的查看patch后的结果。patch代码的流程是： </p>
<hr>
<p>读取dump的方法指令—&gt;定位相应方法指令数据区在ida中的位置—-&gt;patch</p>
<hr>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">#! /usr/bin/python</div><div class="line"># -*- coding: utf8 -*-</div><div class="line"></div><div class="line"># 该脚本用于在ida中使用dump下来的method指令对 dex 进行Patch</div><div class="line">import re</div><div class="line">from dex_parser import dex</div><div class="line"></div><div class="line">#存储 存放dump数据的字典</div><div class="line">data_array = []</div><div class="line">#用来避免多次patch</div><div class="line">patched = []</div><div class="line">file_data = &quot;&quot;</div><div class="line"></div><div class="line">def parse_meta_data(data=&quot;&quot;):</div><div class="line">    # print data</div><div class="line">    ret = &#123;&#125;</div><div class="line">    tokens = re.findall(&quot;\[class=(.*?),.*?method=(.*?),.*?codeSize=(.*?)\]&quot;,data)</div><div class="line">    # print tokens</div><div class="line"></div><div class="line">    ret[&apos;class_name&apos;] = tokens[0][0][1:].replace(&apos;/&apos;,&apos;.&apos;).replace(&apos;;&apos;,&apos;&apos;)</div><div class="line">    ret[&apos;method&apos;] = tokens[0][1]</div><div class="line">    ret[&apos;code_size&apos;] = int(tokens[0][2]) * 2 #dex文件格式定义，总大小为 codeSize*2</div><div class="line">    # print ret</div><div class="line">    return ret</div><div class="line"></div><div class="line">#注释，用于给ida执行</div><div class="line"># def patch_byte(a, b):</div><div class="line">#     print hex(b),</div><div class="line"></div><div class="line">def patch(dest, src, size):</div><div class="line">    print &quot;dest::&#123;&#125;, src::&#123;&#125;, size::&#123;&#125;&quot;.format(dest, src, size)</div><div class="line">    for i in range(size):</div><div class="line">        patch_byte(dest + i, int(file_data[ src + i].encode(&apos;hex&apos;), 16))</div><div class="line"></div><div class="line">    print &quot;\n&quot;</div><div class="line"></div><div class="line">def parse_dump_data(filename):</div><div class="line">    global file_data</div><div class="line">    with open(filename, &quot;rb&quot;) as fp:</div><div class="line">        file_data = fp.read()</div><div class="line"></div><div class="line">    #使用正则表达式把说明dump数据的元数据加载到内存</div><div class="line">    all_item = re.findall(&quot;-------------- \(KL\)resolving(.*?) in pid:.*?\(name: task_name\)&quot;, file_data)</div><div class="line">    offset = 0</div><div class="line">    for meta_data in all_item:</div><div class="line">        try:</div><div class="line">            #使用字典组织数据</div><div class="line">            #&#123;&apos;class_name&apos;: &apos;com.example.jiajiatest.MainActivity&apos;, &apos;code_size&apos;: 306, &apos;method&apos;: &apos;add&apos;, &apos;data_offset&apos;: 7175&#125;</div><div class="line"></div><div class="line">            ret = parse_meta_data(meta_data)</div><div class="line">            data_addr = file_data.find(&apos;(name: task_name)&apos;, offset) + 17</div><div class="line">            ret[&apos;data_offset&apos;] = data_addr</div><div class="line">            data_array.append(ret)</div><div class="line">            offset = data_addr</div><div class="line">        except Exception as e:</div><div class="line">            raise e</div><div class="line"></div><div class="line">    return data_array</div><div class="line"></div><div class="line">def get_method_addr(method_data, signature_str):</div><div class="line">    for md_name in method_data:</div><div class="line">        if signature_str in md_name:</div><div class="line">            return method_data[md_name]</div><div class="line">    return -1</div><div class="line"></div><div class="line">def patch_dex(dump_data_file, dex_file):</div><div class="line">    dump_data = parse_dump_data(dump_data_file)</div><div class="line">    dex_obj = dex.dex_parser(dex_file)</div><div class="line">    method_data = dex_obj.get_class_data()</div><div class="line"></div><div class="line">    for item in dump_data:</div><div class="line">        signature_str = &quot;&#123;&#125;::&#123;&#125;&quot;.format(item[&apos;class_name&apos;], item[&apos;method&apos;])</div><div class="line">        if  signature_str not in patched:</div><div class="line"></div><div class="line">            #获取要patch的目标地址</div><div class="line">            addr = get_method_addr(method_data, signature_str)</div><div class="line">            if addr == -1:</div><div class="line">                print &quot;&#123;&#125; can&apos;t get insns addr&quot;.format(signature_str)</div><div class="line">                continue</div><div class="line">            #do patch</div><div class="line">            print &quot;patch &quot; + signature_str,</div><div class="line">            patch(addr,item[&apos;data_offset&apos;],item[&apos;code_size&apos;])</div><div class="line">            patched.append(signature_str)</div><div class="line"></div><div class="line">    # print patched</div><div class="line">    # for i in patched:</div><div class="line">    #     print i</div><div class="line"></div><div class="line">import pprint</div><div class="line"></div><div class="line">patch_dex(&quot;F:\code_workplace\ida_script\jiajiatest_dump_20406&quot;,&quot;F:\code_workplace\ida_script\classes.dex&quot; )</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    print &quot;comming main&quot;</div><div class="line">    # parse_dump_data(&quot;F:\code_workplace\ida_script\jiajiatest_dump_20406&quot;)</div><div class="line">    # patch_dex(&quot;F:\code_workplace\ida_script\jiajiatest_dump_20406&quot;,&quot;F:\code_workplace\ida_script\classes.dex&quot; )</div><div class="line">    # dex_obj = dex.dex_parser(&quot;F:\code_workplace\ida_script\classes.dex&quot;)</div><div class="line">    # class_data = dex_obj.get_class_data()</div><div class="line">    # pprint.pprint(class_data)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    # parse_meta_data(&quot;-------------- (KL)resolving [class=Lcom/example/jiajiatest/HttpRunner;, method=makeImgHttpGET, methodIndex=13, insSize=2, insns_d=6daf04d8, codeSize=270] in pid: 20406(name: task_name)&quot;)</div></pre></td></tr></table></figure>
<p>patch前后对比：</p>
<p>patch前</p>
<p><img src="/img/android_sec/ijiami_raw.png" alt="raw"></p>
<p>patch后</p>
<p><img src="/img/android_sec/ijiami_patch.png" alt="patched"></p>
<p>这时已经可以看到程序的主体逻辑了。然后查看字符串就可以拿到flag………</p>
<h3 id="我干的傻事"><a href="#我干的傻事" class="headerlink" title="我干的傻事"></a>我干的傻事</h3><ul>
<li><p>代码循环条件忘记写了，导致越界，一打开应用就报错。 </p>
</li>
<li><p>文件打开失败，貌似是权限问题，我直接暴力把 <code>/data/local/tmp</code> 改成 777</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 分析安卓底层代码的错误，要关注 <code>logcat</code> 日志，找到出问题的代码点，然后把库的带符号版本放到ida中分析<br>分析bug, 要看代码的关键逻辑， 判断条件等。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>要多实践，如有问题请在下面评论。</p>
]]></content>
      
        <categories>
            
            <category> 安卓安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 安卓脱壳 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
